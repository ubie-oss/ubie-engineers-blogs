{"pageProps":{"member":{"id":"shiraji","nickname":"しらじ","realName":"磯貝佳典","bio":"家紋アイコンしらじです。フロント、バックエンドやってます","avatarSrc":"/avatars/shiraji.png","sources":["https://shiraji.hatenablog.com/feed"],"includeUrlRegex":"shiraji.hatenablog.com","twitterUsername":"shiraj_i","githubUsername":"shiraji","websiteUrl":"https://shiraji.hatenablog.com"},"postItems":[{"title":"Ubie(が関わる医療データ)の話を聞いてくれ！！！","contentSnippet":"先日、初めて、Meetyさん経由でカジュアル面談をさせて頂きました。meety.netちなみにカジュアル面談とは名ばかりの会でUbieの紹介とか一切せず、リンク先にある内容の通り、ひたすら医療情報に関して話しました。資料もさくっと作って、それをベースに話していたのですが、それを社内にちら見せしたらなかなか好評で、じゃあこの話をブログにも書いてみようということで、今ブログを書いております。医療のレガシーデータから会社(Ubie)を守りたい というタイトルのスライドです。全体としてはタイトル入れて16Pあります。スライドは直接お話しする時のお楽しみと言うことで今日はそのうちの何枚かを使い内容を紹介します。二つのトピックに関して話しています。医療データとは何か？Ubieではどう守っているのか？医療データとは何か？まず医療データですが、ざっくりというと2種類あります。Ubie社内で生成しているデータ外部に委託して生成しているデータそれぞれ説明していきます。Ubie社内で作っているデータ社内の医師が作っている・監修しているデータ医師がスクラムに入り、開発に必要なデータを必要なタイミングで作っていきます海外向けの方はシンガポールにいるグローバル担当医師（日本語話せない）が担当データの管理方法や同期方法も説明しますが、詳しくはこちらで！meety.net外部に委託して生成しているデータ薬、ICD10(国際疾病分類)、医療機関情報、これらは外部に委託しています。電カルベンダーさんや薬局でこういったデータが使われています。私たちもそのデータを使わせてもらおうと思ったのですが、いくつか問題があります。IDは変わるものCSVで最新版のみもらえるはい、IDは変わるものです数百万レコード月1更新 -> 普通にdumpしたら、サービス止まる（実績あり）これらは代表的なものですが、他にもいくつか問題があります。委託のデータが悪いわけではなく、それらの本来の目的とUbieのようなWebサービスのデータに対する狙いが乖離しているために発生している問題です。業界ではUbieの方がまだまだ異端児だったりします。詳細はmeety.netCalendlyも用意してあるよ！！！calendly.comあと、今回話さなかったので、ここで初出しですが、実は外部委託のデータから内製に切り替えたデータも存在しています。これは外部委託のデータがあまりに多く、そのまま利用するとデータが多すぎて逆にユーザを混乱させてしまうのがわかったため、社内医師により、内製に切り替えました。このあたりの話も当然・・・各種サービスでのデータの扱い方そのまま使う組み合わせて使うユーザが上書きして使う可能性あるほとんどがUbieの内製データそのまま利用することが多いですが、内製データと委託しているデータを組み合わせて使っているものもあります。さらに最近は、社内外のユーザがそのデータを上書きすることもあります。これはいろいろここで書くと長くなりますので、ぜひカジュアル面談でお話ししましょう！meety.netUbieではどう守っているのか？次にUbieでは実際どうUbieのシステムを外部のデータから守っているかの説明です。ざっくりとしたアーキテクチャ図を見ながら実際どうやっているのかを説明します。このアーキテクチャでどうデータを入れているのか？システムを止めないか？他のサービスとの関わり方などを・・・もう話した方が早いんで、応募してもらえませんか？meety.netcalendly.comTwitter DM公開してます。Meetyさんのチャット自分気づけないので、出来たらこっちの方が連絡取りやすいです！twitter.com最後に最後に現在対応している問題について説明します。上書きできるデータに対して、データの優先度を考えたり、月1の更新をしたり、以下略！ということで、絶賛お話相手になってくれる方募集しております。meety.net最後2Ubieではどのポジションも絶賛採用中です。特にこのブログにアクセスするであろうエンジニアは常に人員が足りません。一度ぜひこちら見てみてください。recruit.ubie.lifeあと、実はですね、Ubieは生活者向けのサービスも作っています。体調が悪くなった人がスマホで受診相談が出来ます。ちょっと体調悪いなー病院行った方が良いかもなー？不安だなーって人はぜひこれを使ってみてください。ubie.app最後にUbieの普通のカジュアル面談して欲しいという方はこちらを見てください。https://meety.net/matches?q=Ubie以上です。それではカジュアル面談応募楽しみに待ってます！","link":"https://shiraji.hatenablog.com/entry/2021/09/02/115748","isoDate":"2021-09-02T02:57:48.000Z","dateMiliSeconds":1630551468000,"authorName":"しらじ","authorId":"shiraji"},{"title":"graphql-javaで@deprecatedがついてるフィールドにアクセスするクエリを見つける","contentSnippet":"graphql-javaを使っていて、@deprecatedのdirectiveをつけているのに、ずっとアクセスがあるので、どのクエリがアクセスしてくんの？ってなりました。そこで、このクエリを見つけようと思います。tl;dr以下をコピペすればOK@Componentclass LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {    private val log = LoggerFactory.getLogger(LogDeprecatedQueryInstrumentation::class.java)    private val deprecatedFieldMap = mutableMapOf<String, MutableSet<String>>()    override fun beginExecution(parameters: InstrumentationExecutionParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginExecution(parameters)        val id = parameters.executionInput.executionId.toString()        val query = parameters.query.takeIf { it.isNotBlank() } ?: return super.beginExecution(parameters)        return whenCompleted { _, _ ->            if (deprecatedFieldMap[id]?.isNotEmpty() == true) {                log.warn(                    \"\"\"                        |Accessing deprecated field: ${deprecatedFieldMap[id]?.joinToString()}                        |Query:                         |$query                    \"\"\".trimMargin()                )            }            deprecatedFieldMap.remove(id)        }    }    override fun beginField(parameters: InstrumentationFieldParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginField(parameters)        val id = parameters.executionContext.executionId.toString()        if (parameters.field.isDeprecated) {            if (deprecatedFieldMap.containsKey(id)) {                deprecatedFieldMap[id]?.add(parameters.field.name)            } else {                deprecatedFieldMap[id] = mutableSetOf(parameters.field.name)            }        }        return super.beginField(parameters)    }}想定読者graphql-javaでの開発をしたい、している人graphql-spring-boot-starterを使ったことがある人@deprecatedまず最初に@deprecated、これはgraphql-java自体がデフォルトでバンドルしているdirectiveの一つです。directiveに関しては様々なところでその存在含め議論されていますが、一旦ここでは忘れることにします。公式ドキュメントを見てもらえれば、わかりますが、@deprecatedはSDLのフィールドとEnumにつけることが可能で、これをつけることにより、そのフィールドやEnumは非推奨であるということをSDL上で宣言することが可能です。type Drug {    # 医薬品名    name: String!    # 効能効果    description: String @deprecated(reason: \"No longer supported\")}type Query {    # 薬名から薬情報を取得する    drugsByName(name: String!) : [Drug!]}ちなみに余談ですが、この設定をして、GraphiQLを起動すると、deprecatedのワーニングが出ます。deprecatedのワーニングが出る新規クエリに関してはこれを見てもらえれば明確であるため、わかるのですが、問題はすでに動いているクエリです。@deprecatedを後でつけたとしても、利用側はそれに気づくことはできません。クエリをログに吐くどんなクエリがリクエストされているかはいくつかの方法でログにすることが可能です。今回はInstrumentationを使ってログを出力してみます。Instrumentation[Instrumentation] allows you to inject code that can observe the execution of a query and also change the runtime behaviour.www.graphql-java.comクエリ実行中に何が起こっているのか確認したり、実行時の挙動を変えたりするための仕組みです。実装はInstrumentationやSimpleInstrumentationなどのクラスを継承するだけです。(instrumentationの登録方法はgraphql-java-kickstartを使っていると、@Componentなどにすれば、特に何もせずに登録されるため、ここでは一旦省略します。)@Componentclass LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {}Instrumentationには様々なタイミングでコードをInjectする方法が提供されています。/** * This is called right at the start of query execution and its the first step in the instrumentation chain. * * @param parameters the parameters to this step * * @return a non null {@link InstrumentationContext} object that will be called back when the step ends */InstrumentationContext<ExecutionResult> beginExecution(InstrumentationExecutionParameters parameters);beginExecutionはクエリの実行が始まる直前に呼ばれるメソッドです。引数は InstrumentationExecutionParameters でこのオブジェクトには実行前のクエリ情報やスキーマ情報が格納されています。@Componentclass LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {    private val log = LoggerFactory.getLogger(LogDeprecatedQueryInstrumentation::class.java)    override fun beginExecution(parameters: InstrumentationExecutionParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginExecution(parameters)        log.info(parameters.query)        return super.beginExecution(parameters)    }}これでクエリを実行してみると以下のようにクエリがログに出力されます。INFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - {  drugsByName(name: \"ハチミツ\") {    name    description  }}deprecatedフィールドをログに吐く次にフィールドが @deprecated を判定したいです。各フィールドにアクセスする度に実行されるメソッドは beginField です。    /**     * This is called just before a field is resolved into a value.     *     * @param parameters the parameters to this step     *     * @return a non null {@link InstrumentationContext} object that will be called back when the step ends     */    InstrumentationContext<ExecutionResult> beginField(InstrumentationFieldParameters parameters);引数は InstrumentationFieldParameters その取得しようとしているフィールドの情報が格納されています。そのフィールドに @deprecatedがついているかどうか？は parameters.field.isDeprecated で確認できます。    public boolean isDeprecated() {        return deprecationReason != null;    }isDeprecatedの実装が若干本当にそれで判断するの！？って初見で驚きましたが、見なかったことにしましょう。実際にそのフィールドが@deprecatedだった場合、フィールド名とそのパスをログ出力するようにしてみます。@Componentclass LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {    private val log = LoggerFactory.getLogger(LogDeprecatedQueryInstrumentation::class.java)    override fun beginField(parameters: InstrumentationFieldParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginField(parameters)        if (parameters.field.isDeprecated) {            log.info(parameters.field.name)        }        return super.beginField(parameters)    }}そうするとこんな感じのログが出ました。INFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - descriptionINFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - descriptionINFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - descriptionINFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - descriptionINFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - descriptionINFO  a.u.m.p.i.LogDeprecatedQueryInstrumentation - description6回出力されているのは、\"はちみつ\"という名前のついている薬が6個あるためです。（はちみつは薬です。）[余談] N+1問題で障害発生6回出力されている時点で明確なのですが、beginFieldメソッドは出力するフィールド全てで出力されます。要するにこのメソッドはN+1問題が確実に発生するメソッドであるので、注意が必要です。当初、自分はinfoログではなく、errorログを出力するように実装していました。    override fun beginField(parameters: InstrumentationFieldParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginField(parameters)        if (parameters.field.isDeprecated) {            log.error(parameters.field.name)        }        return super.beginField(parameters)    }この処理を本番に出した結果、本番で障害を出しました (テヘペロ理由として、これは完全に見落としだったのですが、errorログを出力するとSentryへのワーニングを出力するように設定されていました。QA環境やステージング環境でもSentryへのワーニングが発生していたのですが、本番と違いそこまで負荷がかからず、通知も数件という感じで問題ない判定になっていました。しかしそこは本番環境、アクセスが多く、Deprecatedフィールドへのアクセスもあり、Sentryへの通知をめちゃめちゃしてしまいました。この通知処理があまりに多く、サーバがその負荷に耐えられずにダウンしてしまっていました。infoログ(通知なし)に変えたら、問題なく動き出したときは、人生で初めてログ出力変えることによって動くようになるプログラム書いてしまったか・・・という衝撃を受けました。deprecatedフィールドを一回だけ出力する(方針編)話を戻して、deprecatedフィールドへのアクセスを検知したら、クエリ毎に一回だけ出力されれば十分であるため、一回のみ出力されるように修正します。方針として以下となります。beginExecutionでクエリを取得beginFieldでdeprecatedフィールドの検知をする全ての処理が終わった時に、deprecatedフィールドがある場合、クエリをログ出力するこんな感じの方針で行こうと思います。whenCompletedメソッドInstrumentationやSimpleInstrumentationクラスは全て begin しか提供されていません。終わった時の処理はwhenCompletedメソッドを利用します。/**     * Allows for the more fluent away to return an instrumentation context that runs the specified     * code on instrumentation step completion.     *     * @param codeToRun the code to run on completion     * @param <U>       the generic type     *     * @return an instrumentation context     */    public static <U> SimpleInstrumentationContext<U> whenCompleted(BiConsumer<U, Throwable> codeToRun) {        return new SimpleInstrumentationContext<>(null, codeToRun);    }使い方は各種beginメソッド内で利用可能です。class LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {    private val log = LoggerFactory.getLogger(LogDeprecatedQueryInstrumentation::class.java)    override fun beginExecution(parameters: InstrumentationExecutionParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginExecution(parameters)        log.info(\"beginExecution[${parameters.executionInput.executionId}]\")        return whenCompleted { _, _ ->            log.info(\"beginExecution[${parameters.executionInput.executionId}] - whenCompleted\")        }    }    override fun beginField(parameters: InstrumentationFieldParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginField(parameters)        log.info(\"beginField[${parameters.field.name}]\")        return whenCompleted { _, _ ->            log.info(\"beginField[${parameters.field.name}] - whenCompleted\")        }    }}実際に使ってみるとこんな感じのログになります。beginExecution[034a160a-4c3a-498f-a305-43f954445fb9] // -- (1)beginField[drugsByName] // -- (2)beginField[name] // -- (3)beginField[name] - whenCompleted // -- (4)beginField[description] // -- (5)beginField[description] - whenCompletedbeginField[name]beginField[name] - whenCompletedbeginField[description]beginField[description] - whenCompletedbeginField[name]beginField[name] - whenCompletedbeginField[description]beginField[description] - whenCompletedbeginField[name]beginField[name] - whenCompletedbeginField[description]beginField[description] - whenCompletedbeginField[name]beginField[name] - whenCompletedbeginField[description]beginField[description] - whenCompletedbeginField[name]beginField[name] - whenCompletedbeginField[description]beginField[description] - whenCompletedbeginField[drugsByName] - whenCompleted // -- (6)beginExecution[034a160a-4c3a-498f-a305-43f954445fb9] - whenCompleted // -- (7)(1)でbeginExecutionの最初のログが出力されます。(2)でbeginFieldのdrugsByNameのログが出力されます。GraphQLではメソッド定義？もフィールド扱いです。(3)でnameフィールドのログ、(4)でそのフィールドへのアクセスが終わった時のログ(5)で次のdescriptionフィールドのログ(6)で(2)でアクセスしていたdrugsByNameへのアクセスが終わった時のログ(7)でクエリ実行全体が終わった時のログexecutionIdwhenCompletedメソッドの実装時にしれっと使いましたが、executionIdというものがexecution毎に振られます。このIDはexecution毎にユニークで、どのexecutionの処理をしているのかを確認することが可能になります。class LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {    private val log = LoggerFactory.getLogger(LogDeprecatedQueryInstrumentation::class.java)    override fun beginExecution(parameters: InstrumentationExecutionParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginExecution(parameters)        log.info(\"beginExecution[${parameters.executionInput.executionId}]\")        return whenCompleted { _, _ ->            log.info(\"beginExecution[${parameters.executionInput.executionId}] - whenCompleted\")        }    }    override fun beginField(parameters: InstrumentationFieldParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginField(parameters)        log.info(\"beginField[${parameters.executionContext.executionId}]\")        return whenCompleted { _, _ ->            log.info(\"beginField[${parameters.executionContext.executionId}] - whenCompleted\")        }    }}例えばこんな感じの実装で確認してみます。ログ出力してみるとbeginExecution[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7]beginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginField[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompletedbeginExecution[a83e77aa-8f51-4499-95af-75c4240ab0b7] - whenCompleted一つのクエリ実行が完了するまで同じIDになります。ちなみにこんなクエリを実行してみます。{  one: drugsByName(name: \"ハチミツ\") {    name    description  }    two: drugsByName(name: \"ロキソプロフェン\") {    name    description  }}複数のフィールドへのアクセスですが、クエリの実行としては同一であるため、同じIDで全て実行されています。beginExecution[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompleted// 長いので省略beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45]beginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginField[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedbeginExecution[60010edd-dd6c-4490-a3d9-fa92e167ce45] - whenCompletedExceptionが出た時もwhenCompletedは実行されてます。以下がRuntimeExceptionが出た時のログです。beginExecution[9e729dab-5fbe-4611-b6db-22c0a1f78406]beginField[9e729dab-5fbe-4611-b6db-22c0a1f78406]Exception while fetching data (/drugsByName) : エラーだよjava.lang.RuntimeException: エラーだよ// stacktracebeginField[9e729dab-5fbe-4611-b6db-22c0a1f78406] - whenCompletedbeginExecution[9e729dab-5fbe-4611-b6db-22c0a1f78406] - whenCompleteddeprecatedフィールドを一回だけ出力する(実装編)方針をもう一度確認します。beginExecutionでクエリを取得beginFieldでdeprecatedフィールドの検知をする全ての処理が終わった時に、deprecatedフィールドがある場合、クエリをログ出力するこちらですが、whenCompletedメソッドを使うことにより、beginFieldでアクセスできるInstrumentationExecutionParametersにクエリ実行後にもアクセスできるため、クエリの取得とログ出力は同時に可能です。新しい方針としてはこんな感じにbeginFieldでdeprecatedフィールドの検知をするbeginExecutionのwhenCompletedでdeprecatedフィールドがある場合、クエリをログ出力するdeprecatedフィールドを検知した場合、先ほどのexecutionIdを何処かに格納して、beginExecutionのwhenCompletedでログ出力、不必要になったexecutionIdは削除という感じで実装していきます。で、今回は簡単にフィールド変数に格納しましょう。@Componentclass LogDeprecatedQueryInstrumentation : SimpleInstrumentation() {    private val log = LoggerFactory.getLogger(LogDeprecatedQueryInstrumentation::class.java)    private val deprecatedFieldMap = mutableMapOf<String, MutableSet<String>>()    override fun beginExecution(parameters: InstrumentationExecutionParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginExecution(parameters)        val id = parameters.executionInput.executionId.toString()        val query = parameters.query.takeIf { it.isNotBlank() } ?: return super.beginExecution(parameters)        return whenCompleted { _, _ ->            if (deprecatedFieldMap[id]?.isNotEmpty() == true) {                log.warn(                    \"\"\"                        |Accessing deprecated field: ${deprecatedFieldMap[id]?.joinToString()}                        |Query:                         |$query                    \"\"\".trimMargin()                )            }            deprecatedFieldMap.remove(id)        }    }    override fun beginField(parameters: InstrumentationFieldParameters?): InstrumentationContext<ExecutionResult> {        parameters ?: return super.beginField(parameters)        val id = parameters.executionContext.executionId.toString()        if (parameters.field.isDeprecated) {            if (deprecatedFieldMap.containsKey(id)) {                deprecatedFieldMap[id]?.add(parameters.field.name)            } else {                deprecatedFieldMap[id] = mutableSetOf(parameters.field.name)            }        }        return super.beginField(parameters)    }}で、これを実行してみるとAccessing deprecated field: descriptionQuery: {  drugsByName(name: \"ハチミツ\") {    name    description  }}これで障害起こさず、悪いクエリを見つけることが出来ました。まとめるまとめるとInstrumentationやSimpleInstrumentationなどのクラスで出力されるフィールドベースでアクセスすることが可能beginメソッドを使いのなしてねbeginFieldはN+1になるので扱い注意！beginFieldはN+1になるので扱い注意！whenCompletedメソッドはそのアクセスが終わった後に呼ばれるよ終わり。","link":"https://shiraji.hatenablog.com/entry/2021/04/29/225517","isoDate":"2021-04-29T13:55:17.000Z","dateMiliSeconds":1619704517000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Ubieのリモートワーク(テレワーク, WFH)を活用して、子育てが充実した話","contentSnippet":"みなさん、リモートワーク、テレワーク、WFH生活どうでしょうか？この生活がどれだけ続くか分かりませんが、案外会社が回ることがわかったことですし、新型コロナウイルス問題収束したあかつきにはリモートでの仕事をすることができるような日々が来るかもしれませんね。そんなご家庭にこんな働き方もありまっせ！ということで、決まった曜日にリモートをすることにより、共働きの家庭の未就学児に習い事をさせ、子育てを充実させてみたので、それについて書いてみます。前提Ubieの定義Ubieには2020年3月現在、UbieとUbie AI Consulting(UAC)の2つの組織が存在しています。このエントリーでは私が所属している開発を主に担当しているDevチームの話になります。UbieのDevチームはコアタイムなしのフルフレックス制度を採用しています。UACの詳細はきっと UAC代表 がどこかでしてくれると思います。楽しみにしていてください。平日の子供の習い事共働きで保育園に子供を通わせてるご家庭ならわかってくれるはず！と思うのですが、平日子供に習い事をさせるのはほぼほぼ無理です。平日の習い事は15時には帰宅する幼稚園に通っている子供向けに時間が設定されており、15:30~16:00くらいからスタートし、18:00までには終わる時間になっています。6時間勤務の時短を使っているご家庭は16:00~17:00くらいに退社することが多いはずです。その時間に会社から子供を迎えに行き、習い事のところまで届けるとしてもかなり厳しいです。私たち夫婦はフルタイムの共働きで、私がUbieに入社するまでは平日の習い事なんて考える余地がないくらい無縁なものでした。リモート利用状況Ubieには新型コロナウイルス問題以前から週2日のリモートワーク制度が存在しています。新型コロナウイルス問題以前の私のだいたいなリモート利用状況はこんな感じです。月曜日 基本出社。木、金に出勤すべき予定が入っていれば、リモート火曜日 リモート水曜日 会社の出社推奨日であるため、出社木曜日 予定が無ければリモート金曜日 木曜日がリモートできなければ、リモート1年間このルールに則って出社したりリモートしたりしていました。少なくとも週1は必ずリモートでした。それと半年経過して書いたエントリーにもありますが、出社時間は10:00-17:30にして、子供の送り迎えをし、タスク消費量が足らないので、その後は家で仕事をしています。shiraji.hatenablog.com水曜日水曜日だけ特殊で、出社推奨日となっています。基本この日はリモートせずに対面でみんな集まろう！と決まっています。その水曜日はスプリントのレビュー、全社でOKRの進捗確認、全員でやる採用定例などなどを実施しています。月、木、金月曜日をリモートしてしまうと水、木、金と三日連続で満員電車に乗らないといけない状況に陥るので、基本的に木、金のどちらかをリモートするようにしていました。あと月曜に出社すると週が始まった感があってシャキーン！🤩としてその週のパフォーマンスが若干よくなってる印象があります。。。（多分気のせい）火曜日さて本題の火曜日のお話です。習い事に通わせる経緯そもそもの発端は4歳児の運動会の時でした。私の息子は他の子たちと比べ、明らかに運動が出来ない子という感じで各競技をこなしていました。別に苦手なら苦手で良いのですが、息子は運動することがどちらかと言うとかなり好きな方であり、息子自身も何か歯痒いそうな感じが見て取れました。納得が出来ず妻と2人で振り返りをしました。そこで気づいたのが私と妻は共に保育園や学生時代は早く家に帰ってくることができる子供で、帰ってきたら外で遊ぶ生活をしていたそのため、子供とは親が何もせずとも普通に運動ができるものだと言う認識だった息子は家に帰ってくるのが19:30過ぎ。平日運動する機会が他の子供たちと比べ少なく、運動する機会を提供できていない完全に私たち親の問題だと気づきました。そこで運動ができる習い事をさせてあげようと探し始めました。ただ4歳児ともなると習い事をする子供が多く、特に保育園児が通う事ができる土日の習い事は半年待ち（ただし半年で入れるとは言ってない）状態で、空いていたのが、火曜日の15:30~17:30までやっている運動教室でした。当時まだUbieに入社して数ヶ月でリモートもあまり積極的に活用していませんでした。しかし、この習い事に通わせるため、数ヶ月週2リモート+フレックス生活を試し、自身のパフォーマンスを落とさずに仕事ができることを確認してから、息子をその習い事に通わせることにしました。初日にその習い事のお試し体験をさせてもらいました。あの時の息子の笑顔や楽しそうな大きな声は1年経った今でも鮮明に覚えています。本当に心から運動することを楽しんでいる息子を見て、ものすごく嬉しかったし、同時になんでもっと早く気づいてやれなかったのか？と後悔もしました。何がなんでもこの生活を回していくぞと決めた日でもありました。スケジュールざっくりとした火曜日のスケジュールはこんな感じです。火曜日のタイムテーブル夜は21時くらいまでは仕事してますが、子供の習い事のときの自分のパフォーマンスが悪かったら、もう少し遅くまで仕事してますし、そのスプリントで進捗良ければ、20時頃には切り上げたりしています。（冷静に考えて奥さん仕事し過ぎでは？🤔）火曜日午後の会議順調にリモートしつつ、習い事に行かせる生活を送っていたのですが、7月頃に大きな問題が発生しました。その時まで実は私と大半がリモートの業務委託の人たちだけのチームに所属していたため、同期的なコミュニケーションを取らずにリモートで仕事をすることができていました。しかし、7月頃にオフィスでスクラムをバリバリこなしているチームへ移籍となり、同期的なコミュニケーションが必要になりました。スクラムの各種セレモニーにも参加する必要があります。特にこのチームに移籍することの問題だったのが火曜日の午後に実施していたリファインメントでした。リファインメントは重要なスクラムセレモニーの一つで一回出ることが出来ないと次以降のスプリントのキャッチアップすることが厳しくなります。このタイミングで子供の習い事を辞めさせることを検討すべきかもしれませんが、あの笑顔を見た後にこの習い事をやめさせることは私の中に選択肢としてありませんでした。そこで、チームにリファインメントを午前中に変更してもらえないか？と話したところ、こんなプライベートな理由だったのですが、快くリファインメントの時間を変更してくれました。Ubieの本当に素晴らしいところは、チームメンバーのパフォーマンスを最大限引き出せる環境をみんなが真剣に考えて作ってくれる事です。この件に関して本当に感謝する事しか出来ません。ありがとうございます。この判断をしてくれたことにより、パフォーマンスを落とさず、習い事に通わせつつ、スクラムの一員になることが出来ました。その後また別のチームに参加することになったのですが、火曜日の午後は基本会議を入れないように配慮してもらっています。時間がどうしても合わず、今までに2回この時間に会議が入ったのですが、教室からリモートで参加をさせてもらいました。子供や周りの声が入り、聞こえづらい時があったのでノイズキャンセリングのヘッドフォンが必要だなーという感じでした。私が頻繁に発言するような会議がもしその時間に組まれた場合は子供たちの声を拾ってしまうことと、周りのママさんたちに迷惑になりそうなので、教室の外に行った方が良いかもしれないなーと考えています。結果Ubieやチームのサポートのおかげで、保育園の送迎など子育てを中心にした仕事のスケジュールを組むことができるようになっています。4歳児の時はとにかく何事もなく終わらせることしか頭になかったようですが、5歳児の運動会のダンスでは一番難しい技を出すグループに自ら手を上げて参加し、本番で成功させていました。走り方もすごく綺麗なフォームでしっかり走れていました。祖父母も明らかによくなったと喜んでいました。本人もやれることが増えて自信が顔に出ていました。保育園の先生からいろんなことを自ら積極的にやれるようになったと聞いています。卒園式では、園の毎年恒例である式の最後に、「園児が保護者のうち1人を呼び、感謝され、いろんな人に写真撮られつつ一緒に退室していく」という保護者の晴れ舞台を作るための時間がありました。普通その場で呼ばれるのは子育てに多くの時間を割いている「ママ」です。今年もクラスの大半が「ママ」を選択しました。しかしうちの息子は練習の時から「パパ」一択だったそうで、他の子に何を言われようが、先生に何を言われようが、ママ・パパに何を言われようが「パパ」にすると言っていました。息子は私が子育てに参加してることをしっかり認識してくれてることが本当に嬉しかったです。念のため明記しておきますが、妻も世間一般のママと同じかそれ以上にしっかりと子育てに参加してます。私と同様に息子に愛情を注いでいる素晴らしいママです。今後卒園式と書いてある通り、4月から息子は小学生になります。また生活がガラッと変わりそうですが、Ubieは柔軟に働くことができる環境なので、問題が発生したら都度チームに相談して解決していこうと思います。まとめリモートワーク、テレワーク、WFHも良いけど、フルフレックスのUbieならうまく時間を合わせられたら、子育て充実させられるよ！さて、そのUbieですが、現在絶賛採用募集中です。Webエンジニア、QAエンジニア、SRE、MLエンジニア、データエンジニア全ポジション募集中です。どのポジションも事業成長スピードと比較して全然人が足らないので、興味のある方はぜひwww.figma.comubie.lifeまた、このエントリーでは詳細説明しておりませんが、UACと言う組織が現在立ち上がりのフェーズに入っています。こちらも全然人が足らない！マーケティングやセールスが武器だ！と言える人ぜひ検討してください！！！ speakerdeck.com","link":"https://shiraji.hatenablog.com/entry/2020/03/15/070000","isoDate":"2020-03-14T22:00:00.000Z","dateMiliSeconds":1584223200000,"authorName":"しらじ","authorId":"shiraji"},{"title":"IntelliJプラグインでAnnotate機能を作った","contentSnippet":"はじめにこれは Ubie Advent Calendar 2019 - Qiita の21日目の記事です。想定読者(開発方法セクションより前)Find pull requestプラグインの開発・利用をしている人(開発方法セクション以降)IntelliJプラグインをがっつり開発したことがあるAnnotate機能を作りたい人本題まずはこれを見て欲しい。以前から欲しいなーって思っていたのだけど、プライベートの時間の捻出が出来ず、主に眠気に勝てないのが原因で、なかなか腰が上がらなかったんですが、息子くんがすんなり寝てくれて2時間くらい時間が出来たので、さくっと作ってみた。その後Twitterに成果報告して寝た。Look! I managed to list all PR up like Annotate in IntelliJ editor (gutter)✌️✌️✌️PRの一覧、annotateみたいに出来たー。気になる点が残り数点あるからそれら対応したらリリース出来そう。Tooltipとかは初期リリースから外す。年内には出来そう。せっかくだしAdvent Calendarも書きたいなー。 pic.twitter.com/nVLMrodEIs— shiraji (@shiraj_i) 2019年12月10日翌朝起きたら中々の反応がもらえてたので、ちょっとやる気が出て、そのまま勢いで作り切りました。余談ですが、自分の場合、こんな機能作った！ってツイートした場合、反応あるとすごくモチベーションが上がるので、欲しいな！って思ったらぜひいいねしてもらえると！これ単体でプラグインとして出しても良いのですが、切り出すメリットがあまり見えなかったため、Find Pull Request プラグインのv1.7.0の機能として出しています。Repositoryはこちらこの機能により、Find pull requestプラグインは3つの機能を持つことになりました。右クリックでpull requestページに飛ぶ右クリックでpull requestページのURLをコピーするpull requestの一覧をエディタに記載するまだまだ他にも欲しい機能があるので、ちょくちょく作っていこうと思います。他にも欲しい機能あればぜひissueにあげてください。ちなみにGitHub, GitHub Enterprise, GitLab, Bitbucketで動作します。他にも欲しいサービスあれば、issueテンプレート埋めていただければ対応します。開発方法せっかく作ったので、調べた知見を置いておきます。ここから想定読者は 「IntelliJプラグインをがっつり開発したことがある・Annotate機能を作りたい人」とします。つまり基本的なプラグイン開発の説明は省略します。参考ソース普段プラグイン開発するなら他の似たようなプラグインのソースコード読め。で終わるのですが、アイコンつけるのはいくつかありましたが、Annotate機能を使ったプラグインは誰も作ったことがないのではないか？と言うくらい見つけることが出来ませんでした。その為、みなさんお馴染みのintellij-communityのrepoから仕様を把握することにしました。github.comその中でも唯一Annotate機能を提供している、 AnnotateToggleAction を見て開発を行ないました。https://github.com/JetBrains/intellij-community/blob/master/platform/vcs-impl/src/com/intellij/openapi/vcs/actions/AnnotateToggleAction.javaFind pull requestプラグインは開発当時2019.1をサポートしているので、masterブランチではなく、2019.1のソースを見て開発していました。後述するけど、これが後に問題になります。Annotateを出すには色々読んだ結果、Annotateを出すには editor.gutter.registerTextAnnotation() を呼び出すことで実装が可能のようです。  /**   * Adds a provider for drawing custom text annotations in the editor gutter, with the   * possibility to execute an action when the annotation is clicked.   *   * @param provider the provider instance.   * @param action the action to execute when the annotation is clicked.   */  void registerTextAnnotation(@NotNull TextAnnotationGutterProvider provider, @NotNull EditorGutterAction action);引数は二つ、一つ目の TextAnnotationGutterProvider はどんなテキストを出すのか？もう一つの EditorGutterAction はそのテキストに対してクリックした時どんなアクションを起こすのか？です。クリックなどのアクションが必要ない場合、二つめの引数は省略可です。TextAnnotationGutterProviderTextAnnotationGutterProviderで一番重要なメソッドはこの getLineText メソッドです。/**   * Returns the text which should be drawn for the line with the specified number in the specified editor.   *   * @param line   the line for which the text is requested.   * @param editor the editor in which the text will be drawn.   * @return the text to draw, or null if no text should be drawn.   */  @Nullable  String getLineText(int line, Editor editor);このメソッドは引数に行番号と表示するEditorが渡されます。戻り値にはその行に表示するStringです。簡単なメソッドなのですが、一つ問題があります。それはこのメソッドが呼び出されるタイミングはAnnotateがレンダーされ得るたびと言うことです。その何が問題なのかを説明する前に、Annotateの機能についておさらいします。AnnotateとはEditorの左横の部分を右クリックし、Annotateを選択したら、その行の最後のコミット（正確には少し違う）を表示します。Annotateここまではよく知られています。問題はエディタでの表示と言うことはAnnotate表示中も開発者がコードの更新をすることが可能です。つまりコード編集してもAnnotateを閉じず、正しい行に正しい情報を表示する必要があるということです。コードの変更・改行・行削除などにも対応する必要があるregisterTextAnnotation するのはアクションがcheckになった時のみです。そのため、registerTextAnnotation された時と getLineText が呼び出された時の表示されているエディタの状態は異なる可能性があることになります。これを踏まえて、 getLineText の実装をします。最初に問題になるのが、 line の意味です。the line for which the text is requested. と記述されていますが、説明が圧倒的に足りていません。というか、説明通りに受け取ってはいけません。この line は Annotate が表示された時の行番号に当たります。今まさにEditorで表示されている行番号ではありません。受け取った line をそのまま利用するのは危険です。 line が今表示されているエディターの行番号としてどこに当たるのかを確認し、その確認した行番号に対して情報を返さないといけません。(ここを読むような訓練されたプラグイン開発者なら「あーよくあるやつね」となるいつものやつです。)「line が今表示されているエディターの行番号のどこに当たるのか」は UpToDateLineNumberProviderImpl を利用して取得します。        val upToDateLineNumberProvider = UpToDateLineNumberProviderImpl(editor?.document, editor?.project)        val currentLine = upToDateLineNumberProvider.getLineNumber(line)UpToDateLineNumberProviderImpl#getLineNumber にはドキュメントはありませんが、0未満の時には現在表示されているエディタにはその行は存在していないことを表しています。そのため今回は、0未満の値だった場合、表示されることはないため、空文字即returnにしてあります。ここが呼び出される回数は思った以上に頻度が高いです。しかも各行呼び出されます。このプラグインではgitのハッシュ値からpull requestの番号を取得しますが、都度その処理を行うことは危険です。そのため、ハッシュ値とPR番号のマッピングを registerTextAnnotation する前に計算しておき、このメソッド内ではそのマッピングから表示する文字列を生成する簡単な処理に留めてあります。EditorGutterActionEditorGutterAction重要なのがdoAnnotateメソッドです。/**   * Processes the click on the specified line.   *   * @param lineNum the number of line in the document the annotation for which was clicked.   */  void doAction(int lineNum);このメソッドのlineNumは現在表示されている行番号になります。 UpToDateLineNumberProviderImpl は利用する必要はありません。Editorは受け取れないことに注意してください。TextAnnotationGutterProvider と同じようなデータやロジックを使います。そのため、今回の機能では、一つのクラスで二つとも実装することにしています。FileAnnotationAnnotateのようにFileAnnotationに依存するような情報を表示する場合、注意しなくてはならないのが、IntelliJのエディタ以外の部分からもファイルの変更が可能になる点です。何を言っているのかわからないと思います。例えばですが、ファイルの変更をして、コンソール上でコミットをするようなケースを考えてください。エディタの変更だけではなく、IntelliJ外部からのFileの変更(FileAnnotationの変更)などを検知し最新の情報を表示する必要があります。ちなみにAnnotateを開いたまま、改行し、コンソールでコミットしてみてください。Annotateが自動で閉じます。今回の機能もFileAnnotationに依存しているため、その変更を検知する必要があります。あまり深く仕様を考えるのは大変であるため、Annotateと同じようにFileAnnotationの変更が発生した場合、Annotateを閉じるようにします。FileAnnotationの変更を検知するメソッドは二つあります。  /**   * Notify that annotations should be closed   */  public synchronized final void close() {    myIsClosed = true;    if (myCloser != null) {      myCloser.run();      myCloser = null;      myReloader = null;    }  }  /**   * Notify that annotation information has changed, and should be updated.   * If `this` is visible, hide it and show new one instead.   * If `this` is not visible, do nothing.   *   * @param newFileAnnotation annotations to be shown or `null` to load annotations again   */  @CalledInAwt  public synchronized final void reload(@Nullable FileAnnotation newFileAnnotation) {    if (myReloader != null) myReloader.consume(newFileAnnotation);  }  /**   * @see #close()   */  public synchronized final void setCloser(@NotNull Runnable closer) {    if (myIsClosed) return;    myCloser = closer;  }  /**   * @see #reload(FileAnnotation)   */  public synchronized final void setReloader(@Nullable Consumer<? super FileAnnotation> reloader) {    if (myIsClosed) return;    myReloader = reloader;  }上記のようにコンソールでコミットする場合、FileAnnotateのcloseが呼び出されるため、setCloserメソッド内でAnnotateを閉じる処理を記述します。        fileAnnotation.setCloser {            UIUtil.invokeLaterIfNeeded {                if (!project.isDisposed) editor.gutter.closeAllAnnotations()            }        }同じようにsetReloaderメソッドを実装しようとしたのですが、思いつく限りの行動をしても、残念ながらreloadメソッドが呼び出されることがありませんでした。そのため、setReloaderの実装することができませんでした。AnnotationToggleActionから引数のFileAnnotationが最新のFileAnnotationのようですが、ここは謎です。。。誰か教えて。2019.1 vs 2019.2さてここまで実装して、よっしゃリリースだ！って思ったのですが、 closeAllAnnotations メソッドが気になっていました。このメソッド呼び出されるとAnnotateの部分に表示されている情報全てを閉じます。つまり、Annotateを表示し、List pull requestを表示し、 close annotationを選択するとAnnotateとList pull requestが両方とも閉じてしまします。片方だけ閉じることが出来ません。2019.1の場合、個々のAnnotateを閉じる方法が提供されておらず、さらに設定されているTextAnnotationの取得が行えません。残念だなーと思っていたのですが、ふとした拍子にこんなissueを見つけてしまいました。Annotate action behave wrong if other annotations addedhttps://youtrack.jetbrains.com/issue/IDEA-209722このissueによると、192.2300から個々のAnnotateを閉じることができるようになったみたいです。つまり2019.1では出来ないけど、2019.2では出来ると。2019.1のソースコードばかり追っていたため、最新のコードでは出来る事を出来ないと諦めてしまっていました。古いバージョンに引っ張られて、しょぼい機能を提供するのはなんだかなーって思ったので、2019.2での開発に切り替えることにしました。ちなみにこのissueにはこんなことが書かれています。We've run into that in the students' project, but it also can be actual for 3rd-party plugins developers.要約すると「学生のプロジェクトやってる時に発覚した。3rdパーティのプラグイン開発者にも発生する可能性あるよ。」とのことです。3rdパーティのプラグイン開発者でAnnotate作って公開まで持っていったの、ひょっとすると相当少ないようです。どうりで似たようなプラグインが見つからない訳ですね・・・2019.2対応2019.2(ここでは192.5728以上とします)では新たに以下の二つのメソッドが提供されました。  @NotNull  List<TextAnnotationGutterProvider> getTextAnnotations();  void closeTextAnnotations(@NotNull Collection<? extends TextAnnotationGutterProvider> annotations);getTextAnnotations はそのEditorに設定されている全てのTextAnnotationsを取得し、 closeTextAnnotations は引数に渡された複数のTextAnnotationを閉じるメソッドです。これを使えばOK！ということでさくっと実装してみました。上記の問題が解消されると思ったのですが、Exceptionが出ます。java.lang.Throwable: Synchronous execution on EDT: /usr/bin/git -c ...    at com.intellij.openapi.diagnostic.Logger.error(Logger.java:145)    at com.intellij.execution.process.OSProcessHandler.checkEdtAndReadAction(OSProcessHandler.java:117)    at com.intellij.execution.process.OSProcessHandler.waitFor(OSProcessHandler.java:62)    at git4idea.commands.GitTextHandler.waitForProcess(GitTextHandler.java:145)    at git4idea.commands.GitHandler.runInCurrentThread(GitHandler.java:383)    at git4idea.commands.GitImplBase.doRun(GitImplBase.java:172)    at git4idea.commands.GitImplBase.run(GitImplBase.java:148)    at git4idea.commands.GitImplBase.runCommand(GitImplBase.java:46)    at git4idea.commands.GitImpl.runCommand(GitImpl.java:41)これは何かというと、UIスレッド時にgitのような外部コマンド叩くとエラーになるということです。IntelliJ 2019.2からこのような仕様に変わったようです。Find Pull Requestプラグインは各所でgitコマンドを叩いているため、これの対応が必要になります。外部コマンドを叩く場合、一番簡単な対処方法はバックグラウンドスレッドでの処理にしてしまうことです。バックグラウンドスレッドでの実行方法はいくつかあるのですが、簡単な方法として、Task.Backgroundableを使ってみます。        object : Task.Backgroundable(project, \"Listing Pull Request...\") {            override fun run(indicator: ProgressIndicator) {                // 外部コマンドを叩くなどの処理+その後続処理            }        }.queue()queue()の呼び出しを忘れがちになるので、注意してください。さぁ対応終わったぞ！って思ったのですが、今度は別のエラーが出ます。java.lang.Throwable: Read access is allowed from event dispatch thread or inside read-action only (see com.intellij.openapi.application.Application.runReadAction())    at com.intellij.openapi.diagnostic.Logger.error(Logger.java:162)    at com.intellij.openapi.application.impl.ApplicationImpl.assertReadAccessAllowed(ApplicationImpl.java:1027)    at com.intellij.openapi.editor.impl.EditorImpl.assertReadAccess(EditorImpl.java:3254)    at com.intellij.openapi.editor.impl.EditorImpl.getSettings(EditorImpl.java:920)今度は何かっていうと、上でやったバックグラウンドスレッドはEditorへのRead権限がないため、あかんよってことです。上のバックグラウンド処理は必須であるため、read権限あるスレッドでEditorへのアクセスをするように修正します。以下の公式ドキュメントにスレッド周りの話が書いてありますので、興味ある人は読んで下さい。www.jetbrains.orgドキュメントによると今回の場合は、invokeLaterを呼び出せば対処可能になります。つまりコードとしてはこんな感じに。        object : Task.Backgroundable(project, \"Listing Pull Request...\") {            override fun run(indicator: ProgressIndicator) {                // 外部コマンドを叩くなどの処理+その後続処理                ApplicationManager.getApplication().invokeLater {                    // バックグラウンドスレッド内でeditorへアクセスするなどread権限が必要な処理を実行                }            }        }.queue()ようやく全てのコードがエラーなしで2019.2で動くようになりました。ほっと一安心。さぁリリースです。完全にやっちまったな。3.5.xで動かないの確認した。3.6.x系では動く。流石にダメな気がしてきた。対応しよう。— shiraji (@shiraj_i) 2019年12月15日はいリリース後にユーザが多い、Android Studioの最新版3.5系(2019.1ベース)のサポートを勢い余って切ったことが発覚しました。最近Android開発してなかったし、完全に忘れてました。。。複数バージョン対応かと言って、2019.1のサポートに戻すと、問題解消されている2019.2のユーザにも問題ある挙動を強制する事になってしまいます。そこで、複数のバージョンのプラグインをリリースすることにしました。1.7.0 -> 2019.2以降のユーザ1.7.0-2019.1 -> 2019.1.xのユーザ(Android Studio含む)対処方法は簡単で、plugin.xmlの idea-version のuntil-buildを設定し <idea-version since-build=\"191\" until-build=\"192.5727\"/>、プラグインのバージョンを新しく 1.7.0-2019.1 として、リリースするだけです。(until-buildなどはplugin.xmlじゃなくて、gradle-intellij-pluginで設定可能になっているはずです。未検証) そうするとこんな感じで、IntelliJのバージョンによって、インストールできるバージョンが変わるようになります。複数バージョンがホストされるまとめ先日のUbieアドベントカレンダーの Lukas (@cvguy84) | Twitter さんのIntelliJプラグインの記事ではqiita.com抽象的で考えるとIntelliJのプラグインの開発は簡単です。どこがやー！って思うのですが、IntelliJのプラグインは誰でも作ることができます。Documentationを慎重に読んで、実装するしかないです。でもそれがOSS開発の一つの楽しみであると思います。本当にこれです。ドキュメント(という名のソースコード)を読んで、うまく動いた時、すっごく楽しいし、それが人に使われると思うとやめられませんなーってなります。ちなみに年内に出したいと思ったので、コピペの嵐でやり過ごしました。そのため、2019/12/21現在のrepositoryのコードは参考にしない方が良いです。。。時間とってがっつりフルスクラッチします。誰にも何も言われず、費用対効果ガン無視で思いっきり俺の考えた最強のコードがかけるのもOSSの醍醐味だと思います。","link":"https://shiraji.hatenablog.com/entry/2019/12/21/013631","isoDate":"2019-12-20T16:36:31.000Z","dateMiliSeconds":1576859791000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Spring+GraphQLからKtor+GraphQLに移行する","contentSnippet":"はじめにこれは Ubie Advent Calendar 2019 - Qiita の7日目の記事です。6日目は かみな/Kaito Minatoya@Ubie (@kamina_zzz) | Twitter による 地球上の Kubernetes ユーザーは絶対使うべきツールたちを紹介するよ - Qiita でした。想定読者Spring + Kotlin + GraphQLを使っていて、Ktorに移行したくなっちゃった人 (需要🤔)本題UbieでAdvent CalendarをKtor縛りで書くぞ！となりました。じゃあ自分は何を書こうかなーって考えてたらGraphQLに決まってるじゃん？と振られたので、UbieではKtor+GraphQLは使ってないのですが、もしSpringのアプリケーションである https://github.com/ubie-inc/kotlin-graphql-sample をKtorに移し替えるとしたら何をするのかを調査しつつ、記事にすることにしました。この記事では一旦動くところまでを目指します。生かすコード、諦めるコードフレームワークを載せ替えるとしてもそこまでガッツリ書き直す訳ではなく、生かすことが出来るコードが多々あります。今回は出来うる限りコードを生かす方向にしました。そのため、graphql-java-toolsを同様に採用します。github.comこれを採用するため、domainとquery resolver, resolver はSpringのアノテーションを消すだけで再利用出来ます。import com.coxautodev.graphql.tools.GraphQLResolver- import org.springframework.stereotype.Component- @Componentclass DiseaseResolver(...) : GraphQLResolver<Disease> {jdbc も同様に修正するのですが、Springのjdbcを使っているため、思った以上にガッツリ修正が入ります。この辺りはKtorで利用するDBアクセスライブラリ次第になります。ここではあまり関係ないので、省略します。スキーマファイルもSpringの時同様にresources直下に置きます。再利用できるコードもありますが、完全に捨てるコードもあります。例えば、JdbcConfigやKotlinGraphQLSampleApplication これらはSpringのための設定なので再利用は出来ません。ただこのようなコードだけなのでほとんどのコードが再利用することが可能となります。新規実装IntelliJのウィザードで作成されるここから、新規の実装をしていきます。fun main(args: Array<String>): Unit = io.ktor.server.netty.EngineMain.main(args)@Suppress(\"unused\") // Referenced in application.conf@kotlin.jvm.JvmOverloadsfun Application.module(testing: Boolean = false) {}最初にRoutingの定義です。 GraphQLなので /graphql にコードを書いていきます。GraphQLは GETとPOSTのサポートをしているので、一応、両方とものAPIを書きます。fun Application.module(testing: Boolean = false) {    routing {        get(\"/graphql\") {            TODO()        }        post(\"/graphql\") {            TODO()        }    }}最初にリクエストをパースします。リクエストはこんなJSONです。{    \"query\":\"{\\n  drug(id:\\\"id\\\") {\\n    name\\n  }\\n}\",    \"variables\":null,    \"operationName\":null}これをこのままdata classにします。data class GraphQLRequest(    val query: String = \"\",    val operationName: String? = \"\",    val variables: Map<String, Any>? = mapOf())Ktorでデフォルトで使える、 ObjectMapper を使ってパース処理を書くと。fun Application.module(testing: Boolean = false) {    routing {        get(\"/graphql\") {            val stringRequest = call.receive<String>()            val mapper = ObjectMapper()            val request = mapper.readValue(stringRequest, GraphQLRequest::class.java)        }        post(\"/graphql\") {            val stringRequest = call.receive<String>()            val mapper = ObjectMapper()            val request = mapper.readValue(stringRequest, GraphQLRequest::class.java)        }    }}何度も同じ処理を二箇所に書くのは辛いので、 GraphQLController を作成します。class GraphQLController {    suspend fun handleGraphQL(call: ApplicationCall) {        val stringRequest = call.receive<String>()        val mapper = ObjectMapper()        val request = mapper.readValue(stringRequest, GraphQLRequest::class.java)        TODO()    }}これを使ってコード量減らします。fun Application.module(testing: Boolean = false) {    // Controller    val graphQLController = GraphQLController()    routing {        get(\"/graphql\") {            graphQLController.handleGraphQL(call)        }        post(\"/graphql\") {            graphQLController.handleGraphQL(call)        }    }}さて次は実際に graphql-java を利用してコードです。    val filePath = \"kotlingraphqlsample.graphqls\"    val graphQLSchema = SchemaParserBuilder()        .file(filePath)        .resolvers(            listOf(diseaseResolver,                 DiseaseQueryResolver(diseaseService),                // 他のResolverもここに記述する                ))        .build()        .makeExecutableSchema()    val graphQL = GraphQL.newGraphQL(graphQLSchema).build()この graphQL インスタンスをController内で使い、それぞれのResolverにアクセスしていきます。graphQL インスタンスはDI使うなり、コンストラクタに差し込むなり、Controller内でインスタンス化するなり、好きなようにControllerに差し込みます。    suspend fun handleGraphQL(call: ApplicationCall) {        val stringRequest = call.receive<String>()        val mapper = ObjectMapper()        val request = mapper.readValue(stringRequest, GraphQLRequest::class.java)        val context = ConcurrentHashMap<String, Any>()        // graphQLは上でインスタンス化したもの        val result = graphQL.execute(            ExecutionInput.newExecutionInput()                .query(request.query)                .operationName(request.operationName)                .variables(request.variables ?: emptyMap())                .context(context)        )        TODO()    }最後にresultをJSONにして、返します。    suspend fun handleGraphQL(call: ApplicationCall) {        val stringRequest = call.receive<String>()        val mapper = ObjectMapper()        val request = mapper.readValue(stringRequest, GraphQLRequest::class.java)        val context = ConcurrentHashMap<String, Any>()        val result = graphQL.execute(            ExecutionInput.newExecutionInput()                .query(request.query)                .operationName(request.operationName)                .variables(request.variables ?: emptyMap())                .context(context)        )        val json = mapper.writeValueAsString(result.toSpecification())        call.respondText { json }    }これでAPIは完成。APIアクセスを簡単にするために、GraphiQLも導入します。 graphiql/packages/examples/graphiql-cdn at master · graphql/graphiql · GitHub この辺りのサンプルコードをそのまま拝借し、index.htmlとしてプロジェクト直下に置きます。fun Application.module(testing: Boolean = false) {    // Controller    val graphQLController = GraphQLController()    routing {        static(\"/graphiql\") {            // GraphiQL            default(\"index.html\")        }        get(\"/graphql\") {            graphQLController.handleGraphQL(call)        }        post(\"/graphql\") {            graphQLController.handleGraphQL(call)        }    }}Runボタン押して、実際にGraphiQL http://localhost:8080/graphiql にアクセスしてみます。見えるようになりました。yay!終わりにいかがでしたでしょうか？(一回やってみたかった)やってみて思ったんですが、Springですでに動いているのであれば、今のところKtorに移す必要ないなーと言うのが感想です。今回はこんなレポジトリのコードを参考にしました。https://github.com/roschlau/ktor-graphqlhttps://github.com/excitement-engineer/ktor-graphqlあまりアクティブな開発がされていないので、今後どうなるのかわからないですが、もうちょっとKtorのGraphQL周りのプラグインが出来たら良いなーと。自分で作れってことか  🙃","link":"https://shiraji.hatenablog.com/entry/2019/12/07/231214","isoDate":"2019-12-07T14:12:14.000Z","dateMiliSeconds":1575727934000,"authorName":"しらじ","authorId":"shiraji"},{"title":"カナダから来たUbieのインターン生(Hiroくん)はすごかった","contentSnippet":"最初にこの記事はどの企業も個人も批判する目的はありません。もし批判を感じる文章があればご指摘して頂けると幸いです。Hiroくんがインターンを予定通り8月中旬まで無事に終わらせたので、彼がこの期間何をやったのか？などを書こうと思います。アイキャッチ画像のための無意味なスクショ出会い最初の彼との出会いは、Twitter上で、自分の経歴とほぼ同じ経歴を持っている学生がいるなー珍しいなーと思ったけど、関わりないだろうなーとスルーしたのを覚えています。その数日後、彼のツイートは炎上していました。朝ごはん食べてたら前見つけた子が炎上してるじゃん！あららーもっと先にフォローして、声かけちゃえば良かったかなー。と朝ごはん食べながら眺めてました。最初、インターン先探しているということに対して、声かけるのはなしだよなーって思ったんですが、子供の朝ごはんを少しこぼしたので片付けをしていて、人ってミスするし、そこでダメって決めつけるのおかしい。優秀な子がこれでチャンス無くすのおかしい。弊社のバリューの一つが「launch x launch」(ロンロン)*1なのにグジグジ考えて行動起こさないのおかしい。と思い、声かけることにしました。声かけると決めた時の分報声かけたあと、東京に来るとのことだったので、その時に会いましょうと言う約束をしました。予定を聞いて、最後の方ってことだったので、まぁ彼のキャリア的にも弊社はまだ魅力的には見えないだろうから優先度下げられたかーとちょっと残念な気分でした。会ってみて5月頭に彼は日本に一時帰国していて、会社に来てもらいました。最初会ったとき、顔と体のギャップがすごい！って思ったのですが、話してみると本当に素晴らしい好青年でした。素直に話は聞けるし、しっかりと意見出来ていたし、キャリアもしっかり考えていたし、事業への質問も的を得たものでした。会う前に炎上してしまった経緯も説明してもらっていたのですが、本当に不可抗力だったのだろうなとそこでようやく納得できました。唯一問題というと彼の今後の専門としたい分野がUXなどであること。当時彼の経験があるAndroidアプリやUnityのポジションは弊社にはありませんでした。あるのはUXなにそれうまいの？CUIで良くね？と言っちゃう自分しかいないチームでのサーバサイドKotlinでした。そこで、「すごくHiroくんは優秀だと感じたし、ぜひ働いて欲しいけど、今弊社に来るとHiroくんのキャリア的に遠回りになるかもしれない。本気でおすすめ出来ない。でも同じ界隈にいるだろうし、引き続き仲良くしてね！」と笑顔で送り出すことにしました。彼が帰った後「すごく良さそうだったけど、今後の彼の専門や今のスキル的にポジションがほぼない。なので今回はなかったことで！」という評価を会社のメンバーに伝えておきました。数日後その数日後、TwitterのDMでこんなメッセージが来ました。「色々週末考えたのですが、Kotinサーバーサイドとして入らせて頂くこと可能でしょうか？」正直、まじか！空気読めない子か！ってフいたのを覚えてます。（そして今気づいたけど、typoしてるw）でも入りたい！と言ってきたのに、なにもせずにごめんなさいってするのはおかしいので、入社試験をしてもらいました。一週間くらいかけて貰えばいいかなーって思ったところ、1,2回のラリーはあったものの、2日で作り切り、コードもしっかり読めていて、想像以上でした。こちら側からお断りする理由もないし、彼のキャリア的に美味しいのか？と罪悪感を感じつつ、入社してもらうことにしました。【報告】インターン先決まりました。今日からUbieでしらじさん(@shiraj_i)の元、Kotlin書きます。Androidじゃなくて、サーバーサイドなので学ぶことしかないですが、頑張ります！— Hiro (@khiro_ca) May 15, 2019 ちなみに入社後に彼が書いた下でも紹介している記事を読んで、すごく真剣に話を聞いてもらえたのがわかったし、めっちゃ嬉しかったのを覚えています。入社前に今のUbieはまだまだ小さな会社であり、事業を危険に晒すこと＝即会社が潰れるということが十分あり得ます。そのため、彼の受け入れ条件としては公開して良い情報・ダメな情報を明確にすることをみんなに約束しました。と言っても、会った時にその話はしっかりすでにしていて、理解していたし、なんなら話す前から理解していたので、全く不安はありませんでした。入社一番の問題は彼が他の弊社メンバーに受け入れられず、ぎこちない関係になってしまうかも？という点でした。短い期間しかいないため、早めに打ち解けてもらいたかったです。そこでwelcomeランチがあったのですが、紹介一言目に「あの炎上した子です！」と全体に情報公開しました。彼はめっちゃ焦ってましたが、Ubieメンバーの器のデカさや彼が誠実に説明してるところを見て、みんな安心して受け入れてくれていました。あの早いタイミングでアイスブレイクしっかり出来たのは良かったなーと思います。彼いろんな会社のイベント参加してたし、入社日からUbieの一員になってくれました。タスクサーバサイドKotlinのポジションではあったのですが、せっかく来てもらう訳だし、色々吸収してもらおうと考えました。彼には複数のサービスの担当をしてもらい結果的にサーバサイド(Kotlin/Python/Rails)フロント(JS/TypeScript)実装設計単独での開発スクラムでのチーム開発デザインといろんなことをしてもらいました。全く経験がなかったのに、土日で勉強してきて、フロントの実装も素晴らしい速度でやっていたのは本当に驚きでした。もちろん彼にもまだまだ未熟な部分はあって、そこは週1の1on1で話していたし、色々彼なりに頑張って改善していました。結果今の彼のレジュメはぐちゃぐちゃになっただろうと思いますが、master resumeには残して、提出するresumeから外せばいいだけだし、好きにしたら良いと思う（責任放棄）留学生のインターン余談ですが、インターンインターンと言ってますが、留学生のインターンって日本で言う、学生の業務委託であり、使えなければクビ切られる覚悟を持っている人が多いです。彼もその考えを持っていました。もし留学生をインターンとして受け入れる会社があるなら、学ばせるというより、キャリアを積ませる＋プロの業務委託的な扱いをしてあげて欲しいです。なので、今回も学ばせると言うより、会社への貢献のためのタスクを選んでやってもらいました。このあたり読んでもらえると良いのではないかなーと思います。hiro-ca.hatenablog.comなぜこの記事を書いたか？インターン生や新卒などなど色んな人を見てきましたが、こんなブログを書くのは初めてで、今後もあんまり書かないだろうと考えています。しかし優秀な子が不本意なデジタルタトゥーにかわいそうな思いはして欲しくないので、彼はそんな人じゃないということをこの記事で明言しておきます。彼はフルタイムで働いているため会社の様々な情報にリーチできる人材でしたが、インターン期間中一度も情報公開に関して指導する必要はありませんでしたし、信用できる人間です。最後にHiroくん、お疲れ様でした。色々自分至らぬところがあったと思います。申し訳ないです。でも一緒に働けてすごく楽しかったし、Hiroくんが将来めっちゃ活躍してるところを早くみたいです。そして「わしが育てた」と言わせて下さい。Good luck!!!*1:弊社の三つのバリューのうちの一つ。100の議論より1の実行に価値がある。","link":"https://shiraji.hatenablog.com/entry/2019/08/26/200000","isoDate":"2019-08-26T11:00:00.000Z","dateMiliSeconds":1566817200000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Kotlin Fest 2019に参加してきました","contentSnippet":"Kotlin Festの感想ブログを読んでいて、やっぱり自分も書きたくなっちゃった。だから書く。(2年連続)去年の記事shiraji.hatenablog.comCfP今年はCfPだったので、2本書きました。GraphQL周り(通過した話)IntelliJ周り(DroidKaigiでなかなか反応良かった話の改良版)セッションの内容に新規性・独自性があることKotlin独自の知見を得られること ― 例えば内容をJavaに置き換えても同じ知見が得られるようなセッションは採用されにくいです。これらの要件が本当に難しくて、Javaに置き換えられない内容ってCoroutineやKotlinでしか使えないライブラリしかないんでは？と悩みまくりました。それに加えて新規性！？とかなり苦しんだCfPでした。通過連絡7/10に通過連絡が来ました。Kotlin Fest採択されたー！急いで準備せねば！社内での実例も出しつつ、KotlinでGraphQLの話しようと思います。渾身のIntelliJのおもしろネタは採択されなかった😭LTにして、「Kotlinを使ってIntelliJと話してみよう！」とかにすれば良かったか？この話どっかで話したいなー。 pic.twitter.com/W4djyN5JHe— shiraji (@shiraj_i) July 10, 2019 全然時間なかった！とここで文句書くつもりだったけど、メール確認して7/10に連絡来ていた事実を知り、1.5ヶ月もあったんなら余裕だったんじゃん・・・と今反省しています。いや、夏休みがあったから実質1ヶ月だしやっぱり時間なかった！スライド準備CfPの時にアウトラインが決まっていたこともあり、サクサク進むかなーって思ってました。IntelliJの話がしたくてしたくて、その影響もあり、あんまりモチベーションが上がらず、進捗は良くなかったです。7月から話す内容を書き出し、2週間前にKeynoteの1枚目を作り出し、1週間前にようやく完成しました。うおー！ようやくKotlin Festのスライド準備完了した！かなり削ってしまった。。。あとは一週間しっかりと練習して、細かいネタを仕込む作業に入る。— shiraji (@shiraj_i) August 18, 2019 かなり遅くて焦ったのですが、今までとは別の方法でスライド作成し、その方法が自分には結構フィットしました。これは自分にとってかなり大きな収穫かなーと考えています。前日去年同様、ぼっち飯回避ツイートをしました。Kotlin Fest 2019でもこれやりたい！どなたか一緒にランチ行きませんかー？サーバサイドKotlinやGraphQLなどなど興味ある方ぜひ！（今年も自腹でお願いします！）https://t.co/zQISiHftUs— shiraji (@shiraj_i) August 22, 2019 kouさん、ikkunさんが反応してくれたので、前日の時点でぼっち飯回避できたの本当に良かった。これあと一人だれか参加しませんかー？ぼっち飯回避！ #kotlinfest https://t.co/1l5SfW7Dp8— shiraji (@shiraj_i) August 24, 2019 当日に追加で呼びかけたらいっせいさんが反応してくれました。これで準備万端になりました！当日会場に入ったのは10:40くらいでした（これがあとで叱られる原因に）。もうすごい盛り上がっていて、会場入って、おおお！とすごくワクワクしたのを覚えています。控え室に荷物を置かせてもらい、キーノートを聴きました。Svetlana Isakovaさんに紹介してもらった、Inline classやimmutableListの話が非常に良く、早速どこに導入するべ？って検討していました。それとSvetlana Isakovaさんのスライドにまさか自分が出てくるとは思ってなかったのですごく嬉しかったです。It's me!!!#kotlinfest pic.twitter.com/PG38WHUe8u— shiraji (@shiraj_i) August 24, 2019 最近正直OSSで貢献できてないので、何かしなきゃ！と思いました。ランチ前日のツイートで集まった三人の方落ち合おうとしていたら、八木さんがランチ相手を探していたので、八木さんを引っ張っていき、去年と同じところでランチしました。バックグランドがみんなバラバラだったのですが、去年同様結構盛り上がりました。話の内容はKotlinの話はもちろん、Androidの話であったり、サーバサイドの話であったり、業務の話であったり、多岐に渡りました。たった1時間しかなかったのが残念ですが、やっぱり初めての人とご飯行くの楽しいし、知ってる人がいても楽しい！という気づきがありました。これは来年もKotlin Festがあるならぜひやりたい！当日(午後)午後のトークは自分の登壇が15:30からあると言うことであんまり聴いてないのですが、以下の二つを聴講しました。Kotlin コルーチンを 理解しよう 2019公募によるLT大会八木さんのトークはコルーチンの知識を最新版にアップデートしようと思いましたが、すんごくうまくスライド作っていて、発表内容も濃く、コードが読みやすく、途中で自分のスライドや発表内容直したくなりました。ちょっと自信を無くして、控え室に行った覚えがあります。LTはどれも良かったです。途中どうしてもトイレにいきたくなってしまい、漏らして人生終わらすならここで行くしかないと、「静的解析ツール detekt で任意の条件で警告させる」の話途中で抜けてしまいました。lintの話は大好きだったのでめっちゃ悔しかったです。急いでトイレ行った後に戻ってきたら会場が爆笑していて、漏らさなくて良かったけど、トイレはトーク前に行こう！と言う小学生並の知見を得ました。動画に映ってる気がするので、まじで申し訳ないです。すいません。LTはめちゃくちゃよくて、どれも5分じゃなくてもっと長い時間で聴きたい！と感じました。登壇スライドspeakerdeck.comGraphQLの話をする時、どこから話せば良いんだろう？と悩み、結局出来上がったのがKotlinの話をせずに1/3基本的なGraphQLの話をすると言う選択でした。最初にGraphQLの経験を確認してみたのですが、思った以上に少なくて、この選択が間違ってなかったー！良かったーと話ながら思っていました。GraphQLのデメリットの話は時間的に削りました。LTでGraphQLのN+1問題が辛いって話が出ていたので、そこで紹介してもらえたし、結果オーライかなーと。今回意識したのがspeakerdeckではあんまり見えないのですが、スライド間のトランジションです。GraphQLはデータの流れ、クエリの流れなどを理解することが重要だなと思っており、Magic Moveを駆使してそれを表現してみました。聴いてくれた方があれがすごく良かったと反応をくれたのが本当に嬉しかったです。余談ですが、Magic Moveを使う場合、閉じ括弧が消える問題があるのですが、これを解消するために、調べていたら結局Jakeさんに到達して、自分はようやく彼の5年前に追いついたのか・・・愕然としていました。(解消方法は下のツイートのスレッドに記述されていますが、透過率100%の文字を括弧の後ろに入れました。)Keynote's Magic Move hates closing curly braces (\"}\") which screws up all my beautiful code transitions. pic.twitter.com/mcxfv2mCi1— Jake Wharton (@JakeWharton) November 1, 2014オープニングでたろうさんが盛り上げましょうみたいな話をしてくれたので、話を聴いてくれた人たちが結構トーク中に反応してくれて嬉しかったです。スライド作った当時本当にコードしかなくて、これ絶対寝るわ。って思ったので、どうにかして、興味を失わず、理解してもらう方法を実施していたので、話ていて気持ち良かったです。聴いてくれた人たち本当にありがとうございました！登壇後Ask The Speakersで30分の休憩全部使って質問対応しました。みんなかなり面白い質問をしてくれて自分まだまだGraphQLのこと知らないなーって思いました。最初APIの開発辛いよねーって大げさな話を出したのですが、まさにあれば起こってるんです！ぜひ導入してみたい！と言う話を何人かにしてもらえたのがやっぱりこう言うのあるんだ。とびっくりしつつ、めっちゃ嬉しかったです。ブースブースですが、朝ブースにいる知っている人たちを見つけて、挨拶をして、あとで来ます！と宣言して、Ask The Speakers後に向かいました。しかし、自分のAsk The Speakersが終わる時間がブースの撤収開始時間らしく、ほぼほぼ回れませんでした。。。家族がブースでもらえるノベルティが大好きで、Twitterを眺めていて、あれ良さそう！と自分の帰りをワクワクして待っていたようなのですが、ステッカーだけもらって帰って来た自分に対し、なぜもっと早く会場に行かなかったのか？とガチ目な説教をしてきました。次回以降しっかり早めに行きます。。。各社のノベルティ、すごく工夫されていて -> 持って帰る -> 家族が喜ぶ -> その会社のプロダクトを使う と言う良い流れが私の家では出来ています。懇親会懇親会ですが、結構いろんな方と話せてすごく楽しかったです。Svetlana Isakovaさんに登壇直前の時間にあとで話しかけるね！と宣言しており、immutableListの話を聴けて満足しました。懇親会で朝からずっと気になってたimmutableListがなぜ必要なのかって話が聞けた。すごく腹落ちして満足出来た。初めましての方や去年のKotlin Festぶりの方だったり毎度おなじみの人、色んな人と話せて本当に楽しかったです。久しぶりにkontribute欲上がってきたー！#kotlinfest— shiraji (@shiraj_i) August 24, 2019 また初めての方が結構な数話しかけてくれたのが本当に嬉しかったです。自分が知ってる人に対しては話しかけることができるのですが、初めての方は紹介してもらうなりしないと遭遇出来ないです。でも食事を盛っている時とか、「今話しかけても良いですか？」とか言ってもらえて本当に嬉しかったです。ご飯食いたいけど、それ以上に話したいってのがあるので、どんどん話しかけてもらえるとありがたいなーと。お子さんを連れて参加していたポールさんとそのお子さんとお話も出来たのも良かったです。自分もいつか子供連れて勉強会とか参加したいなーと。まとめ来年もあったら絶対参加したい！絶対また登壇したい！おー！！！ハッシュタグとsince:2019-08-24_15:30:00_JST until:2019-08-24_16:20:00_JSTで検索して、ニヤニヤしながら、お酒飲んでる。 pic.twitter.com/NseyjP5l4y— shiraji (@shiraj_i) August 24, 2019 一人で馴染みの店で打ち上げ。めっちゃ美味かったー。","link":"https://shiraji.hatenablog.com/entry/2019/08/25/175129","isoDate":"2019-08-25T08:51:29.000Z","dateMiliSeconds":1566723089000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Yet another emoji support をリリースしました。","contentSnippet":"Yet another emoji supportという絵文字の入力をサポートするIntelliJプラグインをリリースしました。イメージとしてはこんな感じCommitダイアログでも利用できます。github.com経緯元々Emoji supportプラグインを公開していました。しかし、いくつかのissueで絵文字をコミットダイアログ以外のところでも挿入したいと言う要望を受けることが多くなりました。cmd+ctrl+spaceで入力できると何度も伝えていたのですが、なぜかみんなあんまり納得してくれませんでした。リリースから3年経過し、公式のサポートもまだないため、需要があるかさっぱりわからないですが、一旦作ってみるかということで作りました。特徴特徴としてはどの言語でもコメントでの入力をサポートしています。また自分の気づいたベースの言語に関してはStringの中での入力ができるようになっています。(GroovyとScalaが初期リリースでサポートされていないのは完全に失念していたためです。次のバージョンで対応予定です)細かい点としてはKotlinのようにString内でコードを書ける場合、コードを書くことが可能な箇所ではCompletionが出ないようになっています。val foo1 = \"${:<caret>}\" // この場合は出ないval foo2 = \":<caret>${}\" // この場合は出る","link":"https://shiraji.hatenablog.com/entry/2019/06/07/012101","isoDate":"2019-06-06T16:21:01.000Z","dateMiliSeconds":1559838061000,"authorName":"しらじ","authorId":"shiraji"},{"title":"graphql-spring-boot-starterのExceptionハンドリングがめっちゃ便利になってた","contentSnippet":"Kotlinサーバサイド開発者のみなさん、graphql-javaでの開発の調子はどうでしょうか？去年末にリリースされたバージョンのgraphql-spring-boot-starterのExceptionハンドリングがめっちゃ便利で感動したので、ブログに残しておきます。想定読者graphql-spring-boot-starter使って、GraphQLやってる人/これからやる人はじめにgraphql-spring-boot-starterのバージョンが5.0.4の時、Resolver内で発生したExceptionは特に何も指定しない場合、全て Internal Server Error(s) while executing query と言うmessageを返していました。例えば、AuthException のような自前で作成したExceptionが出た場合、レスポンスとしては違ったものを返したくなりますが、問答無用でInternal Server Error扱いです。(ちなみに最新版でも互換性を残すため、同じ挙動です)    @Suppress(\"unused\")    fun diseases(icd: String): List<Disease> {        if (icd.isEmpty()) throw IllegalArgumentException(\"icd must not be empty\")        return service.getDiseases(icd)    }何だろうとInternal Server Error!そこで、カスタマイズしたエラーを返すようにしたいのですが、探せど探せど良い方法が見つかりません。issueにこのドキュメント通りに書けばいけるぜ！と書かれているので、URLをクリックするとこんなページに飛ばされ、かなりイライラします。*1でまぁ、色々調べていくと、Authエラーなどで全処理中断させたいであれば、 GraphQLException を実装すれば、一般的なランタイム時のExceptionとなり、エラーを返してくれると書いてあるので、試してみます。    @Suppress(\"unused\")    fun diseases(icd: String): List<Disease> {        if (icd.isEmpty()) throw GraphQLException(\"icd must not be empty\")        return service.getDiseases(icd)    }結果返してくれなかったよ・・・涙このあたりで心折れます。Spring BootでのExceptionハンドリング話変わって、Spring Bootには結構便利なExceptionハンドラがあります。以下のような感じで、各種Controller内で発生したExceptionに対して、一箇所でうまくシュッとやってくれます 😤@RestControllerAdvice(basePackageClasses = [ExceptionHandlerAdvice::class])class MyExceptionHandlerAdvice {    @ExceptionHandler(TimeoutException::class)    @ResponseStatus(HttpStatus.REQUEST_TIMEOUT)    fun handle(exception: TimeoutException): ExceptionResource {        log.error(\"caught an exception\", exception)        return ExceptionResource(\"タイムアウト\")    }    @ExceptionHandler(WebExchangeBindException::class)    @ResponseStatus(HttpStatus.BAD_REQUEST)    fun handle(exception: TimeoutException): ExceptionResource {        log.error(\"caught an exception\", exception)        return ExceptionResource(\"なんか起こった\")    }}まぁあんまり詳しく書いても話が逸れるので、こんな感じのものがあるのだなー程度で良いです。で、graphql-javaでもこんな感じで処理したい！と思う訳です。時間が解決してくれた(=中の人達が頑張ってくれた)それから数ヶ月が経ち、graphql-spring-boot-starterがメキメキ更新されていました。現在の最新のバージョン(5.7.3)を使い、graphql.servlet.exception-handlers-enabledをtrueにすると以下のコードでもうまくハンドリングしてくれるようになります。*2    @Suppress(\"unused\")    fun diseases(icd: String): List<Disease> {        if (icd.isEmpty()) throw IllegalArgumentException(\"icd must not be empty\")        return service.getDiseases(icd)    }IllegalArgumentExceptionですらうまくメッセージを返すようにものすごく良くなりました。しかし一点typeがException名になってしまいます。フロント側で IllegalArgumentException を処理してもらうで良いのですが、ちょっとダサい。GraphQLExceptionをthrowしたとしても、同じようにtypeが表示されてしまいます。Spring BootのExceptionハンドリングのように特定のExceptionに対して、カスタマイズしたGraphQLErrorを表示したくなります。そこで登場したのが、exception-handlers-enabledが導入されたタイミングでgraphql-spring-boot-starterが @ExceptionHandler によるExceptionのカスタマイズ機能です。実装方法としてはこんな感じのBeanやComponentをクラスを作るだけ！@Componentclass GraphQLExceptionHandler {    @ExceptionHandler(IllegalArgumentException::class)    fun handleSomeException(e: Throwable): GraphQLError {        return GenericGraphQLError(\"Foo! ${e.message}\")    }}それで同じようにExceptionを発生させるとメッセージやtypeを表示しないなどのカスタマイズが出来た！これにより、エラーメッセージのカスタマイズやtypeなどを表示しないなどなどエラーハンドリングが容易に出来るようになりました。実際のコード実際にUbieで公開している https://github.com/ubie-inc/kotlin-graphql-sample に、動くコードをコミットしてあります。上記には記述してありませんが、graphql-java-toolsのバージョン上げも必要になりますので、ご注意してください。github.com*1:https://graphql-java.readthedocs.io/en/latest/ が https://www.graphql-java.com/documentation にリダイレクト機能なし+ドキュメント削除して移動したことが原因です*2:5.3で導入され、5.4.1でバグfixされています。","link":"https://shiraji.hatenablog.com/entry/2019/04/24/080000","isoDate":"2019-04-23T23:00:00.000Z","dateMiliSeconds":1556060400000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Androidエンジニアからベンチャー企業でサーバーサイドエンジニアに転向して半年経って分かったこと","contentSnippet":"8/20入社だったので2/20でUbieに入社して半年になりました。つまりサーバサイドエンジニアに転向して半年経ちました。以前の記事でこんなこと書いたので、続編を書いてみようと思います。半年くらい働けば、きっと悪いところももっと見えてくるはずなので、来年落ち着いたらまた続編を書いていきたいと思います。Ubie, incに入社しました。 - shiraji’s diary今月のツイートを冷静に眺めてみるとそこまで自社に関してのツイートしていないし、恋は盲目状態から解放されているようなので、冷静に自分のことを分析してみようと思います。サーバーサイドにキャリアチェンジしてどうだったか？新しいチャレンジAndroidアプリ開発と比較しての設計開発環境サーバサイドエンジニアとしての課題Androidアプリエンジニアとしての不安ベンチャー企業に入ってどうだったか？ルール働き方タスク時間の使い方初めての経験OKR/KPTアウトプットする人が多い名前引っ越し最後にサーバーサイドにキャリアチェンジしてどうだったか？サーバサイドにキャリアチェンジしたのが正解だったかどうかに関してはまだわかっていません。これに関しては結論が当分出ないような気がしています。ただ、以前のエントリーにも書いてありますが、元々AndroidアプリもUIのことより通信だったり、パフォーマンスだったりを主に見ていたため、AOSPの辛さがなくのびのびKotlinを書けるという環境は本当に楽しいです。今後、多くのネイティブアプリエンジニア達がサーバサイドに目を向けるようになってきた時にサーバサイドKotlinというのは一つの可能性でもあるし、ガンガン発信していって、サーバサイドKotlinのプレゼンス高めていきたいという想いがあります。新しいチャレンジ新しいチャレンジとしてはGraphQLに手を出し始めたのは自分にとって大きな出来事でした。shiraji.hatenablog.comshiraji.hatenablog.comGraphQLといえばGo、Rubyなどといった言語を使うのが主流な気がしますが、JVM言語でも可能性あるのでは？というところまで自分の中で良い印象を持っています。さらにここにKotlinならではの良さを追加出来ないか？と模索しているところです。Androidアプリ開発と比較しての設計設計に関しては、Androidアプリのように活発な動きはなく、特にAPIの作成の時などはシンプルな構成になります。ただし、Androidアプリでの経験が活きないか？と言われるとそれは間違っていて、Androidアプリで利用したDIやクリーンアーキテクチャなどは元々サーバサイドにあったものですし、そのまま利用することが出来ています。開発環境今まではAndroid Studioを使っていましたが、IntelliJ IDEAに乗り換えています。Android StudioとIntelliJを両方使ったことある人であれば、わかると思いますが、特に使い勝手は変わらず、多くのサーバサイドKotlinサポート機能が乗っていて、そこの乗り換えコストはほぼ0です。(自分はIntelliJ IDEAでプラグインを開発していたという経験もあるので、生存バイアスかかってるかもしれませんが。。。)さらにCoroutineやテストツール（JUnit5やmockkなど）など馴染みがあるツールをそのまま利用できる事もあり、サーバサイド辛いなーと感じることが少ないです。サーバサイドエンジニアとしての課題自分が今課題と感じているのが、自分自身、結構ネイティブアプリの開発に注力しすぎてしまったため、ネイティブアプリのライブラリなどの知識は深くなっていますが、昨今のウェブの開発スタイルにまだ馴染めていません。UbieではGCPを主に使っていますが、GCPにどんな機能があるのかを完全に把握しておらず、実装しようとして、あれ？その機能GCPにあるのでは？というツッコミを受けたことがあります。その機能がどういうものなのか？などの把握はそこまで時間がかからないのですが、自分の引き出しの少なさにちょっとがっかりしています。サーバサイドの進化はネイティブ開発に比べ遅い！と勝手に思って7,8年前までのサーバサイド開発のスタンスでいたのですが、これは完全に間違いでした。Androidアプリエンジニアとしての不安Androidアプリ開発の一線から退いて半年経ち、一番の不安は、最新のライブラリのキャッチアップが出来ないことです。例えば、JetPackの存在は知っていますし、コードはある程度眺めています。しかし、仕事でJetPackを使っていないですし、経験がありません。今年のGoogle IOでまた新しいものが発表された時、それに対して何かしら自分がアクションを起こせるかどうかは正直不明です。そのため、もしAndroidアプリエンジニアとしてカムバックしなくてはならない時、何かしらキャッチアップ期間がないと厳しそうだなーという感じています。実際、今サーバサイドエンジニアにカムバックしたといえばカムバックした訳で、このキャッチアップに時間を使っているというのも不安です。半年経った今でもまだサーバサイドエンジニアですと胸張って言えないような感じなので、キャッチアップって結構時間かかるなーという印象を持っています。ベンチャー企業に入ってどうだったか？今までいくつかの企業で働いていて、上場してない企業としてはUbieは2社目です。それ以外の会社は全て上場していて、多くのユーザーを抱えている企業でした。1社目は10人くらいで、今回は現在20人くらいなのでほぼ変わらない規模です。こういう会社に入ると感じるのは自分の稼働が会社へダイレクトに良くも悪くも影響を与える事です。変なバグを出してしまったりすれば会社は潰れるかもしれませんし、逆に素晴らしい機能を出せば一気に会社が大きくなる可能性があります。自分が会社を動かしているかも？という錯覚すら覚えて喜べます。1社目で感じていたのですが、こういう感覚が好きなエンジニアには小さい会社ありだなーと改めて思いました。アイキャッチ画像がなかったから、無駄に、自分のデスクのマスコットのアー写置いておく。ルール新しい会社にはよくあることですが、ルールが決まっていないかったり、そもそもなかったりします。必要であれば社員みんなで議論して、即ルールを制定しています。Ubieはなんかイベントが発生するとみんなで本気で解決しようとしてる姿勢が本当に良い。しきちさん忙しいはずなのに、これから子供持ちたいって人のために、人柱になって色々やってくれてるの最高。 https://t.co/Gf0PEeQgcb— shiraji (@shiraj_i) 2019年1月31日こういうことは小さな会社だから出来る自由さ、フットワークの軽さがあって、すごくいいなーと感じています。働き方働き方は今までよりワークライフバランスを特に意識するようになりました。これはリモートワークがいつでも自由に出来る状況*1であることが起因しているのですが、やろうと思えば、深夜でも早朝でも土日でもプライベートの時間を削って仕事が出来る状況になっています。自分のプライベートのGitHubアカウントを会社でも使っているので、GitHubの通知を見ようとすると会社の通知とOSSの通知を同時に受け取ってしまえます。さらに言うと、自分の会社の出社時間が10:00-17:30でだいたい多くの人より早く帰っており、家で足りない稼働分(30分)働いています。そのためそのまま流れで気づいたら仕事してたみたいな状況に陥りがちです。会社の今のフェーズはできるだけ多くのリソースを割いて、サービスをどんどん良くしていくというのはわかっています。しかし今まだ設立1年半のこのタイミングでエンジニアがいっぱい残業してしまうと今後入ってくる人もそういうのを会社は期待してしまうし、それは健全ではないと思っているので、自分1人だけでもワークライフバランスを特に意識しています。タスク任されているタスクは結構自分から手を挙げたものが多いです。サーバサイドKotlinの実装DBテーブルの設計・実装協力会社との連携処理の設計・実装SREの細かいタスクのサポートbot作成(これはほぼ遊びか？)今フロントエンジニアの質がものすごく充実しているように見えます。結構勉強出来そうな環境です。しかし、今の自分がフロントで足引っ張るより、サーバサイドや人が足りていないSREで足引っ張った方が会社のためになるでしょという判断をしたため、SREエンジニアの修行させてもらっています。手取り足取り @sakajunquality から知見吸えているのですごく良い判断したなーって思っています。時間の使い方これまでの会社と一番違う部分は実は時間の使い方なんじゃないかと思っています。今までの会社ではリーダーだったり、外部の方とのやりとりだったり、雑多な管理だったり、採用だったりと、そこまでまとまったの時間を開発に割いていませんでした。(これだけ読むとダメじゃんー！って思われるかもしれませんが、自分はこれはこれで実は結構好きだし、楽しかったです。)今の会社では毎週以下のような時間割でやっています。会議(3時間15分 *2 )その他、定期的ではない会議や採用周り、週平均2時間くらい残り週30時間以上は開発この定期的な会議の多くは出社推奨日の水曜にまとめています。そのため、結構まとまった時間開発することが出来ています。ただ、これでも自分の会社の滞在時間の制限があるため、週1以上は必ずリモートで仕事をし、より長く開発に時間を割けるように工夫しています。初めての経験Ubieに入って初めての経験がいくつかありました。OKR/KPTスクラムなどは経験あったのですが、今まで業務でOKRやKPTを実際にやったことがありませんでした。OKRは今期から本格的に実施することになり、会社から本を買ってもらい、みんなで勉強して実施するようになりました。KPTは良かったことを褒め合う機会と問題の共有・対処の検討などをしっかりやれるのが気に入ってます。アウトプットする人が多い今まで自分より登壇する回数が多い同僚と働いたことがなかったです。Ubieでは社外へのアウトプットを推奨しており、エンジニアはもちろんのこと、デザイナーや医師、Bizもアウトプットする機会があればどんどんアウトプットしています。これがすごく刺激的で、自分ももっとアウトプットしたい！という気持ちが湧いてきます。Ubieのエンジニア陣の登壇予定表が出来たのだけど、 @ngsw_taro @sakajunquality のアクティブさが半端ない。こう言う人たちに囲まれてるともうちょい自分も頑張らなきゃってなる。 pic.twitter.com/Cw1d62yUos— shiraji (@shiraj_i) 2018年10月5日名前これは入社時からだけど、会社で初めて「しらじ」って呼ばれてる。呼ばれすぎてて、社外の方と話すときに、自分のことを本名で呼ばれたりするとドキっとするようになってしまった。。。引っ越し先日Ubieは引っ越しをしました。新しい場所は三越前駅徒歩10秒です。goo.gl今までも席替えやビルの部屋が変わるなどは毎年1,2回のペースで経験してましたが、オフィスの場所が変わる引っ越しは初めての経験でした。新しい環境で働くのはいつもワクワクなので、引っ越してもそこまで変わらないだろうなーって思ったのですが、引っ越して駅から近くなって、オフィスも広くなって、会社の成長をモロに実感出来たのがすごく嬉しかったです。ベンチャー企業の醍醐味だなーこれ。と感じています。このオフィスも2年以内に引っ越す予定なので、次はもっと大きな場所で働けるようにがんばろー！って気分になれました。最後にAndroidエンジニアからのキャリアチェンジですが、SREにも手を出してますし、今のところうまく進んでいる気がします。会社の成長を感じられるのが本当に嬉しい日々です。さて、こんなUbieですが、引き続き、いろんな職種を募集しています。speakerdeck.com随時オフィス見学やUbie Dayなど社外の方を呼んで来てもらうようなイベントもやっていますので、興味あれば、TwitterでメンションやDM下さい。*1:最大週2で、出社推奨日もあります*2:1時間チーム内KPT, 30分全体KPT, 30分採用定例, 1時間エンジニア定例, 15分業務委託の方と1on1","link":"https://shiraji.hatenablog.com/entry/2019/02/25/080000","isoDate":"2019-02-24T23:00:00.000Z","dateMiliSeconds":1551049200000,"authorName":"しらじ","authorId":"shiraji"},{"title":"DroidKaigi2019に参加しました","contentSnippet":"DroidKaigi2019に参加することが出来たので、感想を書いておきます。聴講したセッション1日目ウェルカムトークマルチモジュールなプロジェクトでテストはどう変わる？マルチモジュールプロジェクトでのDagger2を用いたDependency InjectionServer-side Kotlin for Frontend: 複雑なAndroidアプリ開発に対するアプローチPWAでここまで出来るExploring the Android Transform APIFireside chat && 懇親会2日目build.gradle.ktsに移行しよう夕飯ウェルカムトーク動画カッコ良かった。あとで納品されたのが当日9:30頃でめっちゃヒヤヒヤしたという話をtnjさんがしてて、ウケた。それと、mhidakaさんのマイクがなんか変な音がしてて、聴きづらく、少し我慢してたのですが、誰も反応してないし、意を決してツイートしたら即対応してもらえた。（実際は自分のツイート起因なのかは不明だけど、嬉しかったので、そういうことにしておこうw）即対応された。スタッフさん、さすがです。スゴい。— shiraji (@shiraj_i) 2019年2月7日マルチモジュールなプロジェクトでテストはどう変わる？登壇者のテストが好きだというのがにじみ出ているようなトークでした。本当にテスト好きなんだなこの人！ってワクワクして聴かせてもらいました。内容としては、DeNAさんのものなのかわからなかったですが、テストの方針やモジュールをどのようにテストするのか？とPITの紹介という感じでした。わかりやすく噛み砕いてくれて、かなり参考になりました。スライドがシンプルで良かったです。前半部分の方針の説明だったのですが、もう少し具体例が欲しかったかなと思いました。方針の説明だから仕方ないのですが、それでもコードなどを示しつつ、方針と噛み合わせてくれたらさらに深く理解出来たと思います。PITの説明に入ったら、具体的になって、その内容の面白さに会場がすごく盛り上がっていた印象を受けました。あれは本当に良かった。マルチモジュールプロジェクトでのDagger2を用いたDependency Injection去年に引き続き、kgmyshin さんのマルチモジュールのお話。去年マルチモジュールの初歩的な話をしてもらい、今回具体的な実行編って感じの二部構成！って感じで勝手に感動してました。スライドがすごく特徴的で、うまく手書きと図を使われており、流石だー！と感じました。わかりやすいー！#DroidKaigi #hallA pic.twitter.com/T0eVLjte7M— shiraji (@shiraj_i) 2019年2月7日また、概要説明->実コード->概要説明->実コードと本当に素晴らしい流れで、めちゃめちゃわかりやすかったです。いやーやっぱkgmyさんすごいなーと終わった時に改めて思いました。Server-side Kotlin for Frontend: 複雑なAndroidアプリ開発に対するアプローチマイクロサービスを自社で導入しており、今後拡大した時にどうなるのか？BFFはどういう助けになるのか？が知りたくて聴講しました。FiNCさんの過去の話からBFF採用するまでなどのお話でした。辛い辛い辛いーそうだよねそうだよね！という感じで結構感情移入しちゃって聴けました。これは完全に自分の責任なのですが、遅れて入ってきたため、後ろの席で聴いたこと＋登壇直前にツイートしてもらったスライド公開が残念ながら出来ていなかったこと＋スライドの文字が多かったことと不運が重なってしまい、スライドをめくった時にスライドを読むことに注力せざるを得ず、話を聞き逃すことが若干ありました。。。なので、登壇後に直接いくつか質問させてもらいました。丁寧に回答頂き、なるほどーって結構な回数言わせてもらいました。(今スライド見返すと回答が書いてあったので完全にアホな質問ばかりだったかもしれません。。。)FiNC TechnologyやくしてFin Tech— shiraji (@shiraj_i) 2019年2月7日FiNCさんはFin Techってネタは爆笑しました。（FiNCさんはヘルス事業の会社です。）PWAでここまで出来る自社が、PWAにベットしているので、あんまり説明も読まずにタイトルだけで聴講決めました。今年のDroidKaigiで一番バズったのでは？と思う誤発注のDiverseさん所属の方の登壇でした。DiverseさんがAndroidのFlutterエンジニア募集してると聴いておー！Flutterここまできたかーと驚きました。PWAの基本的な紹介があり、その後TikTokさんに似たPWAサイトを作ると言う話でした。PWAのGoogle Playでの公開方法の説明は実は初めて知って、おおおお！！！って驚きがありました。作ってるものは本当に良かったし、話の内容もすんなり入ってきたし、面白いなーって聴けたのですが、一つだけ悲しいこと言っちゃうとコードの文字が小さくて全然読めなかった・・・。一つ前の時間で質問していて、席が後ろになったのが敗因でした。。。ちなみに次の日に自分が同じ部屋で登壇するということもあり、参考にさせてもらいました。ポインターも大きいやつか、わかりやすくなるやつに変えなきゃやばそう。— shiraji (@shiraj_i) 2019年2月7日実はこの登壇者の SAMUKEI さんとは2日目にホールで自分の登壇の質問待ちでボケーっと座っていたら、見つけてもらい、話しかけてもらえました。最初赤髪の人と目が合ったー！こっち近づいてくるー！やばいー！！！とちょっとドキドキしたのですが、話してみるとすごく気さくな方で話やすく、楽しかったです。話終わった後に、あれ？そういえばあの人PWAの登壇者だったじゃん。って思い出して、あーPWAの話もっとすれば良かったと後悔しました。またどこかでお話しさせてください。DroidKaigi2019ではDiverseさん面白い人多いと言う印象になりました。きっと来年はmini usb -> type cの誤発注してくれるでしょう！では次はmicro usb -> type cの発注お願いします！— shiraji (@shiraj_i) 2019年2月7日Exploring the Android Transform APIこれに関して言うと、自分にとって今年のDroidKaigiで一番楽しかったです。あまりに楽しすぎて、感想なんて要らない、みんなとにかくこのトークの動画を観るんだ！です。簡単に説明するとAndroidでは使えないJava9のメソッド List.of をTransform APIで作り、Androidで動かしてしまおうと言うハッキーなお話です。まじで動くところまでライブコーディングしてます。動画が待ち遠しい。正確にはJavassist DSLなのでJavaコードとは少し違いますが、バイトコードよりは遥かに簡単なので、バイトコードウィービングが捗りますね！ #DroidKaigi https://t.co/cflbn9VMot— FUJI Goro (@__gfx__) 2019年2月7日Understanding Kotlin Coroutines: コルーチンで進化するアプリケーション開発次に mhidaka さんの 「Understanding Kotlin Coroutines: コルーチンで進化するアプリケーション開発」を聴こうとしたのですが、早めに行ったと思ったのに、立ち見になっており、立ち見できる体力なかったので、泣く泣く諦めました。mhidakaさん人気すぎるんだよ。。。Fireside chat && 懇親会Fireside chatを聞こう早めに乗り込んだのですが、ちょっと遠く、声が聞こえませんでした。なので、会場入ってすぐに無理して聴くのを諦め、近くにいた方達と話していました。あの会場でのFireside chatは厳しいと思います。懇親会はある程度知ってる方と話した後、新規の方との交流開拓のため、結構ぷらぷら歩いていました。ただ、歩いてる時に話しかけられることはやっぱりない。↓テーブルに止まると話しかけてもらえる。↓でもテーブルに止まるには何か止まる理由が必要。↓テーブルに皿なら置ける↓食事・デザート・飲み物を持ちまくる。ということでかなり食べてしまったような気がします。。。自分から話しかけるの無理なので、どうにか出来ないものか・・・。初めての人ともいっぱい話したいんだ。おかしな性格だ。この懇親会でPixivの方にAndroidの勉強になるお話をしてくれたら、扇子くれるというイベント？やってました。こういうの話しかけるきっかけになるので良いですね！inside.pixiv.blog食事で並んでいたら見かけたので、「Find Pull Requestプラグインを作りました。」と言ったら、ポカーンとされて、完全に滑ってしまったわ。辛い。ってなったのだけど、別のPixivの方が「お世話になってます。」って言ってくれて扇子出してもらいました。めっちゃ嬉しかったです。ステッカー以外のノベルティ特に反応しない息子くんもこれは気に入ったようで、返してくれません自分の登壇のMVPPixivの方に伺ったのですが、この扇子、Droidくんが入っているのですが、Googleさんに権利関係で連絡したとのことで、Pixivさんやっぱりサービス特性上、著作権周りもしっかりされているんだなーと感心しました。build.gradle.ktsに移行しよう二日目は登壇があり、自分のセッションより前のセッションは何も聴かず、自分の登壇後はすんごい倦怠感に襲われ、セッション聴くのを諦め控え室で引きこもってました。体力が回復しつつあったので、去年に続き、tnj さんのgradleの話を聴きました。build.gradle.ktsへの移行方法をプロジェクト作り、一つずつ手順を教えてくれました。また、スライドには置換で活躍する正規表現も逐次記述しており、これがあれば簡単にbuild.gradle.ktsに移行できそうと言う印象を受けました。こう言うビルドの話大好物なので、本当に楽しかったです。始まる前と終わった後、繋いで！という指示をうけた、tnjさん。 pic.twitter.com/VAw1KdsrhH— shiraji (@shiraj_i) 2019年2月8日2日目、控え室でtnjさんを見つけて、Android Studio 3.3.1当日リリースの被害を受けたということで記念に写真撮ってもらいました。Android Studio 3.3.1昨日出ちゃって影響受けてる組です。#DroidKaigi pic.twitter.com/5SbzipnwRW— shiraji (@shiraj_i) 2019年2月8日特に登壇の影響なくて良かった、いや良くなかった。バグが直ってないとtnjさんが混乱してる姿が面白すぎました。夕飯控え室でのんびりしてたら、gfxさんがご飯どうですか？って誘ってくれました。それなら！とこの会に興味ありそうな方にも声かけて、最終的に6人でご飯食べに行かせてもらいました。結構色々な話が出来て、本当に楽しかったです。あの中で圧倒的に自分のスキルが一番低かっただろうなーって思い知ったので、もっと技術磨かなきゃって感じでした。さて、ここからは話変わって、自分の登壇の話になります。登壇今回は2日目の14:00~でした。登壇の話を書く前にCfSの話から書こうと思います。CfSDroidKaigiのCfSがオープンになったということで、募集要項を確認しました。droidkaigi.jpなんか色々カテゴリがありますが、一番重要であろう点はここかな？と理解しました。応募に当たって以下の3点を満たしていると採択されやすくなります。Android specific: Android 固有であることExpertise: よく知られている情報ではなく、専門性があることInnovation: いままでに可能でなかったことを可能にしていること、革新性があることこの三つを満たしている物をCfSに書けば通るだろうと。JetPackを本番で使ったことがなく、最新のAndroid開発周りでExpertiseとInnovationを満たすのは難しそう。Kotlinはもう当たり前なのでチャンスあるとしたら、Coroutineだろうけど、自分より専門性高い人が多い分野だし、競合も多そう。そうなるとAndroid Studioのプラグイン開発かなー？と思ったけど、これは以前NGだったし、どこのカンファレンスでも需要がないのか今まで一度も通ったことがない。今回やっぱり無理かなーと諦めていたら、同僚がJetBrainsのIDE使っていて、あれ？この設定使ってないの？ということが偶然あって、お？そういえば普段使われていないようなAndroid Studioの設定発掘したら面白いかも？とひらめきました。そこからちょっとPreferencesを上から全部見ていって、設定を変えることにより、どうなるのか？を調べていきました。そしたら、知っているもの含め、10個くらい面白そうな設定が出てきたので、一人で語りながら設定変えて実演してみたら、30分くらいに収まったので、うし、これでいくか！とCfS書きました。CfSの書き方は特に奇抜なことはせずに全部書き出しました。2014年末からAndroid Studio v1.0.0が出てから、ほとんどの方がAndroid Studioを使ってAndroidアプリの開発をしていると思います。IntellijをベースにしたAndroid Studioでは非常に多くの機能が存在しています。しかしあまりにも多いため、埋もれてしまっている便利な機能があるのではないのでしょうか？このセッションでは、Android Studioの隠れた便利な機能を紹介して、Android Studioを使った開発をより快適に出来るようにお手伝いしたいと思います。以下の知識がある方を想定しています。* Android StudioでAndroidアプリの開発をしたことがある* Android Studioの設定をあまり変えたことがない* 複数人での開発を主にしている* セッション中にすごいと思ったら「おー！」って言ってくれるこのセッションでは以下の設定の話をする想定です。独断と偏見で大半の方が触らないであろうと思った設定を中心に説明します。* 自分専用のアクションリストを作ってみる* !=をカッコ良く* 通知周り* File Color* Kotlinのファイルフォーマット忘れ防止* 急に別の言語書きたくなった時のストレス発散方法* JSON書きやすくする* Run Configurationや.ideaの共有* Layout Editor* Pluginのインストールの強制しっかり話す内容全部書き出したので、当日の齟齬は無かったはず。これでCfS通らなかったら、Ubie, incに入社しました。 - shiraji’s diaryにも書いてあるとおり、Android開発から遠ざかっていますし、そろそろDroidKaigi卒業かなとも思ってました。その後、CfS通過連絡を受けて、まだまだDroidKaigiは自分を必要としてくれてたー！って結構喜びました。登壇前登壇前に、音声が出るのか不安だったため、運営の方たちに確認したところ、色々調整してもらい、ランチ時間にRoom1を使わせてもらえることになりました。あの時間にRoom1にいた人たちは「なんだこいつ？」って感じだったと思います。申し訳なかったです。ランチ中にいきなり現れて、息子の動画とAndroid Studio喋らせてるヤツいたらそりゃそうなりますわ。。。登壇時twitter.com意識していた「ライブ感」が本当にうまくできるのか？がすごく心配で、それが緊張を引き起こしてました。本当にみんな「おー！」って言ってくれるかな？って。音声チェックの時のように何こいつ？みたいな反応にならないかな？って。でも運営の人たちが緊張をほぐしてくれたので、だんだん調子が出てきました。Macを見ずに俺を見ろこの発言みんな笑ってくれたのが本当に助かりました。これで完璧に吹っ切れることが出来たと思います。きっと「おー！」の練習しっかりやってくれると。AndroidStudio設定のセッションMacよりshirajiさんを見てほしいとのことなのでMojaveアップグレード始めます #DroidKaigi #room1 pic.twitter.com/hQxboc7u8j— ラルフ (@r_ralph_h) 2019年2月8日ただMac見なくていいとは言いましたけど、まさかその時間でOS更新しようとするツワモノが現れるとは想像してませんでした。面白すぎる。DLは家でしてきたんですよね？「おー！」の練習そして、本番。すっごく盛り上がってくれました。やはりかわいいは正義だ。その後、自己紹介中に「おー！」って言われたのは全く想定してなくて面白かったです。もうこの時には緊張なんて全くなく、全力で楽しんでいました。いい雰囲気でした。Android Studioがしゃべった！この辺、ライブ感満載で最高です。Kotlinのスタイル設定Kotlin Repositoryがこれを導入していたので、この設定は知っていたんです。でもこれが盛り上がるってことはみんなKotlinのコントリビュート環境整備してないってことなので実は寂しい！！！コンディション設定してたのに間違って消しちゃうやつ！この設定見つけた時すごく興奮した覚えがあります。というかこれ本当にデフォルトにしてほしい！Inject Language文字列をjsontとして扱うようにすると勝手に@ Languageアノテーションをつける機能がある #droidkaigi #room1— takahirom (@new_runnable) 2019年2月8日Inject Language自体が理解するの難しい機能で、それを説明して、その特定の不便さを説明して、それを解消する設定の説明っていう周りくどい感じだったんですよね。。。それを takahirom さん的確に説明してくれていて、さすがー！って思いました。Prefer XML editor推しNotification出過ぎ再起動中祈ったのに、結局いっぱい出てくれちゃって、あー！もー！！！って感じでした。練習ではもう一回再起動したりしてたのですが、なんか会場盛り上がっちゃったから、このままでいいかーって感じで流しちゃいましたwライブって感じ。ツイートしてる暇がなかった狙い通りです！予約投稿Twitterへの予約投稿は身内？であるたろうさんが反応してくれてました。本当にテレビの副音声みたいな機能に出来たらなーって思ってたので、嬉しい。ツイートの副音声、最高すぎる— たろう (@ngsw_taro) 2019年2月8日副音声ツイートは SocialDog さんを使わせてもらいました。TweetDeckで当初やる予定だったのですが、投稿予定だったツイートを確認する術がわからなかったため、選定出来ませんでした。Room1がトレンド入り登壇直後にハッシュタグ #Room1 がトレンド入りをしたと連絡もらいました。記念にスクショ撮っておきました。トレンドのロジックを全く理解していないのですが、Room1はそもそも各時間一番人が入るし、直前があのMotionLayoutのお話だし、いまいち何かを達成した感がないです。（そもそもTwitterじゃなくて俺を見てくれ！って話だったわけで・・・）入れなかった方がいた・・・しらじさんのroom1入れなかったから諦めてCodelabに来た— furusin (@furusin_oriver) 2019年2月8日開始直前まであのRoom1が満員になるなんて想像してなかったです。1部屋に入っていい人数って法律で決まっていると思うので、運営の方たちも自分もどうしようもできないので、ごめんなさい！としか言えないです。希望者全員に聴いて欲しかった。ライブ感をものすごく押し出していたので、furusinさんや他にもし会場入れなかった人がいらっしゃったなら、配慮が足りてなかったかもしれないです。本当に申し訳ないです。。。登壇後登壇後、良く見るすごい人たちが集まってきて「どうやって設定共有するの？」という質問を受けました。みんな同じ疑問を持っていたようです。話を登壇中に戻すと、当初全ての説明が終わっても5分残っていたら、11個目の説明をしようと考えていました。10個目の説明の「Required Plugins」を話始めたタイミングで残り5分を切っており、さらにNotificationが出過ぎハプニングのため、会場が盛り上がってました。そんな良い感じの雰囲気のまま「Required Plugins」の説明は残り3分のところで終わりました。最後に感謝の言葉を言うのは30秒もあればできるので、強引に続けてもよかったのですが、練習不足であるのが明らかで、せっかく盛り上がったのに、話を延長して、残念な終わり方は嫌だなー。終わりよければ全て良しだよなーって逃げの気持ちが先行してしまい、そこで「ありがとうございました」と締めてしまいました。が、やはりあの出来る人たちには見逃してもらえない感じでした。そこで、.ideaの設定共有の話をしたのですが、仕組み自体はただのファイルをgitで管理しているという簡単なものなので、1分もかからずみんな納得してくれて「あーこんな簡単ならやれば良かった・・・完全にチキンだったー」と自己嫌悪でした。オフィスアワー登壇後の質問で囲まれた時に運営の方に「やっぱりオフィスアワーやりますか？」と言われました。これは自分の聞き間違えだったかもしれないです。そこで自分は（あ、自分はオフィスアワーなしだったんだ。）と勘違いしてしまい、質問対応後、そのまま控え室に戻りました。そしたら、どなたかが、オフィスアワーで待ってくれてた様で、それを知った時には次のセッションが始まっていました。そこで運営の方が色々動き回ってくれて、こんなツイートをしてくれました。Room 1 14:00 から行ったセッション「Android Studio設定見直してみませんか？」の登壇者への質問がある方は @shiraj_i さんへ直接メンションしていただいて結構です。— DroidKaigi (@DroidKaigi) 2019年2月8日諸々対応して頂き、ありがとうございました！今後もいつでも回答しますし、DMも空いてますので、何か質問あれば今からでもしてください。まとめとにかく楽しかったです。自分は年2回くらいしかこういう大きなイベントには参加しないので、運営の人や他の参加者の方達よりゆるいスケジュールで当日過ごしました。しかし、二日後のいまだに体が本調子に戻らなくて、ちょっとまずいなーって感じです。もうちょっと外に行こうか・・・？Android開発者ではないので、次回のDroidKaigiでCfS突破できるようなネタが探せるのか？が課題ですが、来年も登壇出来たらなーって考えています。おもしろ登壇枠があればきっと大丈夫だと思うのですが・・・運営の方たちの細かな気配りがいっぱいありました。色々対応して頂き、ありがとうございました。そして、最後に、自分の登壇を聴いて下さった方たち、当日「おー！」と盛り上がってくれて本当に本当に本当に話しやすかったです。すっごく気持ち良かったし、楽しかったです。ありがとうございました！！！","link":"https://shiraji.hatenablog.com/entry/2019/02/10/164229","isoDate":"2019-02-10T07:42:29.000Z","dateMiliSeconds":1549784549000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Android Studio設定見直してみませんか？ -詳細-","contentSnippet":"このブログはDroidKaigi 2019の Android Studio設定見直してみませんか？ の詳細です。せっかく聴いてくれる方がメモを取ってて話を聴き逃してもらいたくないためのエントリーです。登壇中何らかの問題が発生した時の対策でもあります。前提設定の遷移の区分けはJetBrainsの公式と同じで「 | 」です。「Preferences | Keymap」という記述の場合、Preferencesの中にあるKeymapというメニューを表しています。Macを使っている前提で話が書いてあります。Android Studio 3.1から3.3.1での動作確認はしています。Quick Listsリファクタ、Surrend With、右クリックなどをすると出てくるポップアップがあると思います。 いろんなポップアップがありますこれ、実は自分専用のポップアップを作ることができます。Preferences | Appearance & Behavior | Quick Listsと遷移するとQuick Listsを作成する画面が出てきます。Quick Listsの設定画面ここの「+」をクリックし、「Display name」にはわかりやすいものを設定し、ポップアップに表示したいアクションを追加します。shiraji quick listsというQuick Listsを作ってみました「Find Actions」で「Display name」に入力した値を選択すると、自分でカスタマイズしたポップアップが表示されるようになります。Find Actionsに表示される自分専用のポップアップが！このQuick ListsはKeymapを設定することも出来て、便利です。keymapも設定できるFont ligatures!=, ->, ==ってITエンジニアなら読むことは出来ると思うのですが、!=は≠と表示される方がカッコイイです！（主観です）Android Studioではこの表示をサポートしています。Preferences | Editor | FontEnable font ligaturesにチェックを入れ、Font ligaturesに対応しているフォントに変えます。Fontはデフォルトで入っていてFont ligaturesに対応しているFira Codeを選択そうすると、コードがこんな感じに表示されるようになります。  左が変更前、右が変更後Notification右下や右上に出てくるポップアップです。Power Save ModeをONにすると出てくるポップアップこのポップアップですが、すぐ消えちゃったり、何度も出てきてイライラさせたりしてくれます。全てのポップアップにはIDが振られており、Notificationの設定で表示方法を変えることができます。これは3rdパーティのプラグインも含まれます。Gradle Syncが終わったらポップアップを表示させるようにしてみる今回紹介したいのはこの設定ではなく、どのNotificationでも使われていない、「Read aloud」という設定です。どの設定もOFFになっているGradle Syncの設定の「Read aloud」を選択して、Gradle Syncをしたらどうなるでしょう？Notificationの内容をAndroid Studioが大きな声で何秒かかったのかを伝えてくれます！(この渾身のネタが文字でしか伝えられない悲しさ・・・)ちなみに当日は、「おおおお！」とAndroid Studioさんに言ってもらうためのプラグインを使い、褒めてもらいました。github.comFile ColorFile Colorはデフォルトで利用されているので、結構みんな知らないうちに使っている機能だと思います。Project Viewにあるテストコードの背景が黄緑になっています。これがFile Colorです。背景が黄緑色になっているタブも色が変わるFile Colorは便利な利用方法があります。Preferences | Appearance & Behavior | File Colors上の方のWindowにある、プラスボタンをクリックします。「Scope」を「Production」として、「Color」を「Blue」としてみます。そうすると、「Run」ボタンを押して、アプリを起動する時に利用されるソースコードが青くハイライトされるようになります。青くハイライトされるBuild Variantを変えても即反映されます。Build VariantをpremiumReleaseにしたら、debugのソースのハイライトが消え、premiumのソースがハイライトされたコードフォーマットコードフォーマットにはいろんな方法が提供されています。昔よく話に上がっていたのは、reformat code/organize importsなどを保存時に実行するマクロを組むとか、Eclipseのデフォルト機能から作られたであろう、Save Actions - Plugins | JetBrainsというプラグインを導入する、Commitダイアログにあるreformat code/organize importsなどにチェックして、Commitする。Commitダイアログのコードフォーマットの設定ここで紹介するのは、コードを書いているときに、コードフォーマット漏れしているかを確認する方法です。Preferences | Editor | Inspections | Kotlin | Style IssuesKotlinのInspectionの中に「File is not formatted according to project」という設定があります。これを有効にして、「Severity」を「Error」とします。これでプロジェクトのコードフォーマット設定に違反したコードを書くと文法エラーのような表示なります。コードフォーマットされていないとエラー表示になるこの赤線のところで、「Option(Alt) + Enter」をすると、「Reformat File」という選択肢が出るようになります。Reformat Fileという選択肢が出るそこで「Reformat File」を選択すると、フォーマットされるようになります。簡単にコードフォーマットできるこれを利用すれば、コーディング中にフォーマットされているかどうかの確認が可能です。Android Studio上でエラー表示になっているだけで、ビルドは問題なく出来ます。余談ですが、特定の箇所をCode Formatしたくない場合もあると思います。そう言う場合はPreferences | Editor | Code Style「Enable formatter markers in comments」を有効にし、「@formatter:off」と「@formatter:on」で括れば、フォーマットエラー表記もされないようになりますし、「Reformat File」しても無視されます。コードフォーマット対象にはならないBreakpointsの削除Breakpointsはデバッグ時に必須なものです。Breakpointsを特定の条件下のみ発動することも可能です。Breakpointを右クリックし、「Condition」を入力すればその「Condition」がtrueの時のみBreakpointで止まります。Breakpointに条件を追加するで、このBreakpoint、作るときも削除するときも簡単で、クリックしたら出来ちゃいます。ワンクリックで簡単すぎる削除・・・結構複雑な条件を設定したにも関わらず、誤ってワンクリックで消してしまい、またその条件を入力しなくてはならなくなった経験ありませんか？筆者は首がもげるくらいあります。この問題への対処方法があります。Preferences | Build, Execution, Deployment | Debugger「Remove breakpoint」のところにある、「Confirm removal of conditional or logging breakpoints」を有効にしてみてください。そうすると、条件付きのBreakpointをクリックすると、削除するか確認ダイアログが出現するようになります。削除するか確認ダイアログInject LanguagesInject Languageと言う機能は生のStringに対して、JSONやYAMLなどの言語に対するサポートができるようになる機能です。対象のStringにカーソルを合わせ、「Option (Alt) + Enter」を押し、「Inject Language or reference」を選択します。その後、そのStringの言語を指定したら、その言語のサポートを受けられるようになります。同じ文字列なのに、コードハイライトが有効になっているまた、ここではJSONを利用しているため、「Edit JSON Fragment」と言う機能も利用でき、それを利用すると、別WindowでJSONを入力したら、エスケープなどを良しなにやってくれるようになります。下のWindowで編集したら上の文字列に反映されるこの機能は非常に便利なのですが、チームで共有するためには、@language(\"JSON\")や//language=jsonなどを記述しなくてはなりません。この記述は「Inject Language or reference」を選択したタイミングですぐに再度「Option (Alt) + Enter」を押せば補完してもらえるのですが、忘れがちです。アノテーションをつけるかを聞かれる。別のアクションをしたら消えてしまう！この問題を解消する機能があります。Preferences | Editor | Language Injections | Advancedこの設定画面の一番下にある「Add @Launguage annotation or comment if needed」を有効にします。その後、もう一度「Inject Language or reference」を選択すると、@language(\"JSON\")や//language=jsonを最初から補完してくれるようになります。Layout EditorAndroid開発者なら誰もがお世話になるだろうLayout Editorの設定の紹介です。このLayout Editorは設定がいっぱいあって、なかなか面白い機能ではあるのですが、今回紹介するのはこの画面の設定ではなく、Preferecesの方の設定を変えてみます。Preferences | Editor | Layout Editorこの三つの設定のうち、一番上にある、「Prefer XML editor」という設定。有効にしてみて、もう一度Layout Editorを開いてみます。Prefer XML editorを有効にして、開き直しても特に見た目の違いが見えない。。。よーく見てみます。本当に違いがありますTextタブの位置が変わっています。Textタブの位置が左に！！！デフォルトでは、Designが左で、Textが右。デフォルトはこれ細部までこだわり抜いて作られている感じがします。Preferenceのパスのコピー方法これは設定というより機能のお話です。登壇中もこのブログでも特定の設定画面への遷移を「Preferences | Keymap」のように記述していました。たぶんここを読んでいる方も社内や自分のドキュメントで設定への遷移を書いたことある人いるのではないでしょうか？これをタイピングするのは、なかなか厳しいです。そこでこの機能を使うと便利です。Preferences | Build, Execution, Deployment | Gradle をタイピングするのは大変左側にあるTree的なメニューにポインターを合わせ、右クリックしてみてください。「Copy Preferences Path」と出てきます。これをクリックすれば、そこまでのパスをコピーすることが出来ます。Copyメニューが出てくるPluginのインストールを強制する特定の機能を使っている場合、チームで必須で使うプラグイン揃えたい時があると思います。例えばDatabindingを使っているプロジェクトでDatabinding Support - Plugins | JetBrainsを入れるとか。登壇で使ったプロジェクトでは、自分がどんなタイピングをしたのか、どんなActionを実行したのかをあとでみやすくなるように、Presentation Assistant - Plugins | JetBrainsを強制していました。Preferences | Build, Execution, Deployment | Required Pluginsプラグインの強制方法はこの設定画面で、現在使っているプラグインの中から強制するプラグインを選択します。これらのプラグインをインストールせずにプロジェクトを開くと、右下のところにエラーが表示されます。プラグインがインストールされていない場合、エラーが出る。このエラーポップアップの「Install required plugin」というリンクをクリックすると、インストール予定のプラグインの詳細が表示されます。OKボタンを押すと、全てのプラグインをインストールしてくれます。当日の発表は多分ここまでです。これ以降は時間の都合上、発表することが出来なかったお話です。設定の共有ここまで色々設定変更を見てきましたが、これらの設定はチーム内で共有することが可能です。多くの設定はプロジェクトの.idea内に含まれています。.idea内に設定ファイルが格納されているexternalDependencies.xmlは必要なプラグインの設定、vcs.xmlはバージョンコントロールの設定だったりします。ただし、例えば、workspace.xmlのようなその個人の設定ファイルも含まれてしまっていますので、必要に応じて、.gitignoreなどでコミットしないように注意が必要です。github.comGitHubのgitignoreにJetBrainsのものが公開されていますので、それを参考にすると良いと思います。icon.png/icon_dark.pngというファイルがあると思います。これはそのプロジェクトiconとして認識されます。プロジェクトのアイコンが表示されるちなみに、最近Android Studioの対応がされた、Toolboxでもアイコンが表示されます。Toolbox便利なのでぜひ使うといいと思いますAndroid StudioをNotepadにしてみよう！最後に（最初から？）ちょっとAndroid Studioで遊んでみます。Android Studioにはいろんなボタンや空白などがあります。これを全て消すとどうなるか！？を試してみます。初期表示「Hide All Windows」Tool Windowを隠す「Tabs Placement」を「None」にタブが無くなった「Show line numbers」を「OFF」に行番号が消えた「Status bar」を「OFF」に最下部のStatus Barが非表示に「Navigation Bar」を「OFF」に上部のNavigation Barを消した「Show Gutter icons」を「OFF」に行番号の横にあったスペースがなくなった「Tool Buttons」を「OFF」に外枠のボタンが全部なくなった「Breadcrumbs」を「Don't Show」に下部のスペースがなくなったここまで来るともうNotepadとほぼ見分けが付きません！画面が有効活用出来そうです！ちなみに、ここまでやってしまって、最初に戻す方法は用意されていません。Macの場合、~/Library/Preferences/AndroidStudio3.3/のoptionsフォルダを消せば元に戻せます。実行は自己責任でお願いします！まとめ以上、DroidKaigi2019の Android Studio設定見直してみませんか？ の詳細でした。これを聴いてくれた、または読んでくれた方が1人でも設定変えてみたり、他にも面白い設定/機能ないかなー？ってAndroid Studioの探訪をしてくれると嬉しいなーって思います！宣伝さて、Ubieでは、こんな感じで、便利なものを積極的に採用して開発を進めています。もし、Ubieに興味出てきたなーって方はぜひ、@shiraj_iにDM下さい！サーバサイドエンジニア以外にもいろんな職種募集していますので、こちらもぜひ確認してみてください。speakerdeck.com","link":"https://shiraji.hatenablog.com/entry/2019/02/08/131843","isoDate":"2019-02-08T04:18:43.000Z","dateMiliSeconds":1549599523000,"authorName":"しらじ","authorId":"shiraji"},{"title":"GraphQL(Kotlin)とStackdriver Traceの美しさに惚れました。","contentSnippet":"GraphQL(Kotlin)とStackdriver Traceがすごくいい感じだったから見て欲しい。実装ここで公開したアプリに修正を加えてみました。shiraji.hatenablog.comgithub.comライブラリの追加spring-cloud-gcp-starter-traceを使い、Stackdriver Trace*1利用するため、gradleに変更を加えます。repositories {    mavenCentral()    jcenter()+    maven(url = \"http://repo.spring.io/libs-milestone\")}dependencies {+    val springCloudGcpVersion = \"1.1.0.RC2\"+    compile(\"org.springframework.cloud:spring-cloud-gcp-starter-logging:$springCloudGcpVersion\")+    compile(\"org.springframework.cloud:spring-cloud-gcp-starter-trace:$springCloudGcpVersion\") {+        // remove this after 1.1.0.RELEASE+        exclude(group = \"io.grpc\")+    }+    compile(\"app.ubie:brave-kt:1.0.0\")https://github.com/ubie-inc/kotlin-graphql-sample/commit/b0aee867adf13e3e2ef41e8c3e8a5979619995f3exclude(group = \"io.grpc\")しているのは、1.0.0.RC1よりバージョンが上のspring-cloud-gcp-starter-traceを使うと、io.grpcが複数のバージョンに依存してしまう問題があるためです。以下で問題提起しています。1.1.0.RELEASEで修正が完了する模様です。github.com環境変数などを変更次に、Stackdriver Traceを利用できるように環境変数などを変更しています。GraphQLのクエリをログ出力するために、graphql.GraphQLのログレベルをDEBUGに変えています。  cloud:    gcp:      trace:-        enabled: false+        enabled: true      logging:-        enabled: false+        enabled: true  sleuth:    sampler:      probability: 1.0@@ -24,3 +24,4 @@ logging:  level:    root: INFO    org.springframework.jdbc.core.JdbcTemplate: DEBUG+   graphql.GraphQL: DEBUGhttps://github.com/ubie-inc/kotlin-graphql-sample/commit/beb23dc3b858c1cd8cbead49d2f7c1a0abd59b21Scope Spanを使い、さらに見やすく最後に、brave-ktを利用して、各クエリがどれくらい時間がかかっているのかを確認するTraceを入れます。-        if (icd.isBlank()) return emptyList()-        return jdbcTemplate.query(+        return Tracing.currentTracer().scopedSpan(\"findKinkiDrugsByIcd\") {+            if (icd.isBlank()) return emptyList()+            jdbcTemplate.query(                 //language=SQL                 \"\"\"                 SELECT                   yj_code,                   icd                 FROM                   disease_kinki_drug                 WHERE                   icd = :icd                 \"\"\".trimIndent(), mapOf(\"icd\" to icd), rowMapper-        )+            )+        }https://github.com/ubie-inc/kotlin-graphql-sample/commit/25e8e477b365f037daa4948dc94b24ff5789709abrave-ktに関しては以下の記事に書いてあります。shiraji.hatenablog.com結果ライブラリ追加して、ちょこっと見やすい工夫を入れるだけなのですが、以下のような結果が表示されるようになります。Scope Spanを使い、各DBアクセスの時間を見えるように1クエリ内で発行されたログも表示できるリクエストクエリなども見える特定のクエリに対して、どのSQLがどのタイミングで発行され、どれくらいの時間がかかっているのか？などが一目でわかるようになりました。感想めっちゃ便利。この結果が美しくて惚れました 😍宣伝さて、Ubieでは、こんな感じで、便利なものを積極的に採用して開発を進めています。もし、Ubieに興味出てきたなーって方はぜひ、@shiraj_iにDM下さい！サーバサイドエンジニア以外にもいろんな職種募集していますので、こちらもぜひ確認してみてください。speakerdeck.com*1:Stackdriver Traceを利用するには https://cloud.google.com/trace/docs/quickstart?hl=ja を参照","link":"https://shiraji.hatenablog.com/entry/2019/01/16/083000","isoDate":"2019-01-15T23:30:00.000Z","dateMiliSeconds":1547595000000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Twitterエゴサーチで見る2018年まとめ","contentSnippet":"今年本当に自分のエンジニア生活が一変した年だったので、書き留めておく。(2年連続同じ文言)shiraji.hatenablog.com技術的な話は皆無です。ツイートと共に自分のための振り返りです。ので、自分のことを知りたい人以外が読んでもらっても多分「あ、そう。」という感想だけしか得られないはずので、戻るボタンクリックお願いします。1月初詣。今年もKotlinで何か出来ますように。New year pray(play?) at Japanese Kotlin holy land pic.twitter.com/WAQkNrotpK— shiraji (@shiraj_i) 2018年1月7日2018年はこんなところからスタート実はですが、初詣に行って、嫁ちゃんに今年で転職しそうだね。しっかりお祈りしときな。と言われて、（ははーん！この人何も俺のことわかってないね！結婚して何年経ったんだよ？）と思ったけど、今日の時点では（何で自分より自分のことを知ってる人がこの世に存在するんだ・・・？）と言う畏怖の念を抱いております。2月前のセッション誰もいないから勝手に本番の場所でリハ始めてます。（スタッフさんたちには話してます）今回、表示してるスライドが見えたりマイク持たなくて良いみたいで、最高すぎる環境っぽい！！！ pic.twitter.com/WW173s5tLs— shiraji (@shiraj_i) 2018年2月8日DroidKaigiがありました。How to Kontribute v4をやりました。このネタは結構な回数こなしてたんですが、あんまりうまくやれずに悔しい思いをしたのを覚えています。あくまで噂で聞いたんですけど、某カンファレンスの参加費を出さなくてエンジニア一人失った某社、今年は参加費出したらしいですよ。辞めたエンジニアさんその会社大好きだって言ってたし、きっと心の底から喜んでるでしょうね😄— shiraji (@shiraj_i) 2018年2月8日きっと心の底から喜んでるでしょうね！3月時間オーバーした気がするけど、ライブコントリビュートしたぞー！https://t.co/keWfqkDPkZ— shiraji (@shiraj_i) 2018年3月15日r.kt #3でライブコントリビュートしました。ライブでコーディングしたの初めてだったので、かなり練習したのを覚えてます。recruit-lifestyle.connpass.comさぁ懇親会だ！ #shibuya_apk pic.twitter.com/xclUxAxWvE— shiraji (@shiraj_i) 2018年3月20日ライブストリーミングでshibuya.apkにも参加しました。子供がいるのでこう言うのがどんどん流行ってほしい！と思ってます。準備が大変ですけど・・・。4月一人目のエンジニアとかになるにはどうやってコネ作ればいいのかわからない。それとCEOがエンジニアじゃないとキツいって聞いたことがあるけど、『一人目のエンジニア』の時点でそれでは？起業？🤔— shiraji (@shiraj_i) 2018年4月6日Twitter転職って人生で何回まで使えて、一回使ったら何年待ったら再度使えるようになるんだろう？🤔— shiraji (@shiraj_i) 2018年4月19日4月になったので、キャリアについて真剣に考え始めたタイミングでした。早めのジョイン狙いだよなーってなってる時です。まさに自分がこれ。最初に入った会社年収350切ってて、副業に手出したけど、無理しすぎて体壊した。そのまま続けても600届きそうになかったし、転職するスキルつかなかった。副業やめてブログやOSSやり出したら転職先選べるようになったし、本業で600万越えた。 https://t.co/4TA3aMwaRk— shiraji (@shiraj_i) 2018年4月19日年収ツイートするといいねいっぱい貰えると学んだツイートスゴい！頑張って下さい！ https://t.co/ZrCBNYmUXy— shiraji (@shiraj_i) 2018年4月23日フラグが立った日やはりスタートアップの早い段階での参画もなると知り合い経由だよね。— shiraji (@shiraj_i) 2018年4月23日そして、その日のうちに、スタートアップの早めのジョインなんて今の自分じゃ無理だと判断したツイート。やっぱり4月は転職周りのツイート多いな。。。5月めっちゃ席空いてる。 pic.twitter.com/iORGriWBGx— shiraji (@shiraj_i) 2018年5月7日自分の顔見て話しかけてもらえるのすごい嬉しい。日本人の知っている人以外ではいないけど。OSS Communityにさっき参加して色んな国の人と話せたので良しとしよう。— shiraji (@shiraj_i) 2018年5月9日Google IOに行かせてもらいました。初めての参加でした。デバイス情報 pic.twitter.com/HgXOJbLCP1— shiraji (@shiraj_i) 2018年5月10日Codelabで問題一切やらずに、ChromeBookの検証してた。これ出来たらOSSとして公開してくれるといいなー。変更履歴とかも見たい。 https://t.co/PIeAK9V8Z9— shiraji (@shiraj_i) 2018年5月21日これ忘れられなくて、どうしてもやりたくて、現職でやらせてもらいました。もうすぐ詳細を弊社の誰かが書くはず！6月サーバサイドKotlinの企業での導入実績ってあるのか？ってツイート見かけた。界隈各位、サーバサイドKotlinの企業での導入事例が行き渡っていないみたいなので、もっとお願いします！（単に自分がいっぱい聞きたい）— shiraji (@shiraj_i) 2018年6月6日サーバサイドKotlinの導入事例のツイートして、聞きたそうな人がちらほら見える。本当に知られてない感じ。。。ちなみに自分が知っている中ではサーバサイドもガッツリKotlinってサービス持っている会社少なくとも5社はあるはず。しかも結構な規模の会社。本も出版されてますよ。— shiraji (@shiraj_i) 2018年6月6日サーバサイドKotlinやりたくて仕方なくなってる頃です。皆様、さらに一社増えそうです。https://t.co/B9Mvz01Wdd— shiraji (@shiraj_i) 2018年6月7日なるほど#GitHubSatelliteTokyo?w=1の機能、UIでもう出来るんだ。— shiraji (@shiraj_i) 2018年6月12日GitHub Satellite Tokyoに参加して、色々話聞きました。で、この機能を知らなかったことに正直衝撃を受けてて、毎日GitHub触ってないことに対して危機感を覚えました。このままこのキャリアでもいいかな？と考えてもいたのですが、この危機感は今でも鮮明に覚えていて、この日を境にキャリアを変えると決断しました。で、6月終わりには現職に転職を決めました。7月Kotlinコントリビュートもくもく会 #1 @コネヒト に参加を申し込みました！ https://t.co/UMftgphmn1— shiraji (@shiraj_i) 2018年7月9日めっちゃ資料作成が捗る。#コネヒトもくもく— shiraji (@shiraj_i) 2018年7月23日コネヒトさんのイベントに参加して、Kotlin Festのネタ集めを始めました。本当にこのイベントのおかげで色々助かったので、コネヒトさんには感謝しかない！全然wifi落ちない。快適すぎる。#コネヒトもくもく— shiraji (@shiraj_i) 2018年7月23日にも関わらず恩を仇で返す実を言うと自分もうだめです。 突然こんなこと言ってごめんね。 でも本当です。8月中旬に次の出社日があります。それが終わりの合図です。 程なく残りの有給休暇消化があります。それが明けたら、少しの間もおかず最終日8/19がきます。— shiraji (@shiraj_i) 2018年7月27日当然ごめん。8月最終出社だん！— shiraji (@shiraj_i) 2018年8月9日そして最終出社日最後の最後まで、店舗の方に顔だして仕事してたりしてました。自分がこの会社で長く働けなかったことは本当に悔しいし、またどこかの大企業に再挑戦できる機会がどこかであればいいなと思ってます。今日のコミケひょっとして、参加できちゃうんでは？（参加準備してない）— shiraji (@shiraj_i) 2018年8月9日そして、テンションおかしくなって、なぜかその日のうちにコミケに初参加を決めました。「西め」あたりにいけば興味あるものが置いてあるっぽい！程度で初参加の素人が戦場に一人で向かう。— shiraji (@shiraj_i) 2018年8月10日参加者がみんな熱いな！ってちょっと感動してました。Kotlin Festスケジュール公開されて、LTの時間と被りました！本当に誰も自分のところに来ないのでは？って心配になってる。自分のトークよりLTのライブストリームでも見て、ちゃちゃ入れする方が面白い気がしてきた。副音声的な。https://t.co/xcROzXyIIk— shiraji (@shiraj_i) 2018年8月17日本当に誰も自分のトーク聴きにこなかったら別ネタでLT乱入しよう。— shiraji (@shiraj_i) 2018年8月17日Kotlin Festのスケジュールが公開されて、ふてくされました。会いにきた。 pic.twitter.com/QXShG7WbJx— shiraji (@shiraj_i) 2018年8月19日入社日前日に現職のBBQイベントがあったので、家族同伴で参加しました。たろうさんとのコードレビューでの殴り合い楽しい😊— shiraji (@shiraj_i) 2018年8月21日入社して一番やりたかったことを2日目にしてやらせてもらって、本当に嬉しかった。機転を効かせてくれたスタッフや会場の皆さん、本当にありがとうございます！当日までむちゃな要望出してもしっかり回答してくれたスタッフの方たちにも感謝です！TLさっき見たのですが、楽しんでもらえたようで登壇出来て本当に良かったです！#KotlinFest— shiraji (@shiraj_i) 2018年8月25日その一週間後のKotlin Festで登壇。自分と同じ時間のLTの人たちがみんな時間通り進めたおかげで、最後の辺り全員が自分の登壇を観ると言う美味しい状況でした。明日Kotlin Festでランチ誰か一緒に行かないですか？サーバサイドKotlinの話したい方、Kontributeしたい方、弊社興味ある方ぜひ！！！自分含めて四人くらいで！（自腹でお願いします。。。）— shiraji (@shiraj_i) 2018年8月24日あと、ぼっち飯回避でTwitterで募集したら始めてお会いする人たちとご飯いけました。本当に楽しかった。shiraji.hatenablog.comこの8月は今年の中で一番濃かったなー。9月現役最後のPRでエバァンジェリストに褒められたので、もう悔いはないです🙏 pic.twitter.com/3mH8Mxeray— shiraji (@shiraj_i) 2018年9月12日現役引退予定でしたが、いまだにバリバリコーディングしてます。35歳定年なんてのはないですね。10月Pixel3予約購入だん！ついに念願の合法のPixelを手に入れるぞ！（スタンドも欲しかったけど、YAuthで弾かれた）— shiraji (@shiraj_i) 2018年10月10日Pixel, Pixel2が出なくて、その発想になってしまいました。今はサーバサイドに戻り、Kotlinやってます。（まさかPixel3が来るとは）一緒にやります？— shiraji (@shiraj_i) 2018年10月18日Pixelを合法的に日本で触れるなんて思ってもいなかったですね。これが4月までに発生してたら転職とかなかったかも？なので、何が起こるかわかりませんね。GraphQL+Kotlin動いた。オシャレだなー。エラー時とかかなあと問題になりそうなのは。— shiraji (@shiraj_i) 2018年10月18日GraphQL始めました。この辺りからツイートがGraphQL一色になってる。かなりお気に入りになった模様。そんなに数ないのですが、UbieでKotlinで殴り合うためのコーディングスタイルを公開しました！https://t.co/O0pzqoWLsO— shiraji (@shiraj_i) 2018年10月25日これ公開したら良くね？って気づいてすぐにOSSとしてコーディングスタイル公開しました。なかなか良い反応もらえて嬉しかった。Is there kotlin support for brave? I don't like writing start()/finish() for spanKotlinで使いやすくなるbraveのサポートってないですかね？start()/finish()を書くのが怠くて。https://t.co/xpo3lurzdK— shiraji (@shiraj_i) 2018年10月26日会社でリリースしたOSSについて書きました！ / “122105” https://t.co/WlQr1AXCbh— shiraji (@shiraj_i) 2018年11月4日その勢いのままbrave-ktも公開しました。shiraji.hatenablog.comgithub.com11月DroidKaigiでAndroid Studioの話しますー！リラックスして聞いてもらうような内容になる予定です！よろしくお願いします！！！ pic.twitter.com/es20siRRJq— shiraji (@shiraj_i) 2018年11月10日2年連続でDroidKaigi登壇が決まりました。今回は日本語でやります。ライブコーディングの予定です。スライドあるとしても自己紹介だけになるので聴きに来てね！Ubieに入社したので書いてみました！ / “Ubie, incに入社しました。 - shiraji’s diary” https://t.co/QWLn43zJrg— shiraji (@shiraj_i) 2018年11月22日キャリア変えたことを報告しました。Android開発者に罵られるかも？とビクビクしてました。でも当然そんなこと無く、本当に暖かい良い開発者コミュニティだなーと思います。DroidKaigiで少しでも恩を返せたらと！shiraji.hatenablog.com12月今年はこっちのアドベントカレンダーに参加です！ pic.twitter.com/DgVshEfzUE— shiraji (@shiraj_i) 2018年12月1日今年はアドベントカレンダーに参加しない方針だったので、こっちの参加表明。勢いで公開して、Kotlin Advent Calendarまで書きました！ / “サーバサイドKotlin+GraphQLのアプリケーションをOSS化しました - shiraji’s diary” https://t.co/E7PqOIu9yj— shiraji (@shiraj_i) 2018年12月14日でもKotlin枠が空いてて、書くのを抑えられなかった人です。これ結構プロダクションに乗っかってるコードに近いので、興味ある人はぜひ触ってみてください！10月から月1ペースでOSS公開してます。そんな頻度とかは特に意識はしてないけど、出せるものは出して、サーバサイドKotlinやる人増えてくれたら嬉しいなー。shiraji.hatenablog.comgithub.com2018年の目標達成度2018年の目標一回登壇を経験したので、流れも掴めたし、登壇の方の負荷も減ると思うので、コードのアウトプットと両立させたい。負荷減ってない気が・・・。OSSのコードアウトプット量は前半かなり減っていたので、焦りが出た。それを機に転職して、2018年後半結構アウトプット出来たと思う。ただ、まだまだやれると思うので、来年はもっと増やしていきたい。2019年の目標OSSもそうだけど、仕事でのアウトプットも増やしていきたい。まだまだ手探り感がある。プライベートはようやく来年から落ち着きそうなので、家族みんな元気に過ごす！が目標。最後に8月に転職してまだ4ヶ月しか経ってないのかーと驚きです。今年は仕事もプライベートも色々あって、ドタバタだった感があります。今年も初めましてな方といっぱい会うことが出来ました。来年もきっと楽しいことが起こるだろうなとワクワクしています。今年一年、ありがとうございました。来年もよろしくお願いいたします。","link":"https://shiraji.hatenablog.com/entry/2018/12/29/190700","isoDate":"2018-12-29T10:07:00.000Z","dateMiliSeconds":1546078020000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Kotlin大好きな人向けなCollectionのstdlibメソッドを掘り出してみた","contentSnippet":"これはQiita Kotlin Advent Calendar 10日目の記事です。qiita.comこれマニアックなんじゃね？Kotlin大好きな人向けなんじゃね？ってstdlibにあるIterable/Collection/List/Set/Mapのメソッドを独断と偏見で挙げてみようと思います！Collection - Kotlin Programming Language想定読者KotlinのCollectionのstdlibメソッドもっと知りたい人一旦はさすがです！って褒めてくれる人環境Kotlin 1.3.11で使えるメソッドにしています。全メソッドPlaygroundで動作確認済みです。distinct説明: 重複削除したListを作るdistinct - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/HJnYskugVfun main() {    val list = listOf(1,1,1,3,5)    println(\"List: $list\") // List: [1, 1, 1, 3, 5]    println(\"Result: ${list.distinct()}\") // Result: [1, 3, 5]}感想: かー毎回Setに詰め込んでたね。それでListが欲しい場合は、toListしてたね。さらに順番が必要なら色々頑張ってたね。便利😊intersect説明: 両方のCollectionに入っている要素をSetにして返すintersect - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/SkQkak_eEfun main() {    val list1 = listOf(1,1,1,3,5)    val list2 = listOf(3,4,1)    println(list1.intersect(list2)) // [1, 3]}感想: 知らなかったら、filterとかcontainsメソッドなどで泣きながら書いてたと思う。union説明: Collectionをがっちゃんこする。戻り値はSetunion - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/rykBje_lVfun main() {    val list1 = listOf(1,1,1,3,5)    val list2 = listOf(3,4,1)    println(list1.union(list2)) // [1, 3, 5, 4]}感想: intersectと同じ感想onEach説明: 渡した引数のactionを全ての要素に実行し、レシーバーを返すonEach - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/HyrGyxugEfun main() {    val list = listOf(1,1,1,3,5)    list.onEach {        println(\"Log: $it\")    }.filter {        it > 3    }.forEach {        println(\"Result: $it\")    }}結果Log: 1Log: 1Log: 1Log: 3Log: 5Result: 5感想: forEachして、そのまま何かしたい！って時にまたレシーバーを書いてたけど、これ使えば全部繋げられるじゃん。便利じゃん。onEachWithIndexとか欲しくなりそう。partition説明: Collectionの要素が引数の条件にマッチした要素をPairのfirstのListに。マッチしない要素をsecondのListに分割するpartition - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/HJgvexugNfun main() {    val list = listOf(1,1,1,3,5)    println(list.partition { it >= 3 }) // ([3, 5], [1, 1, 1])}感想: 分割が必要な時、頑張らなくてもいいね！requireNoNulls説明: 要素にnullがないことを担保する。もし、nullがあればIllegalArgumentExceptionrequireNoNulls - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/SJ3VMlul4fun main() {    val list: List<Int?> = listOf(1,2,4)    val listNoNulls: List<Int> = list.requireNoNulls()}感想: requireNotNullのCollection版って感じ。nullがないことが前提条件のメソッドとかで利用できそう。(特に気にもせずに無心でfilterNotNullするかもだが。。。)unzip説明: PairのArrayに対し、firstの値だけのListとsecondの値だけのListをPairとして返す。https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/unzip.htmlサンプルコード: https://pl.kotl.in/ryYFNedx4fun main() {    val array = arrayOf(1 to \"foo\", 2 to \"bar\", 3 to 5)    println(array.unzip()) ([1, 2, 3], [foo, bar, 5])}感想: ちょっと限定的すぎる？🤔いや、こういうのいいですよねきっと！windowed説明: Collectionをsizeの要素数のListを作る。次のListはstep分ずれたものからスタートする。ごめんなさい。どう英訳すれば一番わかりやすいのかすらわからない。以下が原文。Returns a list of snapshots of the window of the given size sliding along this collection with the given step, where each snapshot is a list.windowed - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/r13a_gdxNfun main() {    val list = listOf(0,1,2,3,4,5,6,7,8,9)    println(list.windowed(size = 5, step = 3)) // [[0, 1, 2, 3, 4], [3, 4, 5, 6, 7]]    println(list.windowed(size = 5, step = 3, partialWindows = true)) // [[0, 1, 2, 3, 4], [3, 4, 5, 6, 7], [6, 7, 8, 9], [9]]}partialWindowsがtrueだった場合、sizeに足りてないものも含む。感想: ちょっと置いていかれたメソッド。これが便利なんだ！というくらいKotlinを使いこなしたい・・・zipWithNext説明: Listの隣り合った要素をListのPairとして返すzipWithNext - Kotlin Programming Languageサンプルコード: https://pl.kotl.in/r1cjdxOlEfun main() {    val list = listOf(0,1,2,3,4,5,6,7,8,9)    println(list.zipWithNext()) // [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)]    println(list.zipWithNext { a, b -> a + b }) // [1, 3, 5, 7, 9, 11, 13, 15, 17]}感想: transformを渡せば、数列とかで便利かも？あとは次の値を見て何かするような処理とかでもいいかも。","link":"https://shiraji.hatenablog.com/entry/2018/12/20/024752","isoDate":"2018-12-19T17:47:52.000Z","dateMiliSeconds":1545241672000,"authorName":"しらじ","authorId":"shiraji"},{"title":"サーバサイドKotlin+GraphQLのアプリケーションをOSS化しました","contentSnippet":"これはQiita Kotlin Advent Calendar 2018 1日目の記事です。qiita.comサーバサイドKotlinのコード公開したらみんな見てくれるかな？そこで開発出来そう！ってなったらサーバサイドKotlinのエンジニアになりたくなるかな？— shiraji (@shiraj_i) 2018年12月13日ツイートしたら良い反応もらえたので、サーバサイドKotlinのアプリを以下で公開する事に決めました。github.comcloneして、docker-compose upしたら、GraphiQLが http://localhost:8090/graphiql 立ち上がって、サーバの動作確認が出来る。簡単！！！GraphiQL画面Ubie内で絶賛開発中のシステムに少し手を加えていますが、基本的に実際に開発している環境と同じになっています。公開目的公開に至った理由はいくつかあります。サーバサイドKotlinやりたいって人のハードルを下げたかったやりたい！という声はいろんなところで聞くけど、「環境ないし・・・。」「経験無いし・・・。」という方も多いと思ってます。実際Ubie入社前の自分がそうでした。このプロジェクトは、clone後すぐにローカルで動かす事が可能です。そのため、このお手軽さを見てもらい、もっと多くの方にサーバサイドKotlinやってもらいたいなーと思いました。Kotlin+SpringBoot+GraphQLの開発者にコードレビューしてもらいたかった。または仲良くなりたかった今回、色々な事情があり、KotlinでGraphQLの採用をしています。自分にKotlin+GraphQLの実績がないため、コードを公開することにより、いろんな人に見てもらい、より良いものになったら良いなと思いました。さらに同じような環境の方ともっと仲良くなりたいです！特に後述しますが、多対多のGraphQLResolverの処理が本当にこんな感じのコードで良いのかが不明です。Spring+GraphQLの情報が少なすぎる。。。もっと効率良く出来そうなんですが・・・同じ構成のものをOSS化することにより、Ubieの入社即パフォーマンス発揮！をしてもらいたかった今のところ、Ubieのサーバサイドに関わる人には入社前に1日インターンをしてもらい、チームに溶け込めるか？を見てもらう時間を取っています。しかし、時間が1日しかなく、環境構築に時間を取られてしまうのはもったいないです。そのため、同じ環境をOSS化することにより、先に環境構築出来る状況にしたいと考えました。さらに将来的には1日インターン宗教上無理！って方にこのOSSプロダクト開発に携わってもらい、雰囲気をそこで味わってもらうのもいいかなと考えています。技術スタックこのプロジェクトでは以下の技術スタックを利用しています。Git/GithubCircleCIDockerPostgreSQLSpring BootKotlinGradle(Kotlin Script)GraphQL/graphql-javaFlywayLogbackktlintJaCoCo(ただしまだテストはない)今後テスト書くので、以下が追加予定JUnit5MockkWebTestClientパッケージ構成app.ubie.kotlingraphqlsample├── domain├── infrastructure│   └── jdbc├── presentation│   ├── queryresolver│   └── resolver└── service(Query)Resolver → Service → JDBCという呼び出し階層になってます。DBE-R図薬と傷病の関係性のサンプルテーブルになっています。医療業界で利用されているデータに合わせ、IDがなかったり、外部キーがUniqueじゃなかったり、全て多対多の仕様になっています。DBアクセスはspringがデフォルトで提供しているJDBCを使い、SQLをコードに書いてDBアクセスしています。これは賛否両論あると思いますが、以下の理由から採用しています。SQLのチューニングがしやすいラーニングコストが低い一目でどこでどのSQLを発行しているのかがわかるFlywayを利用して自動マイグレーションが走る状態にしてあります。GraphQLGraphQLのスキーマ定義ファイルには薬情報と病気情報が定義されています。type Query {    # 薬を取得します    drugs(yjCode: String!) : [Drug!]    # 病気を取得します    diseases(icd: String!) : [Disease!]}# 薬情報type Drug {    # 薬品名    name: String!    # YJ Code。だいたい薬を表すために使われるCode。一意ではないので注意    yjCode: String!    # 併用禁忌薬    kinkiDrugs: [Drug!]    # 処方してはいけない特定の病気    kinkiDiseases: [Disease!]} # 病気type Disease {    # 傷病に対してつくコード。一意ではないので注意    icd: String!    # 病名    name: String!    # 処方されてはいけない薬    kinkiDrugs: [Drug!]}Queryブロックには公開APIが定義されています。graphql-javaではこの定義をGraphQLQueryResolverを実装したクラスで記述する必要があります。このプロジェクトではqueryresolverパッケージ内で定義されています。@Componentclass DiseaseQueryResolver(private val service: DiseaseService) : GraphQLQueryResolver {    fun diseases(icd: String): List<Disease> = service.getDiseases(icd)}@Componentclass DrugQueryResolver(val drugService: DrugService) : GraphQLQueryResolver {    fun drugs(yjCode: String): List<Drug> = drugService.getDrugs(yjCode)}Drug/Diseaseブロック内にあるkinkiDrugsなどの外部キーを使った結合はgraphql-javaではGraphQLResolver<T>を実装する必要があります。resolverパッケージ内で定義されています。typeがDrugのkinkiDrugsの取得時にはfun getKinkiDrugs(drug: Drug): List<Drug>が呼び出される。@Componentclass DiseaseResolver(private val service: DiseaseKinkiDrugService, private val drugService: DrugService) : GraphQLResolver<Disease> {    fun getKinkiDrugs(disease: Disease): List<Drug> {        val kinkiDrugs = service.findKinkiDrugsByIcd(disease.icd)        return drugService.getDrugs(kinkiDrugs.map { it.yjCode })    }}@Componentclass DrugResolver(    private val kinkiDrugService: KinkiDrugService,    private val diseseKinkiDrugService: DiseaseKinkiDrugService,    private val drugService: DrugService,    private val diseaseService: DiseaseService) : GraphQLResolver<Drug> {    fun getKinkiDrugs(drug: Drug): List<Drug> {        val kinkiDrugs = kinkiDrugService.findKinkiDrugsByYjCode(drug.yjCode)        return drugService.getDrugs(kinkiDrugs.map { it.kinkiYjCode })    }    fun getKinkiDiseases(drug: Drug): List<Disease> {        val kinkiDrugs = diseseKinkiDrugService.findKinkiDrugsByYjCode(drug.yjCode)        return diseaseService.getDiseases(kinkiDrugs.map { it.icd })    }}多対多な関係が多く、SQLの発行回数が若干多いなーという印象があります。この辺りどうしたらいいのか誰かと語りたい！！！終わりにこのコード読んで、UbieでサーバサイドKotlinやってみたいと思った方は @shiraj_i に直接DMか以下のWantedlyさんのサイトから話を聞きにきて下さい！www.wantedly.comもっと気軽にUbieに遊びに来たい！という方は以下のBosyuさんからメッセージを送って下さい！bosyu.me(adsbygoogle = window.adsbygoogle || []).push({});","link":"https://shiraji.hatenablog.com/entry/2018/12/14/170446","isoDate":"2018-12-14T08:04:46.000Z","dateMiliSeconds":1544774686000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Ubie, incに入社しました。","contentSnippet":"2018/08/20からUbieに入社しています。3ヶ月の試用期間も無事明けたので、色々書いておこうと思います。キャリアを変えようとした動機ちょくちょく話題になる35歳に今年なりました。現役最終日です😂— shiraji (@shiraj_i) 2018年9月12日2018年4月の時点で自分の今後のキャリアについて悩んでいました。主な悩みはこのままAndroidアプリ開発者を続けるか？です。Twitterさんや日経さんなど今や多くのWebサイトがブラウザ上での体験を圧倒的に良くするPWAを採用し始めています。PWAと比較してネイティブアプリを作る優位性が、低いレイヤーの処理を必要とするゲームくらいしかないのでは？という不安に陥っていました。このままこのキャリアを続けて5年後、Androidアプリ開発者の需要が万が一無くなってしまった場合、40代で(ゲームではない)Androidアプリ開発が得意です！としか言えなかったら、エンジニアとしてのニーズが無くなりそうだと。Androidアプリ開発者の需要がある今のうちに、新しいモノを試して、駄目だったり、さらにAndroid開発者の需要が増えたら、またカムバックすることが最善策ではないかと考えるようになりました。Ubieを知るさぁ次のキャリアどうするかー？といろんな会社にお話させてもらおうと考えていた時にたろうさんの転職のエントリーが出ました。taro.hatenablog.jpこのエントリーで初めてUbieという会社があるんだなと知りました。当時このブログエントリーの感想は面白そうなことやってる会社だなー。RailsをKotlinに置き換えるとかスタートアップがそんな余裕なの！？でした。Ubieと話すたろうさんの記事の後1ヶ月くらい経ってから、Ubieがサーバサイドエンジニアを募集しているということを知りました。せっかくなのでとお話を聞かせてもらいました。共同代表の久保と話すことが出来て、ざっくりまとめるとRailsからKotlinに切り替えるのはガチ論文を読み込んで、真剣に機械学習に取り組んでいる精度に関しては圧倒的な自信あり。他社はまず追いつけない創業して1年目（当時）だけど、日本だけではなく、世界をもう視野に入れてるのような話をしてもらいました。思った以上にすごすぎて、ちょっとポカーンとしちゃいました。Ubieに入るその後、冷静に自分がUbieで働く場合を整理してみるとサーバサイドKotlinをやるチャンスがあるあのたろうさんと一緒に働けるData Scienceチームのサポート役の経験を積めそう組織がまだこれから整備される状況であり、自分の知見が活かせる余地がありそう事業的には伸び代かなりありそう創業1年目のベンチャーで、面白そうなフェーズ自分の次のキャリアとしてこれ以上ないなと思い、入社をさせてもらうことにしました。今では本当にタイミングと運が良かったなと思っています。入社の儀撮影してもらいましたUbieの業務入社前からサーバサイドKotlinをしたいと言い続けていたので、希望通り、主なタスクはサーバサイドKotlinをやらせてもらっています。Kotlin化の初期だったということもあり、たろうさんと1on1での開発をさせてもらいました。そのおかげもあり、サーバサイド開発のキャッチアップは結構すんなりいけました。Ubie社での僕としらじさん？仲良くお仕事してるよ☺️ pic.twitter.com/IKtqCzaV6S— たろう (@ngsw_taro) 2018年10月16日ライフサイクルが非常にシンプルということもあり、Kotlinのコーディングに集中出来、コード書く楽しさを実感してます。テストもしっかり書く文化になっているのもお気に入りです。Kotlinのタスク以外にもGitLabからGitHubへの移行、CircleCIの導入、OSSとしてライブラリの公開などなど色々やらせてもらっています。毎日のようにテレレ テッテッテーとBGMが頭の中で流れています。今後はこれらに加えGraphQL+Kotlinや機械学習との連携、SRE業務やPythonでの開発など様々なことに手を出していきます。リモートRepository移行させたということもあり、正確なPR/issueの数とかわからない+自分の働き方上、多くのRepositoryに顔出しているので、分散しちゃっているのですが、一番コミット数が多いRepositoryはこんな感じでした。Ubieの制度 - リモートワークと有給休暇Ubieは「週2のリモートワークが可能」です。オフィスの環境が良いこともあり、多くの人がオフィスに出社しています。今の事業フェーズではあまりうまく事が進むように整備し切れていないため、フルリモートは出来ないようになっています。今後可能になるように絶賛整備中です。自分は奥さんと子供がいます。台風が来た週、子供が熱を出してしまったため、台風で一日、子供の看病で一日リモートしました。さらに子供の熱が下がらない可能性があり、有給休暇を取るかリモートするか悩んだため、Slackで投げかけてみました。リアクション見てもらえばわかる通り、看病であれば、週3日のリモートもOKでした。ただ、さらに良くないことが続きました。自分の奥さんが入院することになってしまいました。自分たち家族は親族が新幹線乗らないと来れない距離にいるため、今までであれば、この状況に陥った場合は有給を使い看病することになります。入退院を繰り返すことになってしまったので、合計すると3ヶ月のうち、約1ヶ月はリモートしていました。最大2週間連続でした。でも同僚は自分がうまく働けるように工夫してくれました。この件からUbieのリモートワークのルールは「週2のリモートワークが可能。ただし何かしら理由があり、恒久的でなければフルリモート可」が実態です。ということで、この3ヶ月会社にいないことも多かったのですが、最終的に有給休暇の消化0です。子供が産まれてから子供の看病のため有給休暇を取得し、毎年有給消化率80%は越えていました。あんまり自分のための有給を取った覚えがなく、どういうタイミングで取ればいいのか悩んでいます。ちなみに有給は休みます！と宣言したら取れますし、週5のフルタイムであれば入社日に14日付与となります。Ubieの制度 - 勤務時間Ubieは裁量労働制です。日本で初めて入った会社が裁量労働制で、朝9:30出社(1分でも遅刻NG)で帰りは残業などして夜10:00がザラでした(見込み残業が30時間だったので40-50時間くらいサービス残業してました)。そのため、裁量労働制に対して非常に嫌なイメージを持っていて、それ以降裁量労働制の会社を避けていました。Ubieも裁量労働制だと聞いたので、若干の残業は覚悟の上で、プライベートは絶対死守しようと考えていました。しかし、実態はUbieはしっかり裁量労働をさせてくれています。遅刻という概念がほぼなく、業務中にお昼寝や映画を観にいく人もいます。自分は現在奥さんが病気になってしまったこともあり、朝息子を保育園に送り、夜迎えに行くことが必須となっています。そのため、出社が10:00頃になり、退社は17:30です。30分業務時間が足りてません！しかし自分の労働時間ではなくアウトプットを見てくれてますし、足りていない分、家で仕事して補填しています。トータルでは残業はほぼなしです。自分があまりの早さで帰るため、Ubieの他の社員さんたちがどれだけ残業しているのかあまり把握していないですが、自分より早く来て早く帰る人もいますし、自分も今後も残業0時間を目安に働いていこうと考えています！Ubieの制度 - KPTUbieでは週次でチーム内KPTをしています。リモートワークを始めたタイミングではたろうさんや自分が今何をやっているのか把握できない事態に陥ってしまったため、この課題がKPTのPとして挙がりました。解決策としては「Slackで始業時に今日のTODO共有する」としたところ、お互い何をやっているのかが把握でき、リモートでも非常にスムーズにタスクが進められるようになりました。こんな感じで毎朝やってます。この日はリモートで9時から開始残業ほぼなし、リモートもしていて、パフォーマンスが下がらないか不安だったのですが、問題があれば、都度全員で解決策を考え、改善していく文化があり、色々手助けをしてもらい、特にパフォーマンスを落とさずにタスクがこなせています。他にも良いと思ったものを取り入れたり、逆にこれは減らして良いだろうと判断したものは削減したりと試行錯誤していて、ガンガン変わっていく姿が見れて楽しいなーと感じています。Ubieの社員構成Ubieの中でかなり気に入っているのがこの社員構成です。特徴的なのがSaaSのスタートアップにデザイナーが2人揃っていること。しかも強い。この2人がUXのためなら公民館だろうが診察室だろうがガンガン入っていってより観察しまくります。動き方はUIデザイナーではなく、サービスのデザイナーです。医師が2人いるのも特徴的です。Ubieに入って初めて医師って全員が全員病院に勤務するわけでもないのだなという気づきがありました。弊社の医師だけなのかもしれませんが。全体を観て、バランスが非常に取れている組織だなーという印象を受けています。(業務委託の人がカウントされていないので、その人たちを含めるともう少しエンジニアの数が増えます。)ちなみにこの社員構成ですが来月には数字がいくつか増えます。どんどん大きくなっていっていて、ワクワクします。終わりにということで、3ヶ月しか働いていないこともあり、良いことにしか目がいっていない恋は盲目状態のブログエントリーでした。半年くらい働けば、きっと悪いところももっと見えてくるはずなので、来年落ち着いたらまた続編を書いていきたいと思います。これを見て、興味あるなーという方は @shiraj_i にDMしてもらうか、以下で応募して下さい。https://www.careers.dr-ubie.com/www.careers.dr-ubie.com一覧にはないのですが、SREやデータサイエンティストも募集してますのでぜひ！直近ではこんなイベントもあるよ！bosyu.mebosyu.me","link":"https://shiraji.hatenablog.com/entry/2018/11/23/081517","isoDate":"2018-11-22T23:15:17.000Z","dateMiliSeconds":1542928517000,"authorName":"しらじ","authorId":"shiraji"},{"title":"brave-ktをリリースしました","contentSnippet":"Ubieという会社に入社して、brave-ktというライブラリを公開しました。Ubie入社ブログエントリーは試用期間明けたら書くとして、このライブラリについて書いていこうと思います。想定読者Ubieのシステムに興味ある人サーバサイドKotlin興味ある人前提今自分が関わってるプロジェクトではSpring Boot2.1+Kotlin1.3+GCP(GKE, CloudSQL)を利用して、RESTfulのAPIを開発しています。ざっくり図にするとこんな感じです。よくある構成だと思います。ユーザがAPIを叩くと、最初にロードバランサーに到達し、アプリサーバを経由して、DBアクセスします。ログ出力この構成で問題になるのはログです。一つのリクエストを処理するのに複数のコンテナが関わっており、あるユーザのリクエストを追跡する場合、ログを一つ一つ確認していかなければなりません。この問題を解決するために出てきたのであろうものがStackDriver Traceです。導入すると以下の公式ドキュメントのquickstartの画像のようにTimelineのところで複数のコンテナのログを一つのリクエストごとにまとめてくれます。Quickstart  |  Stackdriver Trace Documentation  |  Google CloudStackDriver Traceの導入StackDriver Traceの導入には、Google Cloud SDKが必要です。Installing Google Cloud SDK  |  Cloud SDK Documentation  |  Google Cloudgcloudにログインして、project名を設定します。gcloud auth application-default logingcloud config set project [PROJECT名]Spring Bootでの導入には設定をいくつか追加します。Ubieではlogbackを利用しています。ちなみに、spring-cloud-gcp-starter-traceの1.0.0.RELEASEは動かないので注意して下さい。build.gradlerepositories {    // for spring-cloud-gcp-starter    // There is a bug on 1.0.0.RELEASE    maven { url \"http://repo.spring.io/libs-milestone\" }}dependencies {    compile 'io.sentry:sentry-logback:1.7.5'    def springCloudGcpVersion = '1.0.0.RC1'    compile(\"org.springframework.cloud:spring-cloud-gcp-starter-trace:$springCloudGcpVersion\")    compile(\"org.springframework.cloud:spring-cloud-gcp-starter-logging:$springCloudGcpVersion\")}logback-spring.xml<configuration>    <springProfile name=\"production\">        <include resource=\"org/springframework/cloud/gcp/autoconfigure/logging/logback-appender.xml\" />        <root level=\"INFO\">            <appender-ref ref=\"STACKDRIVER\" />        </root>    </springProfile></configuration>application.ymlspring:  cloud:    gcp:      trace:        enabled: true      logging:        enabled: true  sleuth:    sampler:      probability: 1.0問題発生さて、ここまでやってログを出してみたのですが、以下のようになってしまいました。queryのログなどがまとまっています。しかし以下の赤線の部分がquery実行中になるはずなのですが、queryの実行時間などを見ることが出来ません。これはCloudSQLがTraceなどに対応していないように見えます*1。つまり以下のような感じになっているようです。これを解決するためには、GCE上のSpring+Kotlin側で明示的にログを出力する以外手は無さそうです。ようやく本題この問題を解決するため、TraceのライブラリにあるScopedSpanを使います。val span = Tracing.currentTracer().startScopedSpan(\"db access\")try {    jdbcTemplate.query ( ... )} finally {    span.finish()}こんな感じに表示されるようになります。良さそう。それでこのコード見てて、Kotlinだしもうちょっと書きやすくできないかなーって思い、ライブラリを作りました。それがbrave-ktです。これを導入すると以下のように書けるようになります。val result = tracer.scopedSpan(\"db access\") {    jdbcTemplate.query ( ... )}以上！（二行しか紹介してない。。。）宣伝さて、Ubieでは、エンジニアを募集してます！https://www.careers.dr-ubie.com/www.careers.dr-ubie.com結構GCPにはヘビーに今後も依存していくので、その辺り関わりたいSREの方や、Spring+Kotlin書きたいサーバサイドKotlinやりたい人はぜひ応募して下さい！雰囲気先に知りたいって方は以下のただ社員が遊ぶイベントがありますので、どんな感じか確認しにきてください。bosyu.meちょっと怖いから何からすればいいかわからない。という方はTwitterでDMして下さい。*1:Issue上げてます。https://issuetracker.google.com/issues/118466628","link":"https://shiraji.hatenablog.com/entry/2018/11/04/122105","isoDate":"2018-11-04T03:21:05.000Z","dateMiliSeconds":1541301665000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Kotlin Fest 2018に参加してきました","contentSnippet":"Kotlin Festの感想ブログを読んでいて、やっぱり自分も書きたくなっちゃった。だから書く。登壇依頼DroidKaigiの発表の時、CfPを出すものだと思っていたので、何を書こうかなー？って思ってたのですが、一向にCfP出せる場所がなく、本当に大丈夫なのかな？と心配していたら、@satorufujiwaraさんから依頼を直接受けました。日時が土曜日だったこともあり、家族に確認を取り、なんとか了承してもらって参加することに決めました。登壇内容はHow to Kontributeを日本語でやってほしいという話でした。もともとはHow to KontirbuteはOSSの話であるし、日本人だけにやるものではないと思っていて、英語でやるものだというイメージがあったのですが、藤原さんがそういうならと日本語でやってみようと思い、快諾しました。登壇準備準備は英語のプレゼンを日本語にしていくだけなので、簡単だと思ってました。が、初めてリハをやったときは52分(セルフィーなし)という記録を出してしまいました。これはプレゼン最中にふと思ったことを口にしてしまえる母国語だからで、これ重要だ！とかここで笑いを取りにいけそう！と思ったら口に出してしまい、グダグダに伸びるという状態でした。さすがに5分以上超過はまずいと、スライドを何枚か削り、メモを英語で書いていたので、あまり考える余地を作らせないために、日本語に書き直すなどの対処をしました。スケジュール確定スケジュールを知ったのはconnpassでスケジュールが公開された時です。公開された＋LTと同じというのを同僚の某主催者から聞かされました。カンファレンスでは基本早めにトークさせて下さいって毎回お伝えしているのですが、Kotlin Festでは時間の指定しなかったです。ただまさか最後になると思ってなかった＋LTとセッションを同時刻にやると思ってなかったので、決まった時の本音は「それはないわー！」でした。前日完全に見落としてたのですが、ランチがないことにconnpassを見て気づきました。で、せっかくだし、色んな人と話したいと思ったので、こんなツイートしました。明日Kotlin Festでランチ誰か一緒に行かないですか？サーバサイドKotlinの話したい方、Kontributeしたい方、弊社興味ある方ぜひ！！！自分含めて四人くらいで！（自腹でお願いします。。。）— shiraji (@shiraj_i) 2018年8月24日これツイートする前に結構文章推敲してて、それを嫁ちゃんが横で見ていて、ツイートしたらぼそっと「これで誰も来なかったらウケるｗ」って言われてまじでこれで来なかったらどうしようと泣きそうになりましたが、結果4人も集まってくれました！ちなみに夜にリハする予定だったのですが、気づいたら、寝てて、3時くらいに「あ、この登壇終わったわ・・・」と愕然としてました。当日(午前中)時間通りに到着しました。ビルの入り口がわからなくて迷子になったけど。会場の入り口がわからず、一周しちゃった— shiraji (@shiraj_i) 2018年8月25日登壇者の控室がものすごく広くて快適でした。快適だったんですが、これなら3つの会場にしてもらって、もっと色々発表あったら！と思ったけど、あまりに快適だったからやっぱりそのままがいいです。控室にもセッションの音とスライドが見えていて、登壇準備や練習をしつつ、聴けるという最高の環境でした。オープニングは会場の雰囲気を確認したく、2列目で聴いてました。そしたら、LTと時間がかぶったためなのか、二回も紹介してもらっちゃって、もうテンション上がりまくりでした。私です！ （うまく撮れない😂）#KotlinFest pic.twitter.com/KNFTKk7Xln— shiraji (@shiraj_i) 2018年8月25日また紹介してもらえたー！！！#kotlinfest pic.twitter.com/gCZAGF3691— shiraji (@shiraj_i) 2018年8月25日「Kotlinを愛でる」をプッシュしまくっていたので、じゃあ、ということで、タイトルにEmbracing Kotlinを追記しました。ランチ前日に募集したのですが、何話すとか、何も決めずに向かいました。お店は朝迷ったときにビルの1階に肉のお店を見つけて、暑かったし、そこでどうでしょう！って即決しました。初めて会った人ばかりだったのですが、一時間Kotlinの濃い話が出来ました。もっと時間あったら良かったのですが、本当に楽しかったです。また登壇とかする機会があれば、スピーカーということネタにランチ募集しようかなと思いました。当日(午後)参加者と交流することが目的だったので、セッション一つも聴いてないです。(そのためPSIViewerがこの日二回目の登場だったのを知らなかった)Yahooさんのブースでモブプロやるって言っていたので、参加しました。モブプロはあと一人か二人自分のチームに入ったら、たろうさん、自分含めやってみたいなーと思ってたので、どういう感じになるのかな？ということで参加しました。RESTのAPIを作るプロジェクトでした。Springの知らない機能を使っての実装だったので、あんまり口が出せなかったのが残念だったのですが、気になっていた、意見が衝突する場合、どう解消するのか？を知りたく、それまでの話からドライバの方が想定していたであろうControllerのメソッド名(findById)ではないもの(show)にしませんか？と叫んでみました。まぁRESTのControllerのメソッド名はあんまり影響ないためか、参加者から挙がったものだからか、特に議論もなく採用されてしまいました。あー！やっちまった！ということでモブプロで爪跡残したぞ！#kotlinfest— shiraji (@shiraj_i) 2018年8月25日さすがに時間が短かったなーという印象です。登壇前の30分でしたし、参加者は席を取りたいし。個人的には実際に意見がぱっかり割れた時にどのように合意が形成されるのかが知りたかったです。RESTのAPIを作ることが目的になってしまっていた感じで、うーん、じゃあSpringのライブコーディングという形にして、モブプロではなくても良いんでは？となってしまいました。でもモブプロを疑似体験出来て良かったです。設計するタイミングとかでの採用もいいなーという感じでした。他にもmixiさんやCAさんのブースのPuzzler参加しました。mixiさんの方では、何問か間違えましたが、なんとか良い結果だったと思います。CAさんの方はさっぱり過ぎて、手元にIDEAないと無理でしょこんなん！という感じでした。楽しかった！ただ、CAさんの方、これせっかくやるならエンジニア一人は常時ブースにおいてほしかったです。ブースにいる方がふたりともエンジニアじゃなくて、このコードに関してーとか話そうとしたのですが、エンジニアじゃないので、またあとで来て下さい！と言われてしまって、うおー聴きたい！と消化不良でした。もっと話したかった！ブースを一通り回ってから、控室に戻り、スライドの手直しをはじめました。控室で他のスピーカーの話が聞こえるの非常に良いのですが、あまりに面白そうな内容で気になってしまって、控室前の椅子に座って準備してました。トイレ前だったこともあり、結構色んな人に話しかけてもらえて、これはこれで楽しかったです。登壇前の緊張がほぐれたし、色々また勉強することが出来ました。登壇2時間前くらいに自分のスライドの特にInspectionの実装コードのスライドがちょっとこのカンファレンスの空気と合ってないなーと感じました。そこで、登壇時間が懇親会前ってこともあり、急遽いらすとやさんの飲み物、食べ物の画像をペタペタ貼り、Twitterで盛り上げようぜ！というスライドを追加しました。このタイミングでスライドを増やすことにより、80Pに到達した。。。— shiraji (@shiraj_i) 2018年8月25日残り時間少しということもあり、最後のリハをしました。控室で外向きながら小声でブツブツ話していたので、傍目から見たら相当やばい感じだったと思います。登壇登壇前15分に会場に行きました。アダプターが合わず、かなり焦ったのですが、スタッフ、会場の皆さんに探してもらい、ちょうど良いものを10分くらい前にそろえてもらいました。本当に感謝です。さらに想像通り、結構な方がLTの会場に向かっていました。そこで登壇者の控室で近くにいた、m3の方たちに控室で聴けるにも関わらず、空いてるから会場に来て下さい！とお願いしたら本当に来てくれてしかもかなり前の席を確保してくれるという神対応をしてもらいました。登壇前めっちゃ緊張してたのですが、@mhidakaさん、@shanonimさん、@chiiia12さんが色々話しかけてくれて、結構リラックスしてやることが出来ました。登壇中、いくつかのスライドで頭真っ白になってしまい、あれ？何話すんだっけ？とめっちゃ頭がフル回転したのは覚えています。会場に聴きにきてくれた人たちの反応が暖かく、自分が思った通りのところでしっかり反応してくれていて、やっぱりKotlin界隈暖かくていいなーと。懇親会のための気分盛り上げのいやすとやさんも反応が良くて、してやったり！でした。photos.app.goo.glそして、未来のKontributorの皆さんです！すいません！！！自撮りが下手で全員入ってない😭https://t.co/UJSz3W7rih pic.twitter.com/VtN7nNEJ4p— shiraji (@shiraj_i) 2018年8月26日終わった後気づいたのですが、LT会場でも結構自分のことを紹介してもらっていて、さらにスタッフの機転でLT後に自分の会場もつないでもらったようで、本当にごちそうさまでした。某主催者から会社のランチで、LTと同じ時間ですって聴いて、それはないわーLT何人も話すし、そんなん誰も聴きにこないじゃーん！って思ったんですが、オープニングでは二回も紹介してもらえたし、部屋にいっぱい人が来てもらえてたし、さらにLT会場も繋げてもらえて、はっきり言って美味しかったです😊— shiraji (@shiraj_i) 2018年8月25日懇親会懇親会ではパックマンルールが採用されてました。本当にこのルールいいですね。懇親会だと仲良い人と話すことになりがちなんですが、空いているので、入ってきやすいし、輪を作ってる人も周りを意識している感じでした。でももっとはじめましてな方と話したかった！最後にものすごく楽しかったです。Kotlin Fest 2019も登壇したい！！！Kotlinをもっともっと愛でたい！！！！！！","link":"https://shiraji.hatenablog.com/entry/2018/08/26/160112","isoDate":"2018-08-26T07:01:12.000Z","dateMiliSeconds":1535266872000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Google IO 2018に行ってきました","contentSnippet":"まとめAIとJetpackとConstraintLayout前提条件会場で起こったことをつらつらと書いていきます。技術的な話は一切ありません。苦手な人は戻るボタンで戻って下さい。前日SFにはGoogle IO前日に到着しました。飛行機内がガラガラだったため、平らな場所で足を伸ばしてのんびり出来ました。1時間ほど寝れたのが良かったのか時差ボケはなかったです。筋肉のおかげかもしれません。筋トレしてないですけど。着いてすぐにSFで仕事があり、SFO->SFにBARTで行きました。先方と会議をしてから、CaltrainでSF->Mountain Viewへ移動。このまま会場でBadge Pickupしたかったのですが、スーツケースが飛行機で壊れされちゃったので、一旦AirBnBの宿泊先に行きました。プール付きでした。一日目(Keynote)セッションの予約はこのセッションだけは聞かないと帰れない！というKotlinの2セッションだけ前日までにしていて、あとはKeynoteを確認してから予約しようと考えていました。前から聞いていたけど、KeynoteはAI一色。何をするにもAIが入っていた気がします。他にはJetpack周りが大きいかな？という印象でした。自分の現在のタスクがAndroid開発から離れ、R&D的な仕事をしているため、知識を広げることに重きを置き、聞くセッションを決めました。それと一回はコミュニティのMeetupに行きたかったので、二日目のOSS Community Meetupに行くこととしました。一日目(セッション)Effective machine learning using Cloud TPUsWhat’s new with Android TVWhat's new in Android development toolsThe future of apps on Android and Google Play: modular, instant, and dynamicModern Android development: Android Jetpack, Kotlin, and moreと、Keynoteでは考えておきながら、いくつか会場を間違えて入ってしまったので、結果的にAndroid中心に聞きました。The future of apps on Android and Google Play: modular, instant, and dynamic印象的だったのが、間違って入ったセッションの一つのThe future of apps on Android and Google PlayでDynamic Featureです。ざっくり概要としてはDynamic Featureの話の前提としてアプリサイズは小さく抑えたいよね。ほぼ使わない機能は使う人にだけ渡せば良いよね？という流れから出来たであろう機能です。実際、アプリを開発していて、この機能90%以上のユーザ使わないな。って機能結構あるので、非常に良いなーという印象でした。code pushみたいな名前なので、戸惑う可能性があると思いますが、apkをGoogle Play内で分割しているという印象なので、Dynamic featureだけを更新するとかは出来ないようです。Modern Android development: Android Jetpack, Kotlin, and more他のセッション聴いていてもそうなんですが、今後Android開発ではJetpackが台風の目になるのは確実だなという印象を受けました。ただ若干勇み足な感じもしていますが。。。詳しいことはすごい人に任せます。一日目(セッション後)アメリカで働いている同僚と落ち合いました。そこにいた色んな人とお話が出来ました。そこまでほぼ一人で行動していたので、楽しかったです。日本の初めてお会いする方ともお話が出来ました。マジックショーがあったので、それを見て、AirBnBの方へ戻りました。そこから日本のチームと仕事してたのですが、なぜか3時までやってました。惚れさせ１５５　「実質」二日目(セッション前)朝8時前にAirBnBを出たのですが、Lyftの車が全然来なかったです。値段が跳ね上がってました。初めてシェアして乗りました。道路も混んでおり、降りた時点で8:30過ぎてました。一緒に乗車していたロシアの方と降りた後話が盛り上がり、入り口でものすごい並んだので、二人でデバイスピックアップにいきました。Android Thingsはパズルやらないとあげないーとかわいく拒否されたので、前日終わらせていた彼にヒントもらいパズル解くことにしました。会場入り出来たのが結局9時前だったので、朝ごはん食べつつ、掲示されているブースを色々回りました。二日目(セッション)What's new in Android Things[Meetup] Open Source communityBuild real consumer devices with Android ThingsTensorFlow for JavaScriptWeb Components and the Polymer Project: Polymer 3.0 and beyondAndroid Jetpack: what’s new in Android Support LibraryML Kit: Machine Learning SDK for mobile developersIntegrating your content with the Google Assistant using AMP and markupThe power of Headless Chrome and browser automationMachine learning models + IoT data = a smarter worldこの日はトピックがうまくバラけました。Open Source Community初日に参加を決めたOpen Source CommunityではGooglerのOSSの人たちと話せるということで、GoogleのOSSにも関わりたいなーと思っていたので、ぜひにと気合入れていきました。そしたら、すんごいふんわりいつの間にか始まっていて、勝手に話して良いよ？と言われ、うまく輪の中に入れなかったので、一緒に輪に入れなかった人たち+後から来た人たちと話しまくってました。結局40分ほどずっと同じ人達と話してGooglerと話さなかったｗでも普段かかわらないnode.jsのコントリビューターやUS政府のプロジェクトに関わっている人たちと話せたのは良い機会でした。OSSをやりたいけど、やったことがないという人たちにアドバイスとかもしてました。プロジェクトへの参画動機や最初のコミットどこから？などみんな同じような考えをしていたのが印象に残りました。TensorFlow for JavaScript特に印象に残ったセッションの一つのTensorflow for JavaScript。お昼ご飯食べつつ、片耳で聞いているかーと思い芝生から聞いていたのですが、途中から楽しくなっちゃって食べずに話ばっかり聞いてました。tensorflowの結果をブラウザで見える化したらすごい良いレスポンスだったので、JSでtensorflow出来るようにしてみたらしいです。ブラウザで出来るというのはすごく敷居が下がって良い。さらに過去サーバでpythonなどで生成したモデルもそこで再利用出来るのも既存の資源が無駄にならないのも良い。高校生や大学生が利用しているとか。AIを高校生の時点で学べるなんてなんて贅沢なんだ。。。さらにこの日サーバサイドでnode.jsが使えるようになったという発表されました。python一色だったtensorflowにJSの流れが来ているので、今後注目だなーという感じでした。Web Components and the Polymer Project: Polymer 3.0 and beyondPolymerの発表もすごかったです。Polymer界では有名な二人が登壇するとあって、登場しただけで拍手出てました。ニワカなので、すごさがわからなかった。内容はもう怒涛な感じでした。前日の睡眠不足から、このあたりで眠気くるよなって思ったんですが、寝てる暇ないくらいどんどん新しい情報をinput出来ました。Polymer3.0が使えるようになったことと今議論進んでいる内容も含めて色々話が聴けました。このセッションのメモ「情報ありすぎてウケる」で終わってました。動画確認してみてください。本当に怒涛です。Android Jetpack: what’s new in Android Support Library昨日からちょくちょくJetpackのFragmentという言葉が出ていたので、あーヤバそうだなーって思い、これを聴いて、パッケージが変わるのが確定したので、issueあげておきました。https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/472書いた後にFragmentだけじゃなくActivityもじゃね？別のsupport libのクラスもじゃね？って思ったんですが、後で考えることにします。二日目(セッション後)前日に続き、仕事がふってきていたので、コンサートも参加せず、AirBnBで仕事していました。自分頑張りすぎだと思う。賞賛して下さい。三日目(セッション前)朝は結構空いていました。3日目ともなるとみんな体力なくなるのかな？まず朝初っ端からPermissionsDispatcherの対応に関してOffice Hourに向かいました。ただ、残念ながら、support libraryの人たちではわからないと言われ、Sandboxへ行くように言われ、行ってみたら、わかる人がまだ来てないとのことでした。もうこの時点で結構時間を取られていたので、セッション終わった後にまた来ると伝え、場所を離れました。たらい回しになったのですが、みんな良い感じで接してくれたので、特に嫌な思いをしなかったのが良かったです。最終的にこのコメントになりました。https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/472#issuecomment-388219243三日目(セッション)How to Kotlin - from the Lead Kotlin Language DesignerAndroid Jetpack: sweetening Kotlin development with Android KTXWhat's new with ConstraintLayout and Android Studio design toolsHow to Kotlin - from the Lead Kotlin Language DesignerKotlinの神が初心者向けのKotlinの説明をしてくれました。どんどんコードが短くなっていくなーって眺めていたら、coroutineの説明が出てきてあー最早coroutineは初心者向けの常識なのかと驚きました。Android Jetpack: sweetening Kotlin development with Android KTXJakeさんのセッション。ktxの説明よりKotlinのライブラリを作るにはどうしたら良いか？という説明の方を目的に聴きました。ktxの方の説明、力抜いていたのですが、ライブラリの話になって、急に@ExtensionFunctionをJavaコードにつけたら、Kotlinが勝手にExtension Functionと認識して呼べるようになるだからこれをつけよう！って話していて、このアノテーションを出された時点で混乱して、ググっても情報なんら出てこないし、どういうことだ？って思ったら、この発表の1時間前にKEEPにJakeさんが上げた内容の説明だったようです。github.comあまりに驚いて。これでも、すごくない？まだ自分一人でこれ欲しいんだよねーって言ってるだけで、誰からもレスポンスないのに、あのGoogle IOで入るかもよ！って話すんだよ。こんな暴挙出来るの世界でも彼だけでしょ— shiraji (@shiraj_i) 2018年5月10日What's new with ConstraintLayout and Android Studio design toolsすごい。やばい。すごかったです— shiraji (@shiraj_i) 2018年5月10日セッションを見てないAndroiderは最初のほうは流していいから、早めに観たほうが良いです。三日間のセッションで一番拍手が凄かった。三日目(セッション以外)三日目で人も少なかったし、アグレッシブに動き周りました。Android AssistantAndroid AutoDesign & AccessibilityCodelab友達が出来た+会えたAndroid AutoAndroid Autoは前から楽しみにしています。一緒に並んでいた4人と車の中で説明をしてもらいました。車のエアコンのコントロールを声で出来たり、Google Assitantを利用して、メッセージのやり取りなどそ実践してもらいました。大きなサイズのものなのか、タブレットサイズで、画面が非常に見やすかったです。NY Timesなどがサポートしているようで、音でコンテンツを提供できるアプリなどは最高だなーという感じでした。CodelabCodelabは多くの問題があり、Googlerに聴きつつコードを書ける場所だったのですが、ChromeOS with Linuxが気になってしまい、マシンスペック見たり、コマンド触ってみたり、全くCodelabとは関係ないことをしていました。Chromebookセッションの時adbないって笑ってたのに、普通にインストール出来てるし、動いてるし、空プロジェクトなら簡単にシミュレータにインストール出来るし、まじで買いじゃん！— shiraji (@shiraj_i) 2018年5月10日pic.twitter.com/Cw8n0xf6Sk— shiraji (@shiraj_i) 2018年5月10日gitも入ってる pic.twitter.com/ti4VZ5zkLu— shiraji (@shiraj_i) 2018年5月10日MBAとほぼ同じ薄さ。重さもほぼ同じ。 pic.twitter.com/eWN3RPlbWB— shiraji (@shiraj_i) 2018年5月10日Linuxのデフォルトで入ってるコマンド結構使えますね。curlとかも出来ました。 pic.twitter.com/3g0O6pliSg— shiraji (@shiraj_i) 2018年5月10日帰国便待っている時に@ymndさんから聴いたのですが、実機確認が直接出来ないとのことだったので、開発機としてはやっぱり厳しいのかなー？と思いつつ、curlやsshなども出来たし、サーバサイドの開発などには可能性あるかもなーとぼんやり考えてます。友達が出来た+会えたOSSのCommunity Meetupだけではなく、偶然話しかけてくれた人と仲良くなったり出来ました。また、普段会えない人たちともお会い出来ました。道ですれ違って挨拶だけしかしなかった人が何人かいて、時間が足りませんでした。。。突然だと「あ、あ、」ってなってしまう。。。その中でも特に印象が残っているのが、以前Kotlin Night Koltakaでリモートで挨拶させてもらった@ravidsrkさんと偶然隣の席になり、お話出来たことです。What a coincident! @ravidsrk find me sitting next seat! #io18 We met @KotlinKolkata night remotely. pic.twitter.com/bBS4RXKhLu— shiraji (@shiraj_i) 2018年5月10日彼はKontributeの動画を観てKontributeし始めてくれた一人で、さらに自分の公開しているプラグインもガッツリ使ってくれているようでした。会社の環境構築フローに自分のプラグインを数個入れてくれていて、Find Pull Requestなんてあるよ？と説明したら、めっちゃ喜んでくれました。最近これ動かないけど、どうしたの？とか、この機能公式に取り込まれたね！とか作った本人よりプラグインのこと知っててくれて本当に嬉しかったです。最後にAndroid周りはスゴイ人たちがわかりやすく説明してくれるはずなので、新しい出会いを求めることに努めて非常に良かったなーという印象です。このIOでAndroid関係ないTODOの優先度最高なものがいくつか出来たので、何かしら形にしたいなーと思っています。","link":"https://shiraji.hatenablog.com/entry/2018/05/12/162608","isoDate":"2018-05-12T07:26:08.000Z","dateMiliSeconds":1526109968000,"authorName":"しらじ","authorId":"shiraji"},{"title":"DroidKaigi 2018で登壇した&参加した","contentSnippet":"技術的な話は相変わらず一切ありません。いつものヤツです。そういうのが嫌いな人は「戻る」ボタンをクリックして下さい。前日プレパーティーに参加しました。悪魔「今日これからPre Party楽しみなよ！せっかくだしいっぱい飲んじゃいなよ！」天使「楽しんでる余裕あるの？お前まだ全然プレゼンうまくできてなくない？明日だよ？」うわー！😢— shiraji (@shiraj_i) 2018年2月7日ウーロン茶を持って、色んな人と話しました。楽しかった。もっと時間欲しかったです。名札をもらったのですが、その後のコミュニケーション取るためにQRコード貼り付けました。#DroidKaigi の名札だけだと初めて会う人にその場で忘れられそうなので、センスないけどTwitterのQRコード貼り付けた。（スタッフの方、駄目なら剥がしてこのツイート削除しますのでご指摘下さい！） pic.twitter.com/ys39vbEHmk— shiraji (@shiraj_i) 2018年2月7日でも話しかけてくれる人自分をフォローしてくれている人だったので、これをスキャンしてくれる人誰もいなかったです。DroidKaigi2019では何かしら連絡方法をこれで交換できるようにしてくれたら嬉しいなーと思います。初日の午前中午前中はwelcomeトークを聴いてテンション上がりました。公式アプリのコントリビュートもなんとか出来たので、きっと自分のアイコンもあったと思いますが、スマホ探していて見逃しました。あ、自分のアイコン見逃した😭— shiraji (@shiraj_i) 2018年2月8日Kotlin User Groupのたろうさんから以下のイベントが発表されました！Kotlin Developers Conf in Japan!!!!!!!!!! pic.twitter.com/gJLzzplWMM— shiraji (@shiraj_i) 2018年2月8日これは楽しみです。登壇できるのかどうかは不明ですが、絶対参加したいです。その後、申し訳ないのですが、自分の用意のため、午前中のセッションを聴くのを諦めました。前のセッション誰もいないから勝手に本番の場所でリハ始めてます。（スタッフさんたちには話してます）今回、表示してるスライドが見えたりマイク持たなくて良いみたいで、最高すぎる環境っぽい！！！ pic.twitter.com/WW173s5tLs— shiraji (@shiraj_i) 2018年2月8日いくつか聴きたいセッションがあったのですが、録画で絶対聴くことにします。自分のトーク登壇は思い出したくないくらい苦い思い出となりました。以前別のイベントで話した時と同じでした。自分の想定していたタイミングで聴いてくれた方の反応がない↓なんとかしようとなんとかしようと頭の中がぐちゃぐちゃになる↓トークに集中出来ず、話すことがぐちゃぐちゃになる↓いくつかミスが出だす↓もうこれ以上ミスしたくない、さっさと終わらせたいとなる↓早口になる↓余計反応がなくなる↓以下ループ実際、メモにこのページでは○分くらいといくつか重要なところで書いてあるのですが、最初のポイント(3分)の時点で1分アヘッドしてました。パニック状態でした。最終的には7,8分アヘッドしてました。終わった時オフィスアワーがなかったらトイレとかにかけこんで泣いてたと思います。50分枠をもらったのに、40分で終わってしまった。。。登壇終わった直後、よし！登壇引退だ！っていうくらいのショボい感触だったので、慰めてくれるAndroid/Kotlinコミュニティーの温かさに泣けた。DroidKaigiの良かったセッションのトークで勉強させてもらう。— shiraji (@shiraj_i) 2018年2月8日別途内容に関しては記述します。でも、オフィスアワーで質問を頂けて、こんな無様な登壇をしたけど、しっかり聴いてくれていて、本当に感謝でした。ありがとうございました。ちなみにオフィスアワーで隣の席に日高さんがいたので、同じ時間帯ではなした記念でチェキしてもらいました。 初日午後結構登壇が心に来ていて、疲れもあり、ほぼほぼ覚えてないです。録画を見直すつもりです。2/8 16:50~最後のセッションの頃には落ち着いていましたので、フィードバックコメントします。マルチモジュールのすヽめkgmyshin さんのセッション。droidconSFでマルチモジュール今後来るな！と感じていて、日本語でも聴いてみたく聴講しました。内容としてはマルチモジュールのメリット・デメリット、実現方法、実際のアプリでの適応方法などなど非常に充実していました。モジュールの切り方のオススメが機能ごとに切るで、自分もマルチモジュールやるならこれだと思っていたので、すごく参考になりました。Kotlinのinternalの使い方とか最高じゃないですかこれ！という印象でした。あと、セッションにはなかったですが、Javaのプロジェクトを部分的にKotlinにしていくというのにも活用できるのでは？とも思いました。マルチモジュール日本でも流行るなこれ！という感じでした。本当に良かったです。パーティ風船がつけられる情報があったので、なんか恥ずかしいし、逃げられないかなーと思ったけど、会場に入るところで一瞬で捕捉され、つけられてしまいました。スタッフさんすごい。でもこれのおかげで色んな人に声かけられたので、天邪鬼なこと考えないほうが良いですね。去年目の前で寿司が打ち切られたこともあり、最初から寿司狙いにいきました。うまかったです。色んな人と話してから、2皿目狙ったのですが、さすがに考えが甘かったです。さっさと行けば良かったです。サビ抜き注文にも対応してくれていたみたいなので、ワサビそこまで得意ではなかったしワガママ言えば良かったです。次回はそうします。パーティでは、セッションを聴いてくれた人たちや自分のことを知っている人たちといっぱい話せました。Kontributeに関して質問がきたのですが、自分の言語能力が低くてうまく説明が出来ず、走ってMacをかばんから引っ張りだして説明させてもらいました。楽しかったー。他にも去年のDroidKaigiからお会いしていなかった人たちにも会えたし、本当に楽しかったです。二日目のセッションスケジュールをガチガチに決めていなかったので、ふらふらーと気になるセッションに参加していきました。2/9 10:30~Moving Forward with JUnit 5PermissionsDispatcherでコミッターとして仲良くさせてもらっているmarcelschnelleさんのトーク。始まる前に挨拶をさせてもらいました。PermissionsDispatcher committers reunited! @marcelschnelle @hotchemi You missed this!!!#droidkaigi #droidkaigi_room5 pic.twitter.com/cnickLWnfo— shiraji (@shiraj_i) 2018年2月9日内容はJUnit5のプロジェクト構成からJUnit4との違い、そしてAndroidプロジェクトへの適応(UnitテストとInstrumentテスト)でした。JUnit5はまだまだ後で良いかなーとあんまり詳細を勉強しておらずふわっとした知識しかありませんでした。この発表を聞いてJUnit5のPlatform/Jupiter/Vintageの違いやその相互の関わり方などが明確になりました。一番衝撃だったのがJUnit5はフルスクラッチで書いているそうなのですが、その理由のうちの一つのCoupling。JUnit4のプロパティ名を変更しただけでJUnit4が使い物にならない状況だったらしい。面白すぎる。もっとお話聞きたかったです。30分が一瞬で終わってしまいました。楽しかった。Thanks, Marcel!2/9 11:20~企業ブースにいて、セッション聞いてないです。聴講予定していたセッションがあったのですが、色んな人と話していて、いつの間にか開始時間を結構過ぎていました。参加者と話すの楽しいです。2/9 12:50~アプリを成長させるためのログ取りとログ解析に必要なことcattaka_netさんのセッション。ログって本当に良い思い出が無くて、住友さんが関わっているアプリではどういう対処をしているのか知りたかったため聴講しました。簡単にまとめるとログからユーザ全てのアクションが引っ張れるくらいにはしなさいという内容でした。また、それを成すために全てのアクションなどにもログを出すようにしていました。正直衝撃的でした。何かうまく無駄を減らしているのかな？と実は考えていたのですが、しっかりと丁寧に積み重ねているようで、何をするにもコツコツが重要だよね。と改めて教えてもらいました。2/9 14:00~ここの時間帯も聴きたいセッションが多かったのですが、Twitterで流れてきたAndroid Things codelabがどうしてもやりたくて、参加しました。でも14:50~のGraphQLは絶対聞かないとまずいという認識だったので、途中で抜けるかーという軽い考えで参加しました。が、実際はいつから参加しても良いし、特に座学がある訳でもないし、脇道それなければ、20分くらいで終わる簡単な内容でした。でも、周りにGooglerがいっぱいいるのに、そんな即終わらせてももったいないことしたくないと、脇道に逸れまくって色々質問しまくりました。結構無茶な質問してたのですが、真摯に対応してもらいました。終わった後にあ、これもあった😇数日ぶりにご飯も家族と食べれたし、なにからやろかな。One more task😇 pic.twitter.com/KKPdiST28g— shiraji (@shiraj_i) February 9, 2018これもらいました。Raspberry Pi 3持っていないので、どれ買おうかなーと画策してます。2/9 14:50~すばらしきGraphQLのSEKAIへようこそgfxさんのトーク。GraphQLはあんまり前提知識がなく、どうやって書くのかなー？と疑問でした。聴講している人たちもほぼみんなGraphQLを本番投入している人がいなかったようです。内容としてはGraphQLのしっかりとした説明で、編集エディタとしてGraphiQLの説明があり、そのデモ映像で、おおおお！と思わず声が出ました。GraphiQLスゴい。— shiraji (@shiraj_i) February 9, 2018聴講前はIntellijのプラグインとかでもあるのかなー？と思ってたのですが、まさにこれ！というものだったので良かったです。ちょうど次のタスクでサーバサイドのAPIとか作る予定なので、GraphQLまじでありだな。という印象です。(残念ながら、クライアントサイド担当じゃないので、gfxさんのRejectKaigiでの発表の方利用します)2/9 15:40~gRPCとProtocol Buffersで作る、一味違う通信周りRPCは以前から使っていて、(RESTにしようかー？って話があったのですが、なぜかずっとRPC+JSONだった)gRPCに興味があった。Protocol Bufferは以前から把握していたので、その連携方法などなどを知りたく聴講しました。RESTの向いているケース、RPCの向いているケースなどを実際に使われているサービスなどを踏まえて説明して頂きました。あんまりAPIをフルスクラッチから作る経験がなく、こういう比較で実は検討していなかったので、詳細を知ることが出来てよかったです。結構新しい視点でAPI設計を考えられるようになりました。また、RPC使っているものはアクションを中心に考えられていたので、案外筋が悪いものでもなかったなーと振り返ることが出来ました。Protocol Bufferとの組み合わせの具体的な実装の説明があり、自分がまさに知りたい点の説明があったので、大満足でした。一点しまったなーと思ったのが、GraphQLの話の後だったので、悩むネタが増える〜！（歓喜）という点でした。2/9 16:50~ARrrrg! The Google AR Android Demo Application deciphered.ARCoreは今後関わる分野だなーと思ったので、聴講。この辺りで結構体力が限界で、PCの電池も限界がきていて、後ろの方で聞いていました。これが失敗で、コードの説明を丁寧にしてくれていたのですが、コードが読めない！Room6は縦長だったので、出来たら後ろの人にもスライドが見れるようにしてくれたら良かったなーと。内容はスライドが読めなかったのでなんとも判断できませんでした。また録画で確認したいです。2/9 17:40~コードで見るFlutterアプリの実装 (セッションの説明ではQ社になってましたが、大丈夫なのだろうか？)大ファンのkonifarさんのセッション。Flutterのことはkonifarさんのつぶやきで知っていて、以前からちょこっと触ってました。iOSアプリがリリースされ、実際に触ってみて衝撃を受けたので、聴講しました。自分で結構独自でWidget作ってへー動くねー程度だったので、ここまで手厚いGoogleからのサポートがあるのは激アツでは？という印象を受けました。iOSアプリがあれほどしっかり作れるなら今後日本でKotlin Nativeより流行る可能性ありそうという印象でした。このトークは初心者向けということもあり、Flutterとりあえず触ってみるかーという方はこのスライド読むだけでとりあえず形には出来そうでした。あと、トークの最初のほうでがっつり聞いている人の心を掴んでいて、スピーカーとしても勉強させてもらいました。2/9 18:30~Gradleプラグインを作って開発効率を改善しようGradleプラグインはOSSでのコントリビュートや実際にリリースまでしたことあったんですが、正直本当にこの開発手法で良いのか？とはっきり知りたかったので、DeployGateでGradleプラグインの開発知見が多いだろうtnjさんに色々聞いてみようと聴講しました。特に知りたかったのがdebugger周りでした。最初いきなり、リリースしたのになんでいるの？と言われてしまい、あー間違ったかー？って思いました。実際、最初のほうGradleプラグインの初歩的な作り方で、あーあーって感じでした。それで急にtnjさんがこれ\"\"要らないですね。PRお待ちしております！とおっしゃって、うし！せっかくだしやるかー！ってtnjさんのgithubのアカウント見つけて、repository一覧からたぶんこれだなーっていうrepositoryを見つけ、実際にコード検索してみたら、該当のコードがあったので、fork->clone->branch作成->commit->PR！とやりました。(しっかりと聴いてました)投げた。https://t.co/6CykH8mssq #droidkaigi_room3— shiraji (@shiraj_i) February 9, 2018ちなみに前回のDroidKaigiに引き続き、Kaigi中にPR投げる実績をこれにより解除しました。で、PR投げるくらいのタイミングでデバッグとかどうしているの？という話になって、自分がどうしても知りたかったdebuggerの使い方を説明がありました。デバッガの準備2/3のスライドのRemoteのConfigurationを毎回していないのが原因だったようです。この情報もらえただけでこのトーク聞けたことに大満足です。今までログ吐いて確認ログ吐いて確認と非常に大変だったのでGradleプラグイン開発極力避けてきましたが、おかげで捗りそうです。また、そこからはGradle Plugin Portal公開までのステップを一歩一歩説明されており、最近リリースするまでやれてなかったので、最新の動向が知ることが出来ました。その他セッションと関係ないけど、印象的なイベントリストアップしておきます。運営の良さ去年これ呟いていたんですがdroidkaigiの電源タップ、間引くのは全然いいのだけど、次回からでいいので、間引くなら一個づつ間を開けてくれたらすごい助かる。真ん中だけ空いてると入れられない。（なので隣の人に一回抜いてもらわないといけない）— shiraji (@shiraj_i) March 10, 2017しっかり対応されていました。しかも前回ガムテープだったのが、今回はプラスチックカバーになっており、電源タップにも優しい。あとKotlinConfで良かった点をつぶやいていました。KotlinConfの登壇者として良かった点書いてなかったけど以下の2点は本当に良かった。* マイクが耳掛け式* スクリーンに何が写っているのかを登壇者の前のディスプレイで確認できたこれらのおかげで前向いて話せたし、ジェスチャーもしやすかった。DroidKaigiでもぜひ🙏— shiraji (@shiraj_i) November 7, 2017やってくれたらなーと思ってましたが、全部揃ってました。ただ、自分が登壇したRoom6ではディスプレイがうまく表示されないという問題がありました。Keynoteにはプレゼンテーションモードにすると動画が同期されず、スクリーンで何が起こっているのかわからない問題があります。これの対応のため、ディスプレイが欲しかったので、なんとかなりませんか？と無茶なお願いをしたら、別の器具を特別につけてもらいました。本当に神運営でした。ありがとうございました。(対応してくれた人の名前を聞くの忘れていました。。。)登壇内容をまとめてもらった初めて一枚にまとめてもらいました。嬉しかった。\"How to Kontribute\" by @shiraj_i at #droidkaigi 🙌 pic.twitter.com/Y0mJ2Sycls— Lara Martín (@lariki) February 8, 2018How to kontribute by @shiraj_i at #droidkaigi #sketchnotes #Kotlin #AndroidDev pic.twitter.com/7sbNiicNMz— Miquel Beltran (@Miqubel) February 8, 2018でもこれを見て、Intentionの部分の説明詳細すぎて響かなかったのが良くわかりました。Androidに詳しい人達なので、Android StudioのIntention作り方とかにすれば・・・(あれ？それCfP通らなかったヤツ・・・)Roman Guyさんと話せた憧れな人と話せた。めっちゃ震えた声でRomain Guyさんに話しかけた！緊張したー！Mat2のコントリビュートについて覚えていてくれた！嬉しい！kotlin-mathの今後について少し聞いてみた。https://t.co/d0wGO0hWPQ— shiraji (@shiraj_i) February 9, 2018プレパーティーで話しかけようと思ったんだけど、すごい囲まれていて、無理で、アフターパーティーは見つけられず、諦めかけていました。でもDroidKaigi終わり際にソファーでのんびりされているところを見つけたので、他の人との話に割りいり、強引に話しかけさせてもらいました。KotlinConfで登壇したこと、Kotlinのデータサイエンスへの展望、kotlin-mathの将来について話しました。せっかくだから今の話、issue上げてよ。と言われたので、時間作ってあげてみたいです。Kontributorsと会えた色んなKontributorsと会えました。すごい前から会ってみたいなーと思っていたtommykwさんにもようやく会えました。(KotlinConfにも参加してたのにお会い出来なかった。。。)自分のトークに関しても直接色々感想を教えてくれました。嬉しかった。KontributorsでCode Labとかやります？という話が出来ました。15人くらい集めて一気にみんなでKontributeとかしたい。Kotlin Developers Conference Japanでチャンスあればぜひ！","link":"https://shiraji.hatenablog.com/entry/2018/02/12/111637","isoDate":"2018-02-12T02:16:37.000Z","dateMiliSeconds":1518401797000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Twitterエゴサーチで見る2017年まとめ","contentSnippet":"今年本当に自分のエンジニア生活が一変した年だったので、書き留めておく。が、普通に文字だけで書いたら、ただの長いエモいものになってしまった。そこでエゴサーチ縛りにしてみました。まず2017年まとめの前に2016年のことを書かないと始まらないので、2016年のことから。2016/11/21自分の生活はこのツイートで良くも悪くも変わった。.@shiraj_i 予算がないとかで、申請が却下されそう。自腹か。8000円の参加費と3/9, 10休んでもいいという会社ありましたら、転職しますので、ご連絡下さい。— shiraji (@shiraj_i) November 21, 2016前職の人たちは本当に良い人たちばかりで、特に批判などせずに、暖かい目で見守ってくれた。一番怖かったのが前職の上層部に知られ、首にされ、家族に見放される場合だった。そこで、嫁ちゃん意を決して伝えてみた。自分「〜〜こういうことがありまして」嫁ちゃん「あ！ガチャ！セフィロス(FFイベント)だ！」自分「転職するつもりです。」嫁ちゃん「がーん。出なかった・・・。チッ！エースってなんだよ。」自分「聞いてた？」嫁ちゃん「ショックや・・・てか話終わったなら洗濯物干してよ早く。」自分(しぶしぶ洗濯物干しに向かう)嫁ちゃん「てか首になっても、私がフルで残業して、(自分が)バイトでもしてくれたら生活困らんでしょ？」嫁ちゃん「そんなことよりセフィロス出なかったほうがショックだわ。エースってなによー。」男気溢れる嫁ちゃんでした。抱いて！1, 2月さて、こんな感じで、2017年を迎えました。初旬で転職活動がようやく完了しました。慎重になっていたと言うより、スケジュール調整で手間取ってしまった方が大きかったです。こんな自分に声をかけてくれる会社には全て会わなければ！と思い、20社会い、そこから面接に入っていたので。でも本当にどの会社も今からでも行けるほど良い会社ばかりでした。(Twitterとタイトルにあるにも関わらずですが、相手がいるため、この辺りツイートは一切しておりません)background/foregroundチェック用のライブラリを出していた。これAAC使ったほうが良いのかな？deprecatedにすべきかも？Released Android library called butai. Now the application knows if it is background/foreground https://t.co/tvjAAjBttY— shiraji (@shiraj_i) 2017年1月28日他にもDroidKaigiアプリにコントリビュートいくつかキメました。今年もコントリビュート頑張ります！（後でみんながコントリビュートしやすいようにバグとかtypoとか入れておきます！）— shiraji (@shiraj_i) February 6, 20173月DroidKaigiそんなこんなで、\"自腹\"で初参加でした。自分の大好きなバーテンダーさんに今日本当に幸せな顔していますよと言われた。— shiraji (@shiraj_i) March 10, 2017本当にようやく参加出来たし、勉強いっぱい出来て、しかもすごいエンジニアの人たちといっぱい関われたので、幸せでした。フラグも立てた。来年チャンスあったらスピーチ側に回りたい！という思いだけはあるので、次のCfP期限までに何か武器拾いたい。今持ってる武器はニッチ過ぎて、誰もいない部屋で一人で泣きながらプレゼンしてるのが目に見える。— shiraji (@shiraj_i) March 10, 2017DroidKaigiの幸せに浸っていたけど、KotlinConfの存在に気づく。おおおう！？https://t.co/HiFC5sGv17— shiraji (@shiraj_i) March 29, 2017この日のうちに、Speakerを目指し、動き出す。4月人生初のCfP提出。(How to KontributeのCfP）Submitted KotlinConf CfP! This is my very first CfP!!!— shiraji (@shiraj_i) April 7, 2017そういえば、前職の若手達からPRがまだ来てない。OSS頑張っているだろうか？(そもそも彼らがコントリする価値があるRepoを自分が持っていないけど晒しておきます)若手のホープ達がOSSやります！PR投げるので見て下さい！とか宣言してきた。OSS沼に引きずり込むことに成功した模様。— shiraji (@shiraj_i) April 13, 20175月現職に初出社。初日は神戸本社。出社ァァァ！ pic.twitter.com/nUbhtH4UAe— shiraji (@shiraj_i) May 1, 2017一ヶ月でWeb業界との違いに色々心がざわついた。いろんな仕組みをいろんな会社が作っていて、諸々やばそう。しかも規模でかそう。くらいのざっくりしか一ヶ月で把握できない状況だった。正直焦りはあったけど、まずは足元しっかり固める為にとにかくシステムに関わる人と話した。初めて執筆に関わった。出国前にv1.0.0リリースきた！初めて本？に関わりました。スピード感がよかったです。本書くのって大変だなーという感想でした。楽しかったー。https://t.co/SQdpvUxX1a— shiraji (@shiraj_i) 2017年5月29日リリースされた日にそのままボストンへ。一ヶ月ボストンで修行してきます！PC持ち込み禁止になる前にはなんとしても帰ってきたいです。。。ではまたー！（どうせ向こうでもOSSやってるだけであまり変わらんだろうけど） pic.twitter.com/3HIVG5sH3t— shiraji (@shiraj_i) 2017年5月29日6月ボストンで武者修行。海外でフルタイムで働けるかどうかちょっと心配だったが、いい人が良く、仲良くさせてもらった。スクラムをしっかりやったのは実は初めてだった。特に苦なく、進められた。肉！🍖🍗 pic.twitter.com/4tDGwO8w7o— shiraji (@shiraj_i) 2017年6月9日途中KotlinConfのCfPが通った。KotlinConfを無事に終わらせるが今年の最重要事項に設定した。手が震えてクリック出来ない。 pic.twitter.com/G3Qv7iNndK— shiraji (@shiraj_i) 2017年6月13日ボストン空港で結婚指輪を盗まれ、テンション最低となり、帰国ツイートせずに帰国。そのため何人かに、日本にいるんです？と混乱させてしまった。7月5月入社して、社内のことがほったらかしだったので、人事周りやら、いろんな案件に顔を出しつつ、タスクこなす日々。社外向けの発信をしなきゃね！ということで、調査開始。企業の（テック的な）ブログ作る場合、どのサービス使うのが良いのでしょう？ブログを自前で用意するリソースがないです。— shiraji (@shiraj_i) 2017年7月5日最終的にMediumに落ち着く。8月PermissionsDispatcherのコアなメンテナ達と初めての会食。これは本当に楽しかった。もっと英語うまくなりたい。permissions dispatcher maintener united!!! @hotchemi @marcelschnelle pic.twitter.com/18LiMeTkp3— shiraji (@shiraj_i) 2017年8月25日9月7月初旬から始めて実を結ぶ。I just published “Start ASICS Digital Publication” https://t.co/pT7iYWLQTo— shiraji (@shiraj_i) 2017年9月20日でもここからブログより優先度あげて、最近リリースしたアプリに集中することにしたので、ブログの発信が途絶えた。ツイートしていなかったけど、Android Tokyo Meetupに参加。日本で初めて英語の登壇をした。10月CA.kt #3で登壇した。CA.kt来た！（飛行機乗ってきたので、汗臭い）偉い人に無線の設定してもらってる。#ca_kt pic.twitter.com/JLphX8nblP— shiraji (@shiraj_i) 2017年10月19日この登壇は忘れたくても忘れられない。いい勉強させてもらった。人生初、献本して頂いた。(まだ感想書いてない・・・すいません。)生まれて初めて献本された！嬉しい！！！ありがとうございます！ @satorufujiwara @ngsw_taro @boohbah @yy_yank pic.twitter.com/2GeAcT5zNB— shiraji (@shiraj_i) 2017年10月23日11月11/2 KotlinConfに登壇した。I will be there as a Speaker! So excited!!!#KotlinConf pic.twitter.com/kQ6GEP8Zil— shiraji (@shiraj_i) 2017年11月2日11/4 KotlinConfの登壇ネタをブログに書いたら、初めてホットエントリーに入った。興奮して寝れないので、がーっと書いてみた。雑文過ぎるので、後で修正か消すかも？ / “LT1回しかしたことなかったエンジニアがKotlinConf 2017に登壇したお話 - shiraji’s diary” https://t.co/qeVLs6cHgY— shiraji (@shiraj_i) 2017年11月4日11/5 DroidKaigiのCfPが通過How to Kontribute、また採択してもらえたー！さらにもう一回チャンスある！時間かけて準備してたから嬉しい！！！Android Studioプラグイン周りはやはり需要なかったか。残念。英語でしかプレゼンしないキャラにでもなっとくかこれ。— shiraji (@shiraj_i) 2017年11月5日この数日、神すぎでは？念願のdex.fmにも出演した。今まで何回か名前だけ出してもらっていたので、ようやく。でも収録聞いたら、笑ってるだけだった。。。すまんな。調整中。緊張する。 pic.twitter.com/4RooDCnNUS— shiraji (@shiraj_i) 2017年11月17日12月KotlinConfのフィードバックもらった。Does this mean my talk's audience gave me 5th place in entire the conference? Am I dreaming? How nice were they!!! #kotlinconf17 pic.twitter.com/LeyOIg1TRs— shiraji (@shiraj_i) 2017年12月7日9月の社外向けブログが出たくらいから本格的にアプリ開発着手。入社後初の新規アプリリリース。新規でアプリ作りに関わったの数年ぶりかも？楽しかった。【宣伝】エンジニア: 研究員デザイナー: アプリデザイン初経験PM: PM初経験見届け人: 自分このチームを9月に作り、アプリ一つ形になりました！みんな開発経験ない中、もがき苦しみながらやってくれました。☆1は勘弁して欲しいですが、ぜひ使ってみて下さい！https://t.co/v1hpliXBU4— shiraji (@shiraj_i) 2017年12月14日2017年反省点登壇にこだわり続けた一年だった。とにかく登壇を意識していた。非常に良い結果になったし、このまま続けていけるなら続けていきたい。しかし、コードのアウトプットが激減した。優先度を下げたのも事実だが、もうちょっと良いやり方がある気がする。2018年の登壇予定1/18 どこでもKotlin #5これに登壇します！Android x Kotlin+登壇者が豪華ということもあり、人気いっぱいあるイベントですが、需要無視してASプラグインネタやります！途中でブーイングを受けても舞台から降りませんので！どこでもKotlin #5 〜Android特集〜 https://t.co/SxmzcsWVDA #m3kt— shiraji (@shiraj_i) December 24, 20171/26 DroidKaigi Prelude@__gfx__ さんと @muumuumuumuu さんがDroidKaigiのセッションの事前説明をしてくれるらしいので、舞台上で聴いてくる！https://t.co/OHs7Vmgtwm— shiraji (@shiraj_i) 2017年12月5日2/8 DroidKaigi2018年の目標一回登壇を経験したので、流れも掴めたし、登壇の方の負荷も減ると思うので、コードのアウトプットと両立させたい。(ただ、Kontribute以外の登壇ネタが見当たらないので、自然にコードのアウトプットが増える気がする。)最後にそれにしてもこの一年、本当に色々ありました。。。勉強会に何回か出ることも出来て、初めてお会い出来た人がいっぱいいました。来年も引き続きよろしくお願いいたします。","link":"https://shiraji.hatenablog.com/entry/2017/12/25/014158","isoDate":"2017-12-24T16:41:58.000Z","dateMiliSeconds":1514133718000,"authorName":"しらじ","authorId":"shiraji"},{"title":"LT1回しかしたことなかったエンジニアがKotlinConf 2017に登壇したお話","contentSnippet":"KotlinConfに登壇しました。海外カンファレンスでの登壇はなかなか出来ないので良い資料になればと時系列で出来事全て書き残しておきます。（そしてまた海外カンファレンスで登壇出来る日が来て、このエントリーを自分が見直す日がくることを祈ります）だいぶ長いし、エモいし、技術者としてのコツとかはないので、こういうのが嫌いな方は戻るボタンを押して下さい。ほぼ推敲もしていない雑文です。こんなポエムで批判とかされると嫌なので、批判する可能性がある方はぜひ時間を浪費せず、戻るボタンをクリックして下さい。またKotlinConfの内容は一切ありません。別途記述します。KotlinConfが開催されることが発表開催のアナウンスされたのが3/15あたりで、3/28に何かKotlinに関することを検索していたら偶然サイトを見つけて、KotlinConfの存在に気づきました。おおおう！？https://t.co/HiFC5sGv17— しらじ (@shiraj_i) 2017年3月29日そのすぐ後、登壇者はタダ！に気づきました。トーク採用されたら旅費・宿泊費・参加費出すだと・・・！？https://t.co/33Owbd9OlM— しらじ (@shiraj_i) 2017年3月29日当時まだ転職前で、トラウマになりつつあるカンファレンス参加。。。転職直後でしかも海外カンファレンスにいきなり行かせてもらえるか不明だったのでこれは「CfP通っちゃったんで行きますね！タダだし。」とするしかないと自分の中でCfP出すことにしました。(でも正直に言うとrefundされるか不明でしたが、どうしても行きたかったので、チケットはその日に購入していました。NGと言われたら会社休んで行ってしまい、また「海外カンファレンス自腹。転職したい」と呟けば誰か拾ってくれるんじゃね？と楽観的でした。そんなフラフラして良い業界でないことは承知しています。)CfP3/28のうちにCfPが通りやすそうな事柄を自分なりにリストアップしました。Kotlinの機能に関してはJetBrainsや日本のKotlin勢には勝てるわけないので、そこに注力するトークは厳禁JetBrainsが話せないことにする自信があることにする自分が話すことがベストだと思うような内容にするこれに当たる項目として以下の2つが思いつきました。KotlinコントリビューターネタIntellij/Android StudioのプラグインKotlinでの作成ネタそれから4/1にまでに特に自信があったHow to KontributeのCfPを作るために以下のことをしました。有名海外カンファレンスのセッションの説明を読み漁る(Google IO、WWDC、RubyKaigi、DroidKaigiなどなど)How to Kontribute (for Japanese) - Shiraji's Blogのサブタイトルごとにセクション分けブログの英訳有名カンファレンスの説明を参考に楽しそうな雰囲気の説明を記述主催者にしか見えないメモ欄にはそれぞれのセクションで何を話すのか2,3文で概要を記述その後、数日放置して、4/7にもう一度読み直し、これで落ちたらどうしようもないやろ？という気持ちになったので祈りながら申請しました。Submitted KotlinConf CfP! This is my very first CfP!!!— しらじ (@shiraj_i) 2017年4月7日人生初のCfPでした。その後、4/30までに追加で3つほどCfP出しましたが、どれも落ちました。というか今思えばあのレベルのカンファレンスで2つとか通るわけない。。。CfP通過までその後5月に転職し、会社がKotlinConf費用全部出してやるよ！by上司という言質を取りました。(※広告※ 弊社太っ腹なので、興味ある方、弊社に来てください！英語出来ると尚可)そこでKotlinConf何が聞けるかなーと楽しみになりました。その後、Google IOでKotlinがGoogleにもサポートされることが発表され、KotlinConfの注目度がものすごく上がり、これはますます楽しみだなとなりました。Google IOを受け、Kotlin助走本を出しません？というありがたいお誘いを頂き、5/29にそれがリリースされ、それを見てからボストンの出張に行きました。ボストンではひたすらAndroid開発をしていました。新人入社時に社員が話しかけやすくためにデスクにスナックが置かれる（ついでにボロボロなお土産も追加した） pic.twitter.com/RoxvMIi7eu— しらじ (@shiraj_i) 2017年5月30日肉！🍖🍗 pic.twitter.com/4tDGwO8w7o— しらじ (@shiraj_i) 2017年6月9日It's tough to work in Boston. It's tough.ボストンで働くの大変やで！ pic.twitter.com/RVIyJiAXNE— しらじ (@shiraj_i) 2017年6月12日ロブスターロール。うんめー！ pic.twitter.com/Pa56vITQzD— しらじ (@shiraj_i) 2017年6月18日6/13朝起きてなぜか普段しないメールを確認したら[ACTION REQ'D] Congratulations!...というタイトルのメールがあり、「スパムか。Gmailにしては珍しいな。しっかりしろよ」ととりあえず開いてみたら、以下のメールがきていました。手が震えてクリック出来ない。 pic.twitter.com/G3Qv7iNndK— しらじ (@shiraj_i) 2017年6月13日本当にこれクリックする前で、震えてクリック数回失敗しました。ボストンにいるエンジニアたちに話したら、まじかよすげー！となって嬉しかったです。その数日後、日本人(最終的にはアジア人)の誰も登壇しないことが判明して、辞退する方法ってないの？とおえっとえずくことが何回かありました。登壇準備それから数日後よく考えたらこのトピックJetBrainsが広告にしたいだけで需要ないだろうし、会場に行ったら誰もいなくて、何もせずにアメリカで旅行出来るんじゃね？という発想に切り替わったので、とりあえず準備することにしました。（ここは反省点。需要がないという考えでいくと後で響く。CfP勝ち抜いたという自信を持つ。落ちた方に失礼。）その前にまず、自分の発表経歴を書いておくと2017/06時点での登壇回数は「1回」です。その1回もIntellij plugin勉強会@サムライズムさんでCustom Inspection - SSSSLIDEの話をさらっとLT5分で話した程度です。実際は3分半くらいで終わった。今スライド見てみたけど、コンテンツがない発表でした。。。そのため、KotlinConfまでにどこかで登壇経験しないとたぶん本番トーク中に死ぬということが明らかでした。そこで、助走本などで関わりがあったCAの@satorufujiwaraさんにCA.kt #3 - connpassに出させて欲しいと依頼しました。他にもTokyo Android Meetup (東京都, 日本) | Meetupで英語のスピーチを外国人向けにしていることを把握していたので、PermissionsDispatcherでのつながりでお世話になっている、@hotchemiさんとイベントの管理者の@niko_yuwonoさんに連絡をして、登壇させてもらうようにしました。改めて、枠を作って頂き、本当にありがとうございました！この時点でTokyo Android Meetupが9月終わりに、CA.ktが10月中旬になるだろうということになったのでそこから線を引きました。7月: 話す内容確定。スライド完成8月: 練習9月: 練習9月末: Android Tokyo Meetup9月末~10月中旬: Android Tokyo Meetupの反省点修正+練習10月中旬: CA.kt10月中旬~11/2: ひたすら練習普段登壇されている人からしたら非常に余裕のあるスケジュールですが、長いトーク、初の登壇でしかも海外カンファレンスで英語でと考えたら自分にとっては異様に短いくらいでした。ただ、話す内容はブログでもう書いてあるから、極力早めにすすめて練習に時間を割こうという考えでした。7月中旬くらいに予定より早めに話す内容が確定。ほぼほぼスライドも頭の中では確定しました。ここまでは良かったのですが、問題が発生しました。www.nintendo.co.jpSplatoon2がTLに流れまくります。一時Twitter見ないようにするか？と思ったのですが、情報収集に必要なため、無理でした。嫁ちゃんに呆れられ、買って良いよと言われたので、初めてSplatoonを買いました。めちゃくちゃはまりました。そして、準備が滞ります。完全に社会人失格です。8月中旬に盆休みで家を離れた際にSwitchを家においていき、Splatoon断ちをし、8月後半でなんとかスライドが形になりました。仕事ではあんまり遅延させたことがなかったので、挽回方法がわかりませんでした。でも引き続きやばいなーと思いつつ、Splatoonとプレゼンの練習しました。9/20事件Android Tokyo Meetupを1週間後に控え、Kotlinプラグインの中の人がこんなツイートをします。huge @kotlin milestone today: we’ve switched to Gradle Kotlin DSL for our build!— Dmitry Jemerov (@intelliyole) 2017年9月20日実は、登壇が決まったタイミングからKotlinへのコントリビュートやコミットの確認などを怠っていました。プレゼンするんだから！とSplatoonの時間をそちらに割けたはずですが、言い訳していました。たぶんそこまでプレゼンに影響ないだろ？と思いつつ、コミットを調べていきました。事態のヤバさを正確に把握したのが9/22あかんぞこれ。調べれば調べるほど、自分のスライドなくなってくぞ。半分くらい作り直しだぞこれ。来週Tokyo Android Meetupあるってのに。— しらじ (@shiraj_i) 2017年9月22日その間、実は世界中のkotlinコントリビューター誰一人ビルド出来ない異様な状況になっていて、中の人が「古いバージョンでも出来るから今のところ古いバージョンでやってくれていいよ？」とさすが欧米！と思うくらいな発言をしてきました。そんなんKotlinConfの時にはもう落ち着いているだろうし、練習の意味がなくなるやん！！！と苛立ちました。なんとかコミットを全て確認し、ドキュメントが間違っていたので、修正PRを投げ、設定が一つ吹っ飛んでいたので、そこも修正PR投げ、プレゼン資料を修正し終わったのがAndroid Tokyo Meetupの前日でした。明日40分くらいの英語でのプレゼンをするわけですが、ようやくKotlinのテストコードをエラーなしで走らせることに成功しました！残りはテストコード生成するところだけです！他のコントリビューター達も色々試行錯誤してるようです。プレゼンの練習？🤔— しらじ (@shiraj_i) 2017年9月26日発表資料を変えたくないという理由で本番のコードを変えるという暴挙に出ることにした。https://t.co/4SdN6mqKkb— しらじ (@shiraj_i) 2017年9月26日すごい軽い感じでツイートしていますが、この一週間はエンジニアとしてやれること全てを出し尽くした感じです。またこれ以降build.gradle.ktsの監視とKotlinConfまでに今後こういうことが起きないように祈りました。無宗教ですが。Android Tokyo Meetup付け焼き刃でしたが、なんとか一通り話せるまでになったので、登壇しました。(会社で修正後のスライドを使って練習させてもらった。上司にはリソースの振り方など完全に任してもらっていた。ありがたい。)同僚ではない人前で話すのがLT以来でしたが、案外うまく出来ました。フィードバックももらい、修正点がいくつか上がりましたが、これ以上ないほど上出来な感じで、「オレやれば出来る子じゃん？」と調子に乗り、Splatoonに戻りました。CA.kt #3修正をいくつかし、動画を16:9用に撮り直し、準備万端で登壇しました。（余談ですが、英語で画面遷移などを全て説明してもわかりにくいし、飽きる。興味を持ってもらうために、デモか動画かで悩み、デモをやってみたら、ビルドで10分かかりPCがフリーズしたので、デモを諦めて、動画を多用することにしています。デモをKotlinConfでもちょくちょく見かけましたが、本当にすごいです。。。）しかし、Tokyo Android Meetupは発表者との距離が近く、会話形式にほぼなっていたため気づきませんでしたが、一人で舞台の上で話すことの孤独さにここで初めて気づきました。何が驚きかと言うと、思った以上に反応が返ってこないんです。(ただしTwitter上では盛り上がってくれていました。)反応がないため、通じているのかどうなのかわからなくなり、パニック状態に陥り、何を話せばいいのか思い出せず、スライドのメモを読み続けるしかないと判断し、とにかく早くこの舞台から降りるために早口でひたすらスライドのメモを読み続けました。しかもいくつかメモにかかれていないことがスライドに書いてあったりで、すっ飛ばした内容があったりともうそれは酷い内容でした。録画されてなくてよかった。終わった後、こんなくそな30分を100人弱の方に見せてしまった。本当に申し訳ないという気持ちになりました。なので、CA.ktを観た方は頭を打って当時の記憶を消して頂き、KotlinConfの動画も観て下さい。CA.kt #3にshirajiは登壇しなかったことに。悪い点ばかりではなく、良い点もありました。動画があると、しゃべりがダメでもなんとか持つメモさえあれば、真っ白になっても挽回可能日本人技術者はTwitter好き。しかも結構しっかり聴いてくれているし、反応がTwitter上ではしてくれる。CA.kt #3から当日までまず何がいけないのかを整理しました。反応がない場合、パニックになるメモが不完全練習時間が足らなすぎここで、一つ明らかになりました。Splatoonです。Splatoon断ちを決めました。そして、まずはメモとスライドをリンクさせました。反応がない場合の件はそもそもTwitterみんな観てるんだから反応なくて当たり前だわ。という結論に至ったので、日本人相手ならそういうもんだということにしました。今後も日本人向けの登壇はそういうものだと割り切ることにしたほうが良さ気です。また、外国人相手の場合、どうしたら反応をもらえるのかを考えたところ熱中させる真剣さ、誠意を見せる好奇心をくすぐるKISS(Keep it simple stupid)巻き込むくらいのことをやれば反応が良かっただろうと考え（野球の川崎選手のMLBでの対応を参考にした）一文が長い話を短文にする最初に質問をして、反応が来る前に、ah?と言って強制的に巻き込む当たりに修正しました。(ah?のほうは当日他の点ですでに巻き込めていたため、当日使わなかった。)前日朝の10時にSFに到着し、白山さんとデートをしました。その後、あんまり公に言って良いのかわからないのですが、スピーカーディナーがありました。船の上で。Android開発者で有名な人を挙げて下さいと言ったらあの神思い出しますよね？彼ももちろん参加していましたし、今まで雲の上の存在だった人が目の前にいて普通に雑談していました。その中で自分は無名だし、英語のコミュニケーション下手だし、そもそも何を話せば良いのかわからず、ポツンとしてしまいました。(JetBrainsの人が声をかけてくれたりして、なんとか楽しめました。)そのまま何も発生せず、歩いてホテルまでみんなで帰ったのですが、そういえば元々このトークに需要なんてないし、コミュニケーション力ないし、なんで自分こんな調子こいてこんなところにおるの？アホなの？と泣きそうになりながら帰りました。ところが、ホテルに入る直前で、急に @queencodemonkey さんに「あなたがいそがいさん？」と呼び止められ、「How to Kontribute聴きたかったのだけど、私の時間がその後(正確にはスケジュール変更が直前にあり、同じ時間になった)で練習しなきゃいけないから聞けないんだよ。残念。絶対録画観るね！」と言われ、そこで初めて日本人以外の人に話聞きたいと言われたことに気づいて、おっさんなのにガチ泣きする寸前になり、お礼を言って、泣く前に部屋に戻りました。（日本人と記述していますが、日本にいる開発者のことを総称しています。簡単に言うと自分のことを知っている人＝日本人として定義しています。誤解がありましたら、申し訳ありません。）そして、日本の知っている人が来てくれると言っているんだし、CA.ktのリベンジしなきゃいけないし、そもそも選んだJetBrainsがいけないわけで何があっても俺のせーじゃないし、もうどうにでもなれや。という感じになりました。当日朝起きて、まだ上の状態でよっしゃーーーー！とやる気になり、一回練習して、会場に向かいました。会場では午前中のセッションを聴いて、レベルの高いセッションを聴いてしまい、アカン！とまた気持ちが沈みました。そこで、午後からの聴きたかったセッションを捨て、練習し直すことにしました。自分の発表会場の近くで一通り練習し、改めてレベルの違いに気づいてしまって、逆にやる前からほぼパニック状態に。もう終わったわ。と思っていたら、偶然JetBrainsのエバンジェリストのHadiさんがゆで卵食い始めたところを見つけて、ここしかないと、話しかけました。自分「緊張しまくっているんだけど、どうすれば？」Hadiさん「プレゼン失敗したとしたら、何を失うの？」自分「吐く？」Hadiさん「それはあかんw」自分「まぁ吐いても特に自分には問題ないかも。何も失わない？」Hadiさん「やろ？」(ちなみに英語なのでこんなアホな会話ではないですが、Hadiさんと話すといつも自分はこんな感じのラフな会話に脳内変換しています。)気持ちが楽になりました。吹っ切れて、写真撮ってもらいました。@hhariri give me smile back. I was too nervous to presentation. pic.twitter.com/M5GLJ5fU3n— しらじ (@shiraj_i) 2017年11月2日その後、嫁ちゃん+息子くんからの激励もありました。息子くんと嫁ちゃんから頑張って！という動画送られてきた！やるしかない！やるぞー！— しらじ (@shiraj_i) 2017年11月2日体が本当に楽になりました。トーク一つ前のトークが終わり、舞台に上がり、プレゼンが写ることを確認、マイクを体につけてもらい、時間まで待ちます。ひたすら待っていると緊張するので、ジャンプしたり、とにかく体を動かしていました。そのあたりで、日本人エンジニアが前のほうの席を陣取ってくれて、写真撮ってもらったりしました。これが本当に気持ちよくて、なんでKotlin界隈はこんな良い人たちばかりなんだ。最高だわ。と思いました。この時点で海外の方もちらほら会場に入ってきてくれて、え？まさか自分のトーク需要あったの？となりました。最終的に始まるまでには後ろ側の席も埋まってしまって、もう有頂天でした。そこで、「日本語英語だからな！嫌なら別の部屋いけよ！」とマイク入ってないのに大声で叫び、聴講者から「そんなん気にせんわーぼけー」という反応があり、あ、この反応あればいけるわと確信しました。(ただし、この発言のせいで下に見られた可能性も捨てきれないため、あまりこの手法はよくなかったかもしれません。)実際、動画が公開されればわかると思いますが、自分が狙っていなかったところでも笑いが起きたり、反応が非常に良かったです。特に嫁ちゃんのことを言ったときの反応が良かったのが正直驚きでしたし、最初のほうで反応がもらえたので、これはまじでイケるぞ！と気分が乗れました。また途中でアドリブで笑わせられるところないかと考えて、実際に即興でやってみたら案外笑ってもらえて、今思えば何しているんだということも実はしていました。でもやっぱり緊張のせいか早口になってしまったようで予定より5分ほど早くトークが終了してしまいました。前日に早口になっちゃうかも？と冗談で入れた、自撮りしようぜ！スライドがあったので、冗談なしで、本当に自撮り+客席撮影登壇中にさせてもらい、時間を稼ぎ、質問タイムを短くしてなんとかしのぎ(ただし、間違った回答をしたため、中の人にその場で修正してもらっていますｗ)、登壇終了となりました。終わった後、本当にトークが良かったから写真撮ってと海外の人に写真撮ってもらったり、質問を個別で対応したりしました。特に難しい質問ではなかったので、なんとかなりました。。。感想登壇後や翌日、カンファレンス会場を歩いていると、急に知らない人に呼び止められ、すごく良かったよ？や握手して！なんて言われました。こんなことされる日がくるなんてなーという感じです。また、Hadiさんに2日目に呼び止められ、「見間違えではなければ、お前のトークまじで投票結果良かったようだよ。見間違えでなければ。」と言われました。たぶん見間違えです。証拠画像なんと自分の記念すべき登壇の写真を撮り忘れるという失態を犯しましたが、わざわざ自分のセッションを聴いてくれた方に写真を頂いたので、ここに挙げさせてもらいます。@yusukeさんから頂いた画像の一枚@shanonimさんから頂いた画像の一枚ngsw_taroさんから頂いた画像の一枚その他良かった点そろそろブックマークされるのが落ち着いただろうし、ひっそりと追記(11/8アメリカ西海岸時間)。発表日のPC2台持ち人が多く、場所が足らないためなのか、控室がなく、電源もありませんでした。そのため、別のセッションを聴く時のメモ用マシンとトーク用マシンを2台持って行きました。これで特に気にせずに別セッションを楽しめました。スライドのスクリーンが発表者側にもあった動画の説明時に振り返って説明する必要があると思って準備していたのですが、前を向いても発表者がスライドのスクリーンが見えるようにディスプレイが置かれていました。本当にこれが助かりました。マイク腰に機器をつけてもらい耳にかけるタイプでした。首を動かしたり、移動してもマイクが音を拾ってくれるので、ジェスチャーがしやすく助かりました。アダプター各種不安だったので、アダプター各種を持って行きました。活躍はしなかったですが、重くもないので、発表時は必ず持って行くのが良いかなと。証拠動画www.youtube.comスライドphotos.google.com","link":"https://shiraji.hatenablog.com/entry/2017/11/04/193914","isoDate":"2017-11-04T10:39:14.000Z","dateMiliSeconds":1509791954000,"authorName":"しらじ","authorId":"shiraji"},{"title":"DroidKaigi2017参加してきた。自腹で","contentSnippet":"やっぱりブログ書くまでがDroidKaigiかなーと思うので、ブログにしてみます。自分は基本的に勉強会参加をしないのですが、半年ぶりくらいに勉強会参加しました。実は今回がDroidKaigi初参加です。以下の自分に関係が深かった項目について感想を記載していこうと思います。DroidKaigiアプリ参加者との関わり運営セッションAfter PartyDroidKaigiアプリPR21、計34コミットしました。数だけ見ると結構したっぽいですが、楽しみたいというスタンスで参加していたので、一人での開発をせずに複数人で開発するスタイルでやったことと雑プログラマーなのでコードレビュー後の修正コミットが多かっただけです。二日目のウェルカムスピーチでPRの数が296個という話が出ていたので、絶対閉会前に300届かせるぞ！と、こにふぁーさんがモデレーターの休憩時間に横に居座って、聞く事が出来なかったResource Refactoringを直接教わりつつ、PR2つ重ねて300PRのキリ番取りました。途中Kotlin導入議論にも参加出来たし、本当に楽しかったので、また次回があれば絶対関わりたいなーと。(Kotlinのコントリビュートしているくせに賛成しないのどうなの？って言われるかなーとビクビクしていました。)参加者との関わり2日続けてボッチ飯を決めましたが、パーカーのおかげで話してもらえましたし、写真まで撮ってもらいました。ただ、もっと多くの関わったことがない人とも話したかったのです。自分のコミュ力が低すぎでした。モノやTwitterに頼ればなんとかなると信じたのが敗因です。次回はもっと目立つモノにしよう。運営イベント期間中運営にこうしてくれたらいいのになー。というつぶやきを2つしました。Firebase chatのセッションデータを入れて欲しい！アプリで見れない。#DroidKaigi— しらじ (@shiraj_i) 2017年3月10日一時間後に対応してもらいました。実際に当日出来たセッションがアプリに反映されているのはすごい。droidkaigiの電源タップ、間引くのは全然いいのだけど、次回からでいいので、間引くなら一個づつ間を開けてくれたらすごい助かる。真ん中だけ空いてると入れられない。（なので隣の人に一回抜いてもらわないといけない）— しらじ (@shiraj_i) 2017年3月10日6分後に公式アカウントから反映させてもらうという返事をもらいました。速攻でいい返事をもらえて、ワガママ言うな！とか言われなかったし、ツイートして良かったです。セッション聴講したセッションは以下です。How to apply DDD to Android Application DevelopmentAndroid Security 最前線！！Androidリアルタイム通信アプリ作成TipsAndroid定期実行処理入門解剖 Kotlin ~バイトコードを読み解く~オフラインファーストなアプリケーション開発React Nativeはクロスプラットフォームモバイルアプリ開発の夢を見るかWhat’s New in RxJava 2.0Android ORMの選び方個人で11個のアプリを公開した結果How to search and improve performanceCan You Read Your Tests? Clean and Useful Android Testing, with JUnit and Spock!2つのアプリ、1つの設計のデザイン指針Smoke and Mirrors in Android UIテスト0から目指すクラッシュフリー率99%今回は以下の観点でセッションを選びました。自分が知らない情報が出てくるどうしても聞きたい項目がある大穴狙いチラ裏でやるべき内容かもですがある発表者さんから「発表者さんらにとってはフィードバックとして欲しい」とのことなので書かせてもらいます。（ただあくまで私の感想ですし、全てのセッションが素晴らしかったので、ネガティブな意見も批判をしているわけではないのでご容赦下さい。）How to apply DDD to Android Application Developmentあんざいさんという方がどういう方なのか聞いたことしかなかったのとDDDに関しては自分も昔から色んな著作を読んで興味があったのでウェルカムセッションの時からルーム3を陣取り聴講しました。内容としてはDDDを全く知らない人に対して最初の一歩になるような内容でこれを聴いたらDDDやってみようか！と思える内容でした。また新しい単語をチラ見せして、後で説明するなど魅せ方もうまく、感動しました。50分と長いためダレちゃいそうなのですが、中盤にあった「よくある勘違い」でそこまでの振り返りもしてくれ、その後の話にもすんなり入れたのがさらに良かったです。セッション聴きつつTwitterやりまくるスタイルの自分ですが、何一つツイートせずに集中して聴かせてもらいました。大満足でした。DDDの話、面白すぎて全くTwitter業が捗らなかった。— しらじ (@shiraj_i) 2017年3月9日Android Security 最前線！！セキュリティに関して知識が乏しいので、初級者〜中級者向けということで聴講しました。実装方法の説明をしつつ、セキュリティの説明をされていたのですが、初級者もターゲットであるなら、出来ればそこ分けてもらい、説明をしてから実際のコードはこう書く！という形で聴きたかったなと感じました。コードを追うので手一杯で実際に聴きたかったセキュリティの話を聴き逃してしまったり、セキュリティの話を真剣に聴いていたらコード追えなかったりしてしまいました。。。しかし、例えば知っていたカスタムCA証明書問題であればコード読んで非常にワクワク出来たので、やっぱり自分の不勉強のせいだなーと反省させられたセッションでした。Androidリアルタイム通信アプリ作成Tipsリアルタイム通信の実装方法を紹介しつつ、軽く実装の説明をしてくれるセッションでした。白山さんが言いたいことがいっぱいありすぎるのか、かなり早口でついていくのに必死でした。。。それぞれの通信方法の特徴やサンプルコード量の配分などが良かったです。30分ではなく50分のセッションでこの量の説明だったら最高でした。内容としてはリアルタイムの通信方法を検討するならぜひ参考にしたい内容でした。早口のハラハラ感もあり、楽しかったです。あと、このセッション前の絡みが面白かったのでまとめて呟いたら、ちょっとばずってました。30歳こえると厳しい->* 病院に行く回数が増える* 夜更かしが出来ない* 物覚えが出来ない* Android Studioの補完ないとツラい#DroidKaigi3— しらじ (@shiraj_i) 2017年3月9日Android定期実行処理入門定期実行処理といえば、AlarmManagerだろ？と時代に取り残されているので、勉強のために聴講しました。AlarmManager以外のモノは聞いたことはあるけど使ったことがないものばかりで、その特徴をしっかりと説明してくれて助かりました。残念ながらセッション中にあるコードの説明がうん？どこのこと言ってるんだ？と置いて行かれてしまったので、途中で追いつくのを諦めてコードのプレゼンって難しいなーとぼんやりしていました。たぶんハイライトや説明している部分だけコードを見せてくれたらもうちょっとついていけたかもと思います。内容自体は非常に充実していたので、録画見つつ、スライドを落ち着いて読み返したいなと思います。解剖 Kotlin ~バイトコードを読み解く~Kotlinバイトコードを読み解くということで、実際概念としては知っていましたが、あんまり深くバイトコードに注目したことがなかったので、聴講しました。このセッションの狙いが初学者の恐怖心を取っ払い、第一歩を踏んでもらおうという感じなんだと思いますが、本当にわかりやすく、話し方もゆっくり落ち着いていたので、理解しやすかったです。スライドのコード量も一度に出る量が少ないことや簡単なコードでひと目見ればわかるようになっていて、感動しました。Kotlin始める前に知りたかったなーという内容が多かったです。これをKotlin始める前に聴けた人たちは本当にラッキーだったのではないかと。「KotlinはJava。」もちろん、自分のようにある程度Kotlin知っている人でもKotlinの細かい部分を知ることが出来たので、聴けてよかったです。オフラインファーストなアプリケーション開発やっぱりオフラインは重要なのであることとzakiさんにお会いしたことがなかったので、聴講しました。内容はRealmありきな話になってしまっていて、正直それならRealmをセッション説明に入れてほしかったなーと思いました。特に自分のようにRealm入れられない状況の人に対してはちょっとツラいし、他との具体的な比較がなかったので、それじゃあRealmを入れてみよかという判断が出来なかったです。Realm以外でのツラい実装をして、その上でRealmなら〜という話であればうおおお！ってなったかもしれません。セッションの内容は中の人ということもありRealm自体の魅力を非常に感じられるセッションだったし、少し前のセッションでRealm Mobile Platformをオススメされていたこともあり、状況が変わるなら絶対検討しようと思わせてくれました。React Nativeはクロスプラットフォームモバイルアプリ開発の夢を見るかReact Native自体触ったことがないので、このセッションを聴いて判断しよーと思い聴講しました。Reactの説明からReact Nativeの説明にするっと入っていくところがおお！確かに！とわかりやすかったのが印象強かったです。セッションのテンポや流れもロジカルで聴いていて納得感も得られ、楽しかったです。非常にセッションが良かったので、実際にDroidKaigi後にReact Native触ってみました。即時反映されるし、手にしっくりくる感じでした。聴いてよかったセッションの一つでした。What’s New in RxJava 2.0RxJava2.0への移行はある程度把握していたのですが、実際に作業を実施したことがなく(RxKotlinが2.0に正式対応していないため。現在はRxKotlinは対応中。）ライブラリのコードを読む時くらいしか利用機会がないので、これを機にしっかりと把握したいと思い、聴講しました。Rxの初歩的な話から始まり、RxJava2.0で一番意識するようになるBackpressureの話に続き、RxJava1とRxJava2の比較があったりと流れも良かったです。スライドはシンプルで、でもアニメーションを効果的に使われていて、非常にわかりやすかったです。今までふわっとしていたBackpressure対応もこれで完璧に出来そう！と自信が持てるようになりました。Android ORMの選び方元々自分もORMに興味があって、Ormaを作ったgfxさんがどういう観点でORMを選ぶのか興味があったので聴講しました。この日もウェルカムスピーチを捨てて、Room3の最前列確保に走りました。セッション内容はORMの解説から始まり、自分がまさに知りたかった観点の説明、その点でのそれぞれのライブラリの比較をしてくれました。時間が押していたので一つライブラリの説明を飛ばしたりと時間調整もうまくさすがだ！と感心しまくりでした。内容もOrma万歳！なのかと思ったら、しっかりとOrmaの問題点を発表していたりと第三者目線での解説に徹していたように思えました。自分のORM選定にも自信が持てるセッションでした。個人で11個のアプリを公開した結果超激戦区のこの時間、どうするかなーと一つ前のセッションが終わってからも考えていたんですが、質問をしたくなるようなセッションとしてこのセッションを選びました。(結局質問しなかったけど)11個それぞれの開発動機・数値・感想などを聞きました。他にも個人で開発する時のTipsやアイコン特に気にすんななど、知らないことばかりでした。終わった後に自分ももっとアプリ出してみたくなりました。またアプリとは違いますが、Intellijのプラグインいっぱい開発していて、メンテどうするか？問題をかかえていたのですが、実際に使うようなやつはそのままやって使われていないようなプラグインはバグFixくらいだけやればいいかなーと気持ちが楽になりました。11個と量が多かったのでWearアプリとか似てるアプリをまとめちゃっても良かったのではないかなと思いました。こういう失敗も含まれたセッションって貴重なので聴けてよかったです。How to search and improve performance初心者~中級者向け＋使ったことあるツールだったので、あんまり期待せず、でもEaster Eggの問題点をという話だったので選択ミスだとしてもいいかなーという気軽な感じで聴講しました。が、はっきり言って、このセッションが一番衝撃的でした。まず、ANRなどのパフォーマンスに関わる説明があり、その後、実際のEaster Eggの問題を見せつつ、ツールを使って問題を突き詰め、改善していました。セッション内で自発的に「感嘆の声」と「拍手」が巻き起こっていたのが印象的でした。30分という短いセッションでしたが、出来れば50分にしてもらい、もう少し細かいステップでの問題解消の説明が聴きたい気分でした。わかりやすくて、見ていて楽しい。EasterEggの問題潰してるところがさらにすごい。初心者向けって書かれてたから悩んだけど、聴けてよかった。#droidkaigi1— しらじ (@shiraj_i) 2017年3月10日スライドだけでも素晴らしいのですが、セッション聴けなかった人はぜひビデオで確認してもらえたらなーと思います。セッション後に個別で静的解析とツールを組み合わせる場合の使うタイミングなどの質問をさせてもらいました。知っているコードならまずはコードを読み込んでからやると効率があがる。全く知らないコードであれば即ツールを使ったほうが早いとのことでした。Can You Read Your Tests? Clean and Useful Android Testing, with JUnit and Spock!Testコードって冗長的で長くなるし読みにくいからコメントやメソッド名に頼ることが多くてこれほんとうに正しい方法なのか？と疑問に思うことが多かったので、テストの書き方を再度勉強するために聴講しました。英語のセッションを聴くのが久しぶりで、かつ、元々コード量が多いコードから減らしていくという内容だったので、スライドを読むのも結構大変で、必死でついていきました。が、やっぱりついていけず漏れていた部分が多かったです。AssertJとか使っていたり、結果的に実際のテストコードが短くなるのは良いのですが、メソッドで切り出した部分も全て表記してほしかったなという印象です。セッション終わり際にCode Smellをまとめてくれたのは良い指標かなと感じました。Spockの説明はさすがで、ぜひ導入してみたいなーと感じました。2つのアプリ、1つの設計のデザイン指針Quipper社のデザイン指針が聞けると思い、しかも自社サービスのデザイナーは一人なので、どういうことをすればより良いデザインのサポートが出来るだろうかと思い、聴講しました。そして、最初のほうで会社やアプリの説明だったので気が緩んでKotlinの開発始めてしまい、それが完全にミスだったっぽく、ワンソースプロダクトの定義を聴き逃してしまいました。それをずっと引きずってしまい、申し訳ないのですが、あまり理解できませんでした。フレーバーで分けてるってことなのか、デザインのソースを一つにしていて、それを各種アプリで分けているのか？ブランド違う？うん？という感じで完全にやっちゃいました。またビデオとスライドを確認してみます。。。本当に申し訳ありません。Smoke and Mirrors in Android UIGoogle Photoなどの動きをどう作るのか興味があり、聴講したかったのですが、他のセッションの並び列と勘違いして、聴くのを諦めた時のツイートです。.@rallat さんのやつ聴きたかったけど、並びまくってて諦めた。井戸端会議聴きながらKotlin書こ。— しらじ (@shiraj_i) 2017年3月10日発表者さんに拾ってもらい、Fireside chat始まる寸前に退席して聴講させてもらいました。(Firesite chatもぜひ聴きたいので録画公開何卒！)Google PhotoのRecyclerViewをピンチイン・アウトすることによってグリッドの数を増やしたり減らしたり、一つの画像をローテートしたりして、最終的に画面全体に表示する機能があるのですがその機能の実装方法でした。セッションでもよく出ていましたが、本当にこんな気分でした。improved magic gif具体的な実装方法はActivity一つ、FragmentなしでRecyclerViewを重ねてそれを出し分けするというものでした。またViewOverlayを利用することで画像を一枚バーン！と出すようです。他にもローテートのためのPivotの設定方法など細かい部分をわかりにくくならない限界のところで説明してくれていました。海外では普通ですが、スライドには載っていない話が多かったので、本当に生で聴けて良かったなーというセッションでした。発表者さんとはAfter Partyでもお話させてもらい、これがベストプラクティスだということの確認も出来たし、実際Googleもそういう実装をしているからデビオ確認してみなよというアドバイスも頂きました。テスト0から目指すクラッシュフリー率99%テストがないプロダクトにテスト文化を根付かせたいと思ったので聴講しました。セッション内容はActivityにあるコードをテストするなんて無茶でしょ！という話からdelegateなどで切り出し、テストしやすいコードを作ってテストしていこうぜ！という話でした。残念ながら、テスト文化を根付かせたいという理由で聴いていたので、それが抜けてしまっていてあー！となりました。ただ、セッションの内容自体は素晴らしく、テストしやすいを意識して開発するという視点は本当に大事だなと認識しました。セッション後に話しさせてもらったのですが、そこのお話はマイク使って話して下さいよ！と何度もお願いするほど良いクオリティでした。その話のほうが実は刺さって、テストがないならまずUIテストで画面録画しまくっちゃえとか、まずは始めることが大事（要約）というような話でした。知っている方のセッションだとこう気軽に質問出来るのでありがたいなーと。ちなみにこのセッションでも始まる前に雑談があって、その話も結構面白かったです。場の温め方がうまいなーと感心でした。Androidの筋肉枠の一つは完全に白山さんな印象です。全体的にセッションの説明を読んで期待してから聴くので、このセッション説明と違ったりすると若干ネガティブな感想になってしまいました。ただ、自分の視点からはネガティブってだけで、予備知識があったり、別の人からすればすごい良かったり役立つ内容ばかりだったはずなので、ただの一観客の話だと軽く流してもらえたらなーと思います。。。Droidkaigi終わった後にこんな生意気なツイートしているのですが来年チャンスあったらスピーチ側に回りたい！という思いだけはあるので、次のCfP期限までに何か武器拾いたい。今持ってる武器はニッチ過ぎて、誰もいない部屋で一人で泣きながらプレゼンしてるのが目に見える。— しらじ (@shiraj_i) 2017年3月10日冷静にこうやってコメント書いていると、自分がスピーチしたら、来てもらったAndroiderの30分を無駄にしてしまうのでは？？？という気持ちになりました。実際にあれだけの人の前でスピーチ出来るの本当にすごいです。After PatryAfter Partyでは本当に名前をあげたら半端ない数の人と話すことが出来ました。主催者の日高さんと初めてお話することも出来て感激でした。そして、Kotlinやりだして一年ちょいですが、ついに日本のKotlerの憧れの的のたろーさんと話すことが出来ました。今までKotlin触ってて良かったなーとしみじみしました。ただ、嬉しすぎてテンションおかしくなってしまって、あとでこんなツイートしています。kotlinガチ勢集まった時、写真撮ってもらえばよかった！せっかくのチャンスだったのにもったいないことした。— しらじ (@shiraj_i) 2017年3月10日またKotlin勢揃うチャンスがあったら絶対撮ってもらいたいです！他にも自分が作ったdatabinding-supportを使ってくれていて、さらに修正PR送ってくれた方ともお話出来たのも本当に嬉しかったです。自分が作っているものを使ってくれている人がいた！！！って。本当に励みになりました。Twitter上でしか知らない人たちといっぱい会えた！良かった！楽しかったです！！！#droidkaigi— しらじ (@shiraj_i) 2017年3月10日まとめスタッフの皆様ありがとうございました！また来年よろしくお願いします！(名前を極力出さずに書きましたが、発表者の方と運営の方はどうしても必要だったので、書いてしまいました。もし消して欲しい方は@shiraj_iまでメンション下さい。即消します。)","link":"https://shiraji.hatenablog.com/entry/2017/03/12/183237","isoDate":"2017-03-12T09:32:37.000Z","dateMiliSeconds":1489311157000,"authorName":"しらじ","authorId":"shiraji"},{"title":"jitpack.ioではまったところまとめ","contentSnippet":"まとめ以前から色んな箇所で取り上げられているjitpack.ioですが、ドキュメントに書いてない機能であったり、書いてあってもよくわからない機能がいくつかあったのでまとめてみました。そもそもjitpack.ioって何か？とかどう使えばいいのか？は以下のリンクを確認して下さい。qiita.com以下の機能の説明をします。compile指定以外Multiple ModuleSNAPSHOT versioncompile指定以外compile指定以外ももちろん問題なく動きます。例えばよく使う、aptの場合apt 'com.github.$USER.$REPO:$Module:$VERSION'Multiple Module一つのレポジトリで複数のmoduleを扱うことがあります。その場合、jitpack.ioにアクセスし、repositoryのURLを貼ってみます。例えば、自作ライブラリでやってみます。github.com        allprojects {        repositories {            ...            maven { url \"https://jitpack.io\" }        }    }    dependencies {        compile 'com.github.User:Repo:Tag'    }こんな感じで入れればいいよ！と言われるので、そのままやるとコケます。Multiple Moduleなので、以下のように指定が必要になります。compile 'com.github.$USER.$REPO:$Module:$VERSION'これはドキュメント通りhttps://jitpack.io/docs/BUILDING/#multi-module-projectsなのですが、一つドキュメントに記載されていない事項があります。例えば、自分がコントリビュートしている、PermissionsDispatcherの場合github.comcompile 'com.github.shiraji.permissionsdispatcher:permissionsdispatcher:2.1.1'compile 'com.github.shiraji.permissionsdispatcher:permissionsdispatcher-processor:2.1.1'このように指定する必要が出てきます。つまりcompile 'com.github.$USER.$REPO.toLowerCase():$Module:$VERSION'が正しいフォーマットです。SNAPSHOT versionSNAPSHOTバージョンはweb上では一つしか選択できないようなUIです。ドキュメントにもbranch-SNAPSHOTと記載されているので、-SNAPSHOT付きのブランチを作成してもweb上では反映されません。しかし、ブランチが存在していさえすれば利用は可能のようです。例えば、v1.1.1-SNAPSHOTというブランチをリモートに作成してあるとしたら、以下になります。compile 'com.github.$USER.$REPO:$Module:v1.1.1-SNAPSHOT'ドキュメントにも書いてあるけど、webUIには反映されないから気をつけてねってことです。","link":"https://shiraji.hatenablog.com/entry/2016/04/01/133913","isoDate":"2016-04-01T04:39:13.000Z","dateMiliSeconds":1459485553000,"authorName":"しらじ","authorId":"shiraji"},{"title":"リファクタリングについて伝えたいこと。","contentSnippet":"この文章は以下に該当する方へ、なぜエンジニアにリファクタリング(リファクタ)させるべきなのかを記載しています。リファクタリングする＝サービスの開発が停止すると考えている方リファクタリングに関して価値を見出せない方エンジニアにリファクタリングさせて欲しいと言われる方最初にリファクタリングの話をする前に、一般的な職場に関する質問があります。あなたの職場は綺麗ですか？あなたが思い浮かべる「できる同僚・上司」の机は整理整頓されていますか？全ての人に当てはまるわけではないと思います。しかし大抵の方は両方回答がYesになると思います。職場を綺麗にするのはそこで働く人の健康維持やモチベーション向上に役立ちます。職場を綺麗にしてくれる専門のスタッフがいる企業もあるのではないでしょうか？また整理整頓された机で仕事することにより、ムダを省略することが出来ます。仕事をするスペースが増えることにより効率もあがります。大抵の出来る人は机を整理整頓している傾向があるそうです。著名な会社の研修でも同じようなことを説いていました。汚い環境で働くということは、モチベーションを下げ、ムダな作業を発生させ、効率を下げるということです。汚い環境で働くのは非常に辛く、可能であれば、人はその環境から離れていきます。リファクタリングとは何か？さて、本題のリファクタリングについてです。wikipediaでは以下のように説明されています。リファクタリング (refactoring) とはコンピュータプログラミングにおいて、プログラムの外部から見た動作を変えずにソースコードの内部構造を整理すること。*1もう少しサービス開発に絡めて切り込んだ説明にすると、「リファクタリングするということは、サービスの機能の追加や削除は一切行わず、コストをかけて、今まで動いていたコードに対して修正を加える作業です。」リファクタリングをすることにより、バグを埋め込んでサービスを止めてしまう可能性も含まれることになります。もちろんそれを避ける術はいくつかあるのですが、手段はエンジニアが考えればいいのでここでは省略させていただきます。リファクタリングをなぜやるのか？なぜこんなムダな作業を行うのでしょうか？エンジニアはアホなんでしょうか？エンジニアはコード上で仕事をしている（実際、アホなことやる人は多いですが・・・）事自分たちが行っているサービス開発に関して言えば、プライドを持って行っているはずです。サービスに携わっている以上、そのサービスがより良くなることを望んで開発しています。そのエンジニアがコストがかかることを承知で、リファクタリングさせて欲しいという理由があります。それはエンジニアはコード上で仕事をしているということです。デスクの綺麗さとコードの綺麗さ私が非エンジニアにリファクタリングの重要性を説明する時は以下のように説明します。デスクに毎日のようにいろんな人が資料を置いていくとします。資料を置くことを目的にする社員もいるので、資料はあなたが意図した場所には置かれません。デスクがどんどん汚くなっていき、必要な資料を探すのに苦労します。間違った資料を使って仕事をする可能性も出てきます。このような状況になった場合、あなたがまず最初に行うのが、整理整頓だと思います。ではエンジニアはコード上で仕事をしているということなので、デスクを「コード」、置かれていく資料を「追加機能」と読み替えてみます。コードに毎日のようにいろんな人が機能を追加していきます。機能追加を目的にする社員もいるので、エンジニアが意図した場所に機能が追加されません。コードがどんどん汚くなっていき、必要な機能を調査するのに苦労します。間違った機能を使って仕事をする可能性も出てきます。(=バグを作り出す)このような状況になった場合、エンジニアがまず最初に行うのが、整理整頓(=リファクタリング)だと思います。エンジニアが作業しているコードを綺麗にすることにより、将来的にバグを作り出さなかったり、効率良く作業が出来る環境を作ることが出来ます。エンジニアを惹きつける、引き止めるためのリファクタリング汚い環境で働くということは、モチベーションを下げ、ムダな作業を発生させ、効率を下げるということです。汚い環境で働くのは非常に辛く、可能であれば、人はその環境から離れていきます。この文章も同じように読み替えることが出来ます。汚いコード上で働くということは、モチベーションを下げ、ムダな作業を発生させ、効率を下げるということです。汚いコード上で働くのは非常に辛く、可能であれば、エンジニアはそのコード（会社）から離れていきます。エンジニアが働く場所の環境を良くすることとそのエンジニアを魅了するためにリファクタリングをさせる猶予を与えてあげてください。この魅力的な余裕があることでエンジニアとしてやる気が向上し、整理されたコードで仕事が出来るためパフォーマンスが上がります。働きやすい職場(コード)で最高のパフォーマンスを出すことが出来るのであれば、エンジニアが離職するのを引き止めるのに役立つはずです。まとめ汚い場所で人を働かせることが辛いということがわかるのであるなら、ぜひ汚い環境で働かされているエンジニアに掃除をする猶予を与えてあげてください。それが長期的に見るとサービスを改善を早くし、技術力のあるエンジニアを定着させ、変化に柔軟なサービスを提供させることが出来るようになるからです。*1:\"リファクタリング (プログラミング)\". wikipedia. https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0","link":"https://shiraji.hatenablog.com/entry/2015/09/06/225204","isoDate":"2015-09-06T13:52:04.000Z","dateMiliSeconds":1441547524000,"authorName":"しらじ","authorId":"shiraji"},{"title":"自己紹介","contentSnippet":"はじめてはてなブログを使ってみようと思います。普段技術ネタをQiitaにあげているのですが、技術ネタではないものを書くためにこのブログを開設しました。shirajiともうします。Qiitaもshirajiというアカウントで記載しておりますので、そちらも確認してください。思ったものを記載していくつもりです。更新ペースはそこまで高くないです。よろしくお願いいたします。","link":"https://shiraji.hatenablog.com/entry/2015/09/05/214030","isoDate":"2015-09-05T12:40:30.000Z","dateMiliSeconds":1441456830000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Eclipseの環境構築をまとめてみた","contentSnippet":"Objective-cやらJavaやらRailsやらPlay frameworkやら手を出しまくっているせいか書くネタがない。。。ということで、本題。Eclipseの設定をするという非常にだるいことになったので、一旦、何を毎回しているかメモ書き。あくまで自分の環境なので、設定して壊われても責任持ちません。vimのvundleみたいにファイル一つでやってくれたらいいのに。）1. インストールAndroid開発ならADT）http://mergedoc.sourceforge.jp/2. 英語化http://d.hatena.ne.jp/shiraji/20130427/13670544263. プラグインGlance（ctrl-jの上位互換）URL: http://code.google.com/p/eclipse-glance/Update Site: http://eclipse-glance.googlecode.com/svn/site/キーバインド設定は下に記載。Eclipse Color Theme (Editorの色変更)URL: http://eclipsecolorthemes.org/Update Site: http://eclipse-color-theme.github.io/update/設定方法テーマを選ぶWindow > Preference > General > Appearance > Color Themeで選ぶ（いつもWombat）カーソルがある行のハイライトがうざいので消すWindow > Preference > General > Appearance > Text Editor > Highlight current lineのチェックを外すついでに行番号を表示するWindow > Preference > General > Appearance > Text Editor > Show line numbersのチェックを入れるWombat好きなんだけど、field名とクラス名の色が同じなので、かえる。Window > Preference > Java > Editor > Syntax Coloring > Java > Fieldsを選択。色を変える。（色はだいたいいつも左から6番目、上から3番目）Eclipse Theme (Editor以外のテーマ変更、4.2 - Juno以上だった場合)URL: https://github.com/jeeeyul/eclipse-themesUpdate Site: https://raw.github.com/jeeeyul/eclipse-themes/master/net.jeeeyul.eclipse.themes.updatesite設定方法テーマを選ぶWindow > Preference > General > AppearanceでJeeeyul's theme - Chrome Themeを選び、再起動するパディング(Shadow？)を消すWindow > Preference > General > Appearance > Chrome Theme > General > Sash WidthでThin Sashを選ぶさらに画面大きくWindow > Preference > General > Appearance > Chrome Theme > Part > Part Statck ShapeのPart Paddingを0pxにする各パネルの色がいやWindow > Preference > General > Appearance > Chrome Themeで、右にあるパレット？の横の下三角形から > Editor's Presets > Chrome ClassicメモEclipse Dark Junoというものもあるけど、ところどころ白くて嫌。全部まとめて変えられればいいのに。 4. 補完Javaの補完の機能をもっと便利にWindow > Preference > Java > Editor > Contents AssistEnable auto activationをチェックAuto activation delay(ms): 80Auto activation triggers for Java: .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_いらない補完候補を消すWindow > Preference > Java > Editor > Contents Assist > AdvancedJavaの開発ならJava Proposalsだけあれば十分 5. UTF-8化エンコーディングをUTF-8にする。てかこれなんでデフォルトじゃないのだろう？Window > Preference > General > Workspace > Text file encodingをUTF-8 6. キーバインド Preferences > General > KeysGlanceのため、Incremental FindとIncremental Find ReverseをアンバインドGlanceのキーバインドName:「Open Glance」Windows」Name:「Next Match」上のキーバインドをコピーし、Name:「Previous Match」クリーンName:「Clean」Windows」ツールバー出したり消したりName：「Toggle Toolbar」Windows」 7. スプラッシュ画像を変える変えたいsplash.bmpを以下のフォルダに置く（オススメはEclipseたんなんですが、職場ではイメージを壊す恐れがあるので、要注意）eclipse\\plugins\\org.eclipse.platform_xxADTの場合eclipse\\plugins\\com.android.ide.eclipse.adt.package_xx 8. ツールバーのカスタマイズEclipse Junoを使っている方（特にADT）この設定はやらないほうがいいです。理由は追記に記載。Window > Customize Perspective... > Tool Bar Visibilityで不必要なものからチェック外す。自分の場合、LaunchとDebug以外全て外す。LaunchとDebugはマウス使うので。右にある各Perspectiveのテキストがうざい右にある各Perspectiveのアイコン右クリック > Show Textからチェック外す 9. コードテンプレート新しくファイル作成するとファイルの1-3行目にコメントが入るのがうざいWindow > Preference > Java > Code Style > Code Templates > Comments > Files > Edit > 空にするOverrideしたメソッドのコメントが意味不明Window > Preference > Java > Code Style > Code Templates > Comments > Overriding methods > Editに以下を記載/**新しいメソッドのテンプレートがうざいWindow > Preference > Java > Code Style > Code Templates > Code > Method body > Editで以下を記載throw new UnsupportedOperationException(\"havn't implemented, yet\");新しいファイル作成時、必ずコメントをつけるWindow > Preference > Java > Code Style > Code TemplatesでAutomatically add comments for new methods and typesをチェック（これもデフォルトにしてー） 10. その他検索した結果からファイルへ飛ぶときに新しいタブを開いてほしいWindow > Preference > General > SearchでReuse editors to show matchesを外すフィールド名の前は「m」とかプレフィックスにする。だけど、getter/setterではmはつけない場合。(開発場所により変わる)Window > Preference > Java > Code StyleでFieldsを選択し、Edit > Prefix listにm保存時に何かする（フォーマットとか）Window > Preference > Java > Editor > Save Actions開発場所によりかなり変わるため、なんともいえないが、必ずつけるものは以下Format source codeをチェックFormat edited linesを選択Organize importsをチェックAdditional actionsをチェックし、congifureをクリックCode Organizing > Remove trailing whitespaceをチェックAll linesを選択Missing Code > Add missing Annotationsをチェックし、その下の全てをチェックUnnecessary Code > Remove unused importsとRemove unnecessaray castsをチェックthis.とかのルールもここで設定すると便利。これ設定するようになってから、ctrl+shift+oとctrl+shift+fを押さなくなりつつある。Package Explorerに隠しファイルを表示するPackage Explorerの右側にある三角形 > Filters...をクリック.* resourcesのチェックを外す。 なんかまとめたら大作になた・・・。githubにあげて管理しなきゃ。放置しているレポジトリがあるから、腰をあげてみますか。にしてもこのブログのフォーマットうまくできない。// 追記 ////////////////////////////////////////////////ツールバーの変更についてツールバーにバグが存在しています。ツールバーのアイコンの移動や消したものをもとに戻す機能にバグがあり、動かないと報告もあります。https://bugs.eclipse.org/bugs/show_bug.cgi?id=340695もし、ツールバーからアイコン消したけど、やっぱり必要だったーなどがあった場合、以下のファイルを消すともとに戻ります。eclipse.e4.workbench/workbench.xmiパースペクティブなどのレイアウトをし直す必要があります。扱いには細心の注意を払って下さい。","link":"https://shiraji.hatenablog.com/entry/20140115/1390240223","isoDate":"2014-01-14T17:50:23.000Z","dateMiliSeconds":1389721823000,"authorName":"しらじ","authorId":"shiraji"},{"title":"Objective-cでNSArrayのcountではまったこと。","contentSnippet":"10月くらいからObjective-cを触っている。windows使っていて、Mac持っていないので、会社でしか触れていなくて。Mac買おうかなー。ということで初歩的なところではまったのでメモ。// 配列nil];for (NSIntger index = -1; index こんな感じで、ループさせてみた。まぁなにゆえ、ループ前にやらないのかとかあるけど、とりあえずそこはおいておいて。Javaにはないunsigned型があるので注意しましょうということでした。","link":"https://shiraji.hatenablog.com/entry/20131201","isoDate":"2013-11-30T15:00:00.000Z","dateMiliSeconds":1385823600000,"authorName":"しらじ","authorId":"shiraji"},{"title":"chef-soloでcookbookを作成する","contentSnippet":"以前からJenkinsさんをchefで立ち上げるところまで自動化したのですが、自動起動が設定されていなかった。自動起動設定がない。ということで、chefのcookbook作成方法のメモです。まず、環境を作る。git clone https://github.com/shiraji/chef-repo.gitbash chef_setup.shこれで問題なければ、今回使うchefやknifeが入る。以前にも書いたと思うけど、ざっくり構成についておさらい。chef-repo/nodesとrolesはかなり重要で、この2つを意識したcookbookを作れば、拡張性が高くなる。実際にcookbookを作成してみる。cd $HOME/chef-repo/site-cookbooks/knifeが色々揃えてくれた結果がこれsite-cookbooks/CHANGELOG.mdHello worldしてみる。デフォルトのrecipe（recipes/default.rb）に以下を書き込む。puts \"Hello World\"これだけでほぼ終わりなのだけど、せっかくなので、nodes, rolesを設定する。まずはrole。$HOME/chef-repo/roles/にjenkins_autorun.jsonを作成する。スクリプト作成したので、それを利用して、作成する。cd $HOME/chef-repo/roles/bash new_role.sh jenkins_autorun.jsonnew_role.shはsedでテンプレートファイルの中身を変更し、それをファイルに保存している。#!/bin/shif [ $# -ne 1 ]; then_role_name=$1cat role_template.json | sed -e \"s/NAME/${_role_name}/g\" > ./${_role_name}.jsonrole_template.jsonはknife create roleすると出来るべきroleファイル{  \"name\": \"NAME\",json_class\": \"Chef::Role\",  ],上記のコマンド叩いて、出来るのがこのrole。（コピペするだけでも問題ない。）{  \"name\": \"jenkins_autorun\",json_class\": \"Chef::Role\",  ],今のところ、attributesなどはないので、設定せず、run_listに先程作成したcookbookを設定する。{  \"name\": \"jenkins_autorun\",json_class\": \"Chef::Role\",\"recipe[autorun_settings]\"次にnode{  \"run_list\": [実行で必要な設定ファイル(chef-repo/solo.rb)はこんな感じ。le_cache_path           \"#{ENV['HOME']}/chef-repo\"$HOME直下に置いてあると想定されている。違う所に置いてある場合は、このファイルを変更すること。拡張子で一目瞭然だけど、solo.rbはrubyファイル。＄HOMEは使えないので注意。それでは実行cd $HOME/chef-repojson実行結果Starting Chef Client, version 11.6.0Hello Worldこれで、Hello Worldはできたので、今回の目的であるjenkinsのサービスの自動起動をしてみる。http://docs.opscode.com/resource.htmlrubyの文法を駆使してrecipeを作成していく。linuxのコマンドのため、resourcesはexecuteを利用する。execute \"autorun\" doただ、これだと、jenkinsのみのcookbookになってしまう。そこでattributeを設定し、roleで指定できるようにする。default[:autorun][:ons] = [\"jenkins\"]これを使うrecipeはこんな感じ。node[:autorun][:ons].each do |on|実際に実行してみるとStarting Chef Client, version 11.6.0Recipe: autorun_settings::defaultChef Client finished, 1 resources updatedこれでもまだ、拡張性がないので、autorunの設定のON、OFFができるようにする。default[:autorun][:ons] = []デフォルトのrecipeを以下にnode[:autorun][:ons].each do |on|node[:autorun][:offs].each do |off|ここで、roleでoverride_attributesを設定する。chef-repo/roles/jenkins_autorun.jsonを以下のようにする。{  \"name\": \"jenkins_autorun\",json_class\": \"Chef::Role\",    \"autorun\": {  },実行結果（上記と同じ）Starting Chef Client, version 11.6.0Recipe: autorun_settings::defaultChef Client finished, 1 resources updatedこれで完了。■注意点■CentOSの環境のみしかないので、chkconfigが使えないubuntuとか気にしていない。必要な場合はOS別のコマンドを作成すればいいと思う。","link":"https://shiraji.hatenablog.com/entry/20131006/1381068041","isoDate":"2013-10-06T14:00:41.000Z","dateMiliSeconds":1381068041000,"authorName":"しらじ","authorId":"shiraji"}]},"__N_SSG":true}