{"pageProps":{"member":{"id":"sosukesuzuki","nickname":"sosukesuzuki","realName":"Sosuke Suzuki","bio":"Software Engineer","avatarSrc":"/avatars/sosukesuzuki.jpg","sources":["https://sosukesuzuki.dev/feed.xml","https://zenn.dev/sosukesuzuki/feed"],"twitterUsername":"__sosukesuzuki","githubUsername":"sosukesuzuki"},"postItems":[{"title":"Jest で reject されたエラーのエラーコードをテストする","contentSnippet":"describe(\"test\", () => {  test(\"test\", async () => {    expect(doSomething()).rejects.toHaveProperty(\"code\", \"ENOENT\");  });});","link":"https://zenn.dev/sosukesuzuki/articles/f00dc136a68be8","isoDate":"2022-05-05T06:55:05.000Z","dateMiliSeconds":1651733705000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JS に TS のような型注釈を書ける Type Annotations プロポーザル","contentSnippet":"この記事では Type Annotations プロポーザルの概要とモチベーションについて説明する。概要Type Annotations プロポーザルは 2022 年の 3 月 9 日に Microsoft の TypeScript チームの Program Manager である Daniel Rosenwasser 氏のブログ記事 A Proposal For Type Syntax in JavaScript で発表され、2022 年 3 月の TC39 ミーティングで Stage 1 になった。Type Annotations プロポーザルは JavaScript に TypeScript のような型注釈の構文を導入する。たとえば、次のような型注釈を持つ関数宣言などが可能になる。function hello(name: string): void {  console.log(`Hello, ${name}`);}現段階では Enum や Namespace、Parameter Properties などの一部の機能を除くほとんどの TypeScript の型の構文が仕様に含まれている。このプロポーザルの重要な点は型注釈の記述は可能になるが、実のところそれらはコメントのように振る舞い、実際に動作には全く影響を及ぼさないというところである。したがって、上で定義した hello 関数を次のように呼び出しても問題なく動作する。hello({ prop: 1 });型注釈に基づいた実際の型チェックについては外部のツール(テキストエディタや CLI)で行うことになる。モチベーションFlow/TS のトランスパイルなしでの実行このプロポーザルの主なモチベーションは、開発者が書いた TypeScript や Flow などの静的型付け JavaScript をトランスパイルなしで実行できるようにすることである。我々が普段 TypeScript コンパイラで行っているトランスパイルは大きく２つに分けられる。1 つはダウンレベルコンパイルである。たとえば const foo = \"foo\"; を var foo = \"foo\"; にするような処理だ。もう 1 つが型の消去である。たとえば const foo: string = \"foo\"; を const foo = \"foo\"; にするような処理だ。そして近年、ダウンレベルコンパイルの必要性は低くなってきている。なぜなら、フロントエンドではエバーグリーンブラウザが主流になっており、バックエンドでは Node.js や Deno が十分に新しい V8 を使っているからだ。JavaScript が動作する環境では、大体の場合新しい JavaScript が動作するような世界になってきている。そして Type Annotations プロポーザルによって型の消去も不要になれば、トランスパイルそのものが不要になるというわけだ。JSDoc コメントの延長線としての Type Annotationsこれとは別の文脈として、JSDoc コメント的な使い方における利便性の向上といったモチベーションもある。実は TypeScript コンパイラは JavaScript 中に書かれた JSDoc コメントを使った型チェックができる。これによって TypeScript の環境を本格的に構築しなくても型チェックの恩恵にあずかることができる。たとえば筆者がメンテナンスしている Prettier は JavaScript で書かれているが、一部のコードでは JSDoc コメントを使って型を明示して TypeScript コンパイラを使って型チェックを行っている。しかし JSDoc コメントは冗長であり、複雑な型を表現するのが難しいなどの問題がある。Type Annoatations プロポーザルがあればこれらの問題を解消できる。感想筆者個人としては「理想としては共感できなくはないが、現実的には不可能に近いのではないだろうか」というような印象を受けた。まず、トランスパイルというかビルドステップを消し去るにはモジュールバンドラーをどうにかしないといけない。ブラウザが ECMAScript Modules を解釈できるようになった今、モジュールバンドラーの役割はダウンレベルコンパイルではなくパフォーマンスの改善になっている。そこに関しては Type Annoataions ではカバーできない(Subresource loading with Web Bundles に期待したい)。さらにガバナンスの問題もある。TypeScript のサブセットの構文が TC39 によって ECMA-262 に組み込まれたとして、その後の TypeScript と TC39 の関係はどのようになっていくのだろうか。標準化が足かせとなり TypeScript 側の進化が遅れることも考えられるし、TypeScript 側だけが進化して標準化が遅れてしまい結局みんな TypeScript をコンパイルして使うような未来も考えられる。「開発者の書いたコードがそのまま動く世界」を実現するためには Type Annotations プロポーザルは必要なステップだと思う。しかしそのために解消しなければならない難しく現実的な課題が多い。ちなみに筆者は書き捨てのスクリプトを書くときに JavaScript + JSDoc で書くことが多いのでそういうときに Type Annotations があったら便利だとは思う(この記事を書きながら思ったがそういうときは Deno を使えばいいかもしれない)。この記事ではざっくりと Type Annotations についか解説したが、詳細については https://github.com/tc39/proposal-type-annotations を自分自身で読んでほしい。FAQ には結構興味深いことが書かれている。参考リンクhttps://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/https://github.com/tc39/proposal-type-annotationshttps://github.com/tc39/notes/tree/main/meetings/2022-03","link":"https://sosukesuzuki.dev/posts/stage-1-type-annotations/","isoDate":"2022-05-01T00:00:00.000Z","dateMiliSeconds":1651363200000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Node.js 18 の node:test の型","contentSnippet":"@types/node にまだなさそうだからdeclare module \"node:test\" {  type TestContext = {    diagnostic(message: string): void;    runOnly(shouldRunOnlyTests: boolean): void;    skip(...message: string[]): void;    todo(...message: string[]): void;    test: Test;  };  type TestCb =    | ((testContext: T...","link":"https://zenn.dev/sosukesuzuki/articles/e981603c1af756","isoDate":"2022-04-25T11:08:02.000Z","dateMiliSeconds":1650884882000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"typescript-eslint/typescript-estree デバッグスクリプト","contentSnippet":"@typescript-eslint/typescript-estree をデバッグしたいことが誰しもあると思う。console.log デバッグ大好き君であるところの自分はこんなスクリプトを用意している。このスクリプトは ./packages/typescript-estree 直下に配置する。名前はなんでもいいけど、自分はマシンのグローバルの .gitignore に _tmptmptmp.* というのを入れていて、雑なデバッグ用スクリプトみたいなのをその名前にするようにしている。なのでこいつの名前は _tmptmptmp.js である。で、typescript-estree...","link":"https://zenn.dev/sosukesuzuki/articles/bcc66d0dd54dd3","isoDate":"2022-04-16T15:33:37.000Z","dateMiliSeconds":1650123217000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"esbuild に CJS として import してほしいのに ESM として import されちゃうときのプラグイン","contentSnippet":"import 文を書くと esbuild は該当パッケージを ESM として読みに行く。どういうことかというと、import 先のパッケージが Conditional Exports でこんな風に書いてる場合、./foo.mjs をバンドルする。package.json{  \"exports\": {    \"import\": \"./foo.mjs\",    \"require\": \"./bar.js\"  }}基本的にこれは望ましい挙動なんだけど、場合によってはうまくバンドルできなかったりする。たとえば、foo.mjsがこんな感じのとき。実装の実態は bar.js に...","link":"https://zenn.dev/sosukesuzuki/articles/d8220ba2d869f0","isoDate":"2022-04-07T11:54:25.000Z","dateMiliSeconds":1649332465000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"import.meta.url を esbuild で CJS に変換する","contentSnippet":"メモES2020 の機能で import.meta というのがあります。import.meta はモジュールのメターデータを含むオブジェクトです。ブラウザや Node.js では import.meta.url というプロパティが生えています。これは import.meta.url が評価されたモジュールのファイルの URL を表すプロパティです。Node.js では、ESM 環境下で createRequire をしたり __filename や __dirname に相当するものを取得する用途等でよく使われます。import module from \"node:module...","link":"https://zenn.dev/sosukesuzuki/articles/44992fc109ddb2","isoDate":"2022-04-05T13:38:09.000Z","dateMiliSeconds":1649165889000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"現実の Babel プラグインを SWC プラグインに移行する","contentSnippet":"最近の SWC は Rust でプラグインを書くことができます。https://twitter.com/swc_rs/status/1492454606118752257先日、現実の Babel プラグインを SWC プラグインに移植して実際に使ってみたので、それについて書き残します。(SWC のプラグインの仕様は変わっていく可能性が高いので、この記事や参照先のコードはあんまり参考にしすぎないように...) 移行対象の Babel プラグイン今回の移行対象の Babel プラグインは、主に React 用の状態管理ライブラリである Valtio に実装されている usePro...","link":"https://zenn.dev/sosukesuzuki/articles/e6ac87acdd7122","isoDate":"2022-03-20T05:15:51.000Z","dateMiliSeconds":1647753351000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Prettier のサイズを減らすテクニック","contentSnippet":"実は先日リリースした Prettier 2.6 では前のバージョンである 2.5.1 と比べてバンドルサイズが 3MB ほど減っています。Prettier 2.5.1 のサイズ(20.0MB)Prettier 2.6.0 のサイズ(16.9MB)リリースブログで言及したとおり Prettier 2.6 ではモジュールバンドラーを Rollup から esbuild に移行したので、その影響かと思われるかもしれませんが実はそれだけではありません。esbuild への移行によって減ったバンドルサイズはそれほど大きくはありませんでした。バンドルサイズが 3 MB 減ったのは泥臭いチューニングをいくつか行った結果なのです。この記事では Prettier 2.6 で実施したバンドルサイズを減らすテクニックを紹介します。きっかけライブラリのサイズは大きいより小さい方が当然良いですが、その重要度はライブラリによって異なります。たとえばブラウザで動かす目的で開発された UI ライブラリにっとてはサイズが小さいことは重要です。しかし Prettier のようなコードフォーマッターにとってはそれほど重要なことではないと考えています。ブラウザ上ではなく開発を行うマシンか CI のためのマシンの上で実行されることが多いためそれほどクリティカルな問題ではないのです。そのような状況の中で、我々が Prettier のバンドルサイズを減らすための努力を始めたのにはきっかけがあります。それは Chrome DevToolss が Pretty Print 機能のためのコードフォーマッターとして Prettier を採用しようと試みたことです。https://github.com/prettier/prettier/issues/12144この issue は Chrome DevToolss の開発チームのメンバーだった Tim van der Lippe 氏によって作成されたものです。要約すると「Chrome DevTools のコードフォーマッターとして Prettier を使うことを考えたんだけど、バンドルサイズが大きすぎる。なんとかして減らしていけないか。」というような内容です。この issue が作成されたすぐあと Tim van der Lippe 氏によって Prettier のバンドルサイズをへらすためのいくつかの Pull Request が作成されました。これを受けて私と、もう一人のメンテナーである fisker Cheung 氏は Prettier のバンドルサイズを減らすために動き出しました。(私も fisker 氏もバンドルサイズのチューニングがもともと好きだという事情もあります。)Tree Shaking には頼れないesbuild は今のところ CommonJS の Tree Shaking をサポートしていません。そして残念なことに Prettier のソースコードは CommonJS で記述されています。つまりモジュールバンドラーによる Tree Shaking には頼れません。なので Tree Shaking 相当のことを自分たちでやるしかありませんでした。ファイルを適切に分割するたとえば次のような utils.js というファイルがあるとします。// utils.jsconst foo = function () {  console.log(\"Foo\");};const bar = function () {  console.log(\"Bar\");};module.exports = { foo, bar };この utils.js を require する main.js があるとします。// main.jsconst { foo } = require(\"./utils.js\");foo();このとき Tree Shaking が適切に機能していれば最終的なバンドルから bar は取り除かれます。Tree Shaking なしでこれを実現するためには、単純に foo と bar を別のファイルで宣言する必要があります。// utils/foo.jsconst foo = function () {  console.log(\"Foo\");};module.exports = { foo };// utils/bar.jsconst bar = function () {  console.log(\"Bar\");};module.exports = { bar };そのような修正をいくつか行いました。https://github.com/prettier/prettier/pull/12156https://github.com/prettier/prettier/pull/12164https://github.com/prettier/prettier/pull/12176https://github.com/prettier/prettier/pull/12204https://github.com/prettier/prettier/pull/12203これは退屈でつらい作業でした。要らないものはビルド時に抹消する自分たちの管理しているコードに対しては上記のようなファイルを分割する方法で十分です。しかし依存しているライブラリのコードに対してはファイルをあとから分割することはできません。なので依存しているライブラリに関しては、未使用の API が esbuild の minifier によって抹消されるように設定する必要がありました。そのために esbuild-plugin-replace-text と esbuild-plugin-replace-module という２つの esbuild プラグインが fisker 氏によって実装されました。これらのプラグインを泥臭く設定することで、バンドルサイズを大幅に減らすことができました。esbuild-plugin-replace-textesbuild-plugin-repleace-text はバンドルする前のコードの中のある文字列を、指定の文字列で置換します。@rollup/plugin-replaceを知っている人はそれと同じだと考えてもらって大丈夫だと思います。(ちゃんと調べてないのでわかりませんが webpack の DefinePlugin もこの用途に使えそうです)さきほどの utils.js と main.js を思い出してください。utils.js を分割することなく最終的なバンドルから bar を取り除くことを考えます。esbuild-plugin-replace-text を使うと次のようにして実現できます。import { build } from \"esbuild\";import esbuildPluginReplaceText from \"./esbuild-plugin-replace-text\";const options = {  entryPoints: [\"./src/main.js\"],  minify: true,  bundle: true,  outfile: \"./dist/main.js\",  // その他のオプション...  plugins: [    esbuildPluginReplaceText([      {        file: \"./src/utils.js\",        find: \"const bar = \",        replacement: \"const bar = undefined && \",      },    ]),  ],};build(options);このように指定することで、 utils.js の const = bar  の部分をバンドル前に const bar = undefined &&  に置き換えることができます。これによって minifier の Dead Code Elimination により && の右辺が消されます。これでファイルを分割することなく、bar の実装を最終的なバンドルから消し去ることができます。esbuild-plugin-replace-moduleesbuild-plugin-replace-module も似たような機能を持つプラグインです。特定のモジュールに対する require / import を指定した別のモジュールへ置換します。次のような sub-lib.js があるとします。sub-lib.js は foo という関数をエクスポートしています。引数として与えられた kind が \"A\" のときに限り largeFunction という関数を呼び出します。// sub-lib.jsconst largeFunction = require(\"./largeFunction\");const foo = function (kind) {  if (kind === \"A\") {    largeFunction(options);  } else {    console.log(\"Foo\");  }};module.exports = { foo };ここで次のような lib.js があるとします。lib.js は bar という関数をエクスポートしています。bar は foo に \"B\" を渡しています。// lib.jsconst { foo } = require(\"./sub-lib.js\");const bar = function () {  foo(\"B\");};module.exports = { bar };そして次のような main.js があるとします。// main.jsconst { bar } = require(\"./lib.js\");bar();このとき main.js をバンドルすると、最終的な結果には largeFunction の実装が含まれることになります。しかし foo の引数として \"B\" を渡してはいるため largeFunction が実際に呼び出されることはありません。このような状況で最終的なバンドルから largeFunction を取り除くことを考えます。esbuild-plugin-replace-module を次のように設定することで実現できます。(次のような largeFunctionShim.js を作成しておきます。)// largeFunctionShim.jsmodule.exports = () => {};import { build } from \"esbuild\";import esbuildPluginReplaceModule from \"./esbuild-plugin-replace-module\";const options = {  entryPoints: [\"./src/main.js\"],  minify: true,  bundle: true,  outfile: \"./dist/main.js\",  // その他のオプション...  plugins: [    esbuildPluginReplaceModule([      {        \"./largeFunction.js\": \"./largeFunctionShim.js\",      },    ]),  ],};build(options);esbuild-plugin-replace-module のオプションとして largeFunction.js を largeFunctionShim.js に置き換えることで、バンドルから実装を抹消できます(() => {} に置き換えられる)。ビルドのデバッグがしやすい環境を整える快適にビルドのチューニングを行うためにはビルドスクリプトの開発を快適に行う環境を整える必要があります。esbuildまず、esbuild の圧倒的な速さがなければ快適にビルドスクリプトを改善することは到底できなかったでしょう。この記事の冒頭で esbuild のおかげでバンドルサイズが小さくなったわけではないと書きましたが、esbuild なしでは無理でした。たしかに esbuild に移行したからバンドルサイズが小さくなったわけではありませんが、esbuild に移行したからこそバンドルサイズを減らすための作業に取り掛かることができたのです。esbuild-visualizeresbuild-visualizer というライブラリによって、ビルド結果を可視化することができます。(webpack の Webpack Bundle Analyzer のようなものです。)この仕組みによって、余計なライブラリが含まれていることにすぐ気がつけるようになりました。CLI オプションデバッグを行うにあたって便利ないくつかの CLI オプションが追加されました。たとえば minify の有無や、esbuild-visualizer によるレポートの作成の有無などを CLI オプションで切り替えられるようになっています。ドキュメンテーションPrettier のビルドスクリプトは複雑です。しかしその複雑さに反してドキュメントが存在しませんでした。レビューは行われるとはいえ、メンテナー個人の意思によって CLI オプションが追加されるため、当人以外それを覚えていないような状況でした。これでは便利な環境を整えても他のメンテナーはその環境の恩恵を受けることができません。そこで CLI オプションについてはきちんとドキュメントを残すことにしました。https://github.com/prettier/prettier/tree/ae080df3e7c38e22ddb47699f71bd2bbca3d822e/scripts/build今後ECMAScript Modules への移行この記事を読んで、バンドルサイズのチューニングをしたことがある人は「なんて不毛な！」と思ったことでしょう。私もそう思います。ここまで紹介したテクニックのほとんどはソースコードを CommonJS から ECMAScript Modules に移行することによって不要になる可能性が高いです。ECMAScript Modules は性質上静的解析がしやすく CommonJS に比べて Tree Shaking などの最適化がよく働きます。Prettier は次のメジャーバージョンである v3 から ECMAScript Modules へ移行します。Chrome DevToolsChrome DevTools のコードフォーマッターとして Prettier が使われるかもしれないという話を紹介しましたが、おそらく当面はそのようなことはないでしょう。というのも、そのために色々と動いていくれていた Tim van der Lippe 氏はすでに Google を退職されているようなのです。いつか Chrome DevTools 上で Prettier が動くようになったら嬉しいですね。おわりにQ. 3 MB 減ってもまだ 16.9 MB なので十分でかいですよね？何がうれしいんですか？A. でかいですね。あんまりうれしくないかも。でもブラウザで JavaScript のコードをフォーマットするために必要なサイズ(standalone.js + parser-espree.js)は 783 kb から 595 kb になっているので、約 200 kb のダイエットと考えるとちょっとはうれしいかも？","link":"https://sosukesuzuki.dev/posts/how-to-reduce-prettier-size/","isoDate":"2022-03-19T00:00:00.000Z","dateMiliSeconds":1647648000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"esbuild でビルドするときのスクリプト","contentSnippet":"最近ライブラリをビルドするときはもっぱら esbuild を使っている。esbuild を使うときには大体 ./scripts/build.mjs みたいなのを用意している。この記事では、自分が使っているビルドスクリプトの雛形を紹介する。Stage 3 の Import Assertions と JSON modules を使って package.json を取得するので、Node.js v17 系が必要になる。環境変数 WATCH に true を渡しておくとウォッチモードになる。各種設定は用途に合わせてお好みで。import { build } from \"esbuild\"...","link":"https://zenn.dev/sosukesuzuki/articles/e65e95425e697e","isoDate":"2022-03-13T09:25:27.000Z","dateMiliSeconds":1647163527000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"instanceof をごまかす","contentSnippet":"２つの方法を紹介します。 Object.setPrototypeOf実際にはごまかすというよりは　instanceof は MDN にあるとおりinstanceof 演算子は、あるコンストラクターの prototype プロパティが、あるオブジェクトのプロトタイプチェーンの中のどこかに現れるかどうかを検査します。だけなので、納得感のある挙動なのですが、クラスベースの考え方だとあとから継承ツリーになにかを入れられるというのがやや違和感のある挙動なのでメモしておきます。JavaScript には instanceof という二項演算子があります。左辺に値を、右辺にクラスを渡...","link":"https://zenn.dev/sosukesuzuki/articles/e0516a3d4c424e","isoDate":"2022-03-04T03:45:44.000Z","dateMiliSeconds":1646365544000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"npm パッケージが ESM パッケージかどうか調べるウェブサイト","contentSnippet":"npm パッケージが ESM パッケージかどうか調べるやつを作った。https://is-esm-package.netlify.app/https://github.com/sosukesuzuki/is-esm-package 目的バンドラーを使ってウェブフロントエンドの開発をしているときはパッケージのモジュールシステムの差はバンドラーによって吸収されることが多いのであんまり気にならない。しかし、ライブラリを作る側だと気になることがある。具体的には Prettier の開発では結構気にする必要がある。(なんで気にする必要があるのか〜みたいな話はまた別に記事を書くつもりだ。...","link":"https://zenn.dev/sosukesuzuki/articles/72dac973f5a9fc","isoDate":"2022-02-27T15:19:16.000Z","dateMiliSeconds":1645975156000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"esbuild の生成物の先頭に @ts-nocheck をくっつけるプラグイン","contentSnippet":"esbuild でバンドルした結果の先頭行に @ts-nocheck コメントを追加する小さな esbuild プラグインを書いたのでメモとして残しておきます。そんなプラグインいつ欲しくなるんだよという感じですがほしくなってしまったので仕方なし。https://github.com/prettier/prettier/pull/12248ビルドが終わったタイミングで fs.readFileSync でビルド結果の中身を読み込んで // @ts-nocheck をくっつけて fs.writeFileSync で同じ場所に書き込んでいます。もっとスマートにビルド結果の中身をいじる方法...","link":"https://zenn.dev/sosukesuzuki/articles/9617c45ba7a467","isoDate":"2022-02-06T16:08:08.000Z","dateMiliSeconds":1644163688000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Babel プラグインを import しつつオプションを渡す","contentSnippet":"最近 eslint-plugin-import のテストを書いてて必要になったのでメモ。@babel/eslint-parser のオプションとして plugins を渡すときに、プラグインのオプションを指定したい。Babel プラグインは api と options を受け取る関数なので、こんな感じでラップして強制的にオプションを渡せる。import babelPluginSyntaxDecorators from '@babel/plugin-syntax-decorators';const parserConfig = {　　parser: \"@babel/eslint-...","link":"https://zenn.dev/sosukesuzuki/articles/8113c657753da0","isoDate":"2022-01-25T08:47:54.000Z","dateMiliSeconds":1643100474000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"TypeScript で unknwon の値が Node.js のエラーであることを検証する関数","contentSnippet":"メモimport typeUtils from \"node:util/types\";function isNodeError(error: unknown): error is NodeJS.ErrnoException {  return typeUtils.isNativeError(error);}","link":"https://zenn.dev/sosukesuzuki/articles/90e8b948e526d8","isoDate":"2022-01-19T00:14:03.000Z","dateMiliSeconds":1642551243000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"なぜ JavaScript の [1, 2, 3] + [4, 5, 6] は '1,2,34,5,6' なのか","contentSnippet":"先日次のツイートを見かけた。I have been writing Javascript since roughly 1997 but it still manages to occasionally do something that absolutely shocks me pic.twitter.com/JyYOo4wGOu— mcc (@mcclure111) January 11, 2022 JavaScript では [1, 2, 3] + [4, 5, 6] の結果が \"1,2,34,5,6\" であり、この挙動が直感に反しているというツイートである。実際のところ筆者も直感に反していると思う。しかしこの挙動は至って ECMAScript の仕様通りである。この記事では、なぜこの挙動が ECMAScript の仕様に従っていると言えるのか仕様を引用して説明する。大雑把な答えまず大雑把な答えを示しておこう。JavaScript で [1, 2, 3] + [4, 5, 6] が \"1,2,34,5,6\" になるのは、オペランドの配列の Array.prototype.toString が呼び出され、それらが文字列として結合されるからだ。しかしこれではつまらないのでちゃんと仕様をたどっていく。+ 演算子まずは + 演算子の挙動がどのように定められているか見ていこう。+ 演算子は The Addition Operator として https://tc39.es/ecma262/#sec-addition-operator-plus に定義されている。構文については多くの人の想像する通りだと思うし今回の本題ではないので無視するとして、セマンティクスを見てみよう。ここでは次のようにセマンティクスが定義されている。1. Return ? EvaluateStringOrNumericBinaryExpression(AdditiveExpression, +, MultiplicativeExpression).AdditiveExpression と MultiplicativeExpression とはここではそれぞれ左辺と右辺のことである。つまり + 演算子は EvaluateStringOrNumericBinaryExpression という Abstract Operation に左辺と+、そして右辺を渡した結果を返す。EvaluateStringOrNumericBinaryExpressionEvaluateStringOrNumericBinaryExpression は https://tc39.es/ecma262/#sec-evaluatestringornumericbinaryexpression に定義されている。この Abstract Operation は leftOperand、opText、rightOperand という次の３つの引数を取る。そしてその３つの引数を次のステップに従って実行する。1. Let lref be the result of evaluating leftOperand.2. Let lval be ? GetValue(lref).3. Let rref be the result of evaluating rightOperand.4. Let rval be ? GetValue(rref).5. Return ? ApplyStringOrNumericBinaryOperator(lval, opText, rval).これらのステップを大雑把に説明する。まず leftOperand を評価した結果を lref とする。そして GetValue(lref) の結果を lval とする(GetValue は https://tc39.es/ecma262/#sec-getvalue で定義されている。今回考えている場合のように [1, 2, 3] のような単純な配列を渡す場合はそのままの配列が返ってくると考えてよい。)。次にleftOperand に対しての処理と同じことを rightOperand に対しても行う。そうして lval と rval が得られる。最後に ApplyStringOrNumericBinaryOperator という Abstract Operation に対して lval と、引数として受け取っていた opText、そして rval を渡し、その結果を返す。つまり EvaluateStringOrNumericBinaryExpression はオペランドと演算子の種類を引数として受け取り、オペランドを評価し GetValue した上で、そのまま ApplyStringOrNumericBinaryOperator に渡すだけの Abstract Operation である。ApplyStringOrNumericBinaryOperatorApplyStringOrNumericBinaryOperator は https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator に定義されている。ApplyStringOrNumbericBinaryOperator は lval、opText、rval という３つの引数を受け取る。ApplyStringOrNumbericBinaryOperator のステップをすべて掲載すると長いの関連するステップのみ説明していく。まずは最初のステップでは引数で受け取った opText のバリデーションを行う。1. Assert: opText is present in the table in step 7.step 7 に掲載されている表によると opText は次のいずれかである必要がある。***/%+-<<>>>>>&^|もちろんこの記事の対象である + もここに含まれており妥当な opText である。次のステップは opText が + であるときのみ実行される。2. If opText is +, then    a. Let lprim be ? ToPrimitive(lval).    b. Let rprim be ? ToPrimitive(rval).    c. If Type(lprim) is String or Type(rprim) is String, then        i. Let lstr be ? ToString(lprim).        ii. Let rstr be ? ToString(rprim).        iii. Return the string-concatenation of lstr and rstr.    d. Set lval to lprim.    e. Set rval to rprim.a と b で lval と rval をそれぞれ ToPrimitive に渡してその結果を lprim、rprim とする。c では、lprim と rprim の少なくともどちらかの型が String であればもう片方も String に変換し、それぞれ lstr、rstr とする。そして lstr と rstr を文字列として結合した結果を ApplyStringOrNumericBinaryOperator 全体の結果とする。この場合には後続の d と e は実行されない。結論からいえば [1, 2, 3] + [3, 4, 5] では、このステップ c が実行されることで文字列の結合が行われ \"1,2,34,5,6\" が出来上がるというわけだ。c が実行されるのは、 lprim と rprim の少なくともどちらかの型が String であるときだけだ。そして lprim と rprim は ToPrimitive によって返された値である。すなわち、配列に対する ToPrimitive の結果が String であるために、冒頭で紹介した直感的でない挙動が引き起こされているのだ。ToPrimitiveToPrimitive は https://tc39.es/ecma262/#sec-toprimitive に定義されている。ToPrimitive は input という１つの必須の引数と preferedType という１つのオプショナルの引数を受け取る。ToPrimitive は input が Object 型だったときにそれを非 Object 型(つまりプリミティブ型)に変換する Abstract Operation である。ToPrimitive は次のステップに従って実行される。1. If Type(input) is Object, then    a. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).    b. If exoticToPrim is not undefined, then        i. If preferredType is not present, let hint be \"default\".        ii. Else if preferredType is string, let hint be \"string\".        iii. Else,            1. Assert: preferredType is number.            2. Let hint be \"number\".        iv. Let result be ? Call(exoticToPrim, input, « hint »).        v. If Type(result) is not Object, return result.        vi. Throw a TypeError exception.    c. If preferredType is not present, let preferredType be number.    d. Return ? OrdinaryToPrimitive(input, preferredType).2. Return input.1 は input が Object 型のときのみ実行される(input が最初から非 Object 型のときは 2 に進みそのまま input を返す)。次に 1 の各ステップ a、b、c について説明する。ステップ a では GetMethod を使って input の@@ToPrimitive を取得し exoticToPrim とする(GetMethod は https://tc39.es/ecma262/#sec-getmethod に定義されている。名前の通りオブジェクトからメソッドを取得するための Abstract Operation である。)。@@ToPrimitive は Well-known Symbols の１つで、Object 型の値がプリミティブに変換されるときの挙動を制御できる。MDN にドキュメントがあるので詳しくはそちらを参照してほしい。配列にはデフォルトの @@ToPrimitive は存在しないので今回の場合は exoticToPrim は undefined になる。そしてステップ b は If exoticToPrim is not undefined, then という条件付きで実行されるので、exoticToPrim が undefined である今回は b は実行されない。次にステップ c では preferedType が存在しないときに preferedType を number とする。今回 ToPrimitive は ApplyStringOrNumbericBinaryOperator から呼び出されているが、preferedType は指定されていないためこの c により preferedType は number になる。最後のステップ d では input と preferedType を OrdinaryToPrimitive という別の Abstract Operation に渡し、その結果を返す。つまり ToPrimitive は input に @@ToPrimitive が存在すればそれに基づいて input を非 Object 型に変換するが、@@ToPrimitive が存在しない場合は OrdinaryToPrimitive を呼び出し、その結果を返す Abstract Operation である。OrdinaryToPrimitiveOrdinaryToPrimitive は https://tc39.es/ecma262/#sec-ordinarytoprimitive に定義されている。OrdinaryToPrimitive は O と hint という２つの引数を受け取る。O は Object であり、hint は string もしくは number である。ToPrimitive から渡された input が O で、preferedType が hint だ。OrdinaryToPrimitive は次のステップに従って実行される。1. If hint is string, then    a. Let methodNames be « \"toString\", \"valueOf\" ».2. Else,    a. Let methodNames be « \"valueOf\", \"toString\" ».3. For each element name of methodNames, do    a. Let method be ? Get(O, name).    b. If IsCallable(method) is true, then        i. Let result be ? Call(method, O).        ii. If Type(result) is not Object, return result.4. Throw a TypeError exception.まずステップ 1 と 2 によって methodNames が決定する。hint が string のときは methodNames は \"toString\", \"valueOf\" になり number のときは \"valueOf\", \"toString\" になる。今回は ToPrimitive の 1 の c によって preferedType が number になっているので、methodNames は \"valueOf\", \"toString\" である。ステップ 3 では methodNames の各要素(今回の場合 \"valueOf\" と \"toString\")に対して順にステップ a と b を実行する。各ループごとに methodNames の要素は name という名前に格納される。まず a では Get を使って O から name に対応するメソッドを取得し method とする(Get は https://tc39.es/ecma262/#sec-get-o-p に定義されている)。次に b では IsCallable を使い method が呼び出し可能かどうかを調べる(IsCallable は https://tc39.es/ecma262/#sec-iscallable に定義されている)。もし呼び出し可能であれば method を呼び出しその結果を result とする。そしてその結果が非 Object 型であれば result を返す。そしてステップ 1、2、3を実行しての何も返すことができなかった場合、ステップ 4 で TypeError をスローする。OrdinaryToPrimitive を JavaScript で簡単に表現すると次のようになる。当然厳密ではないので疑似コードだと考えてほしい。function OrdinaryToPrimitive(O, hint) {    const methodNames =        // 1.        hint === \"string\" ? [\"toString\", \"valueOf\"]        // 2.        : [\"valueOf\", \"toString\"];    // 3.    for (const name of methodNames) {        // a.        const method = Get(O, name);        // b.        if (IsCallable(method)) {            // i.            const result = method(O);            // ii.            if (typeof result !== \"object\") {                return result;            }        }    }    // 4.    throw TypeError();}今回の場合は methodNames は \"valueOf\", \"toString\" なので、その順番でループが実行される。1回目のループでは Get を使って O(今回は配列)から valueOf を取得し method とする。method には配列の valueOf が格納され、IsCallable(method) をパスする。しかし配列の valueOf はその配列を返す。つまり配列の valueOf は Object 型の値を返すのだ。そのため ii の If Type(result) is not Object という条件はパスできない。したがって値を何も返さず次のループへ進む。2回目のループでは、Get を使って O から toString を取得し method とする。配列には toString が定義されているので、method はその配列の toString になる。今回のループでは method に 配列の toString が格納されているので IsCallable(method) は true になる。次に i でその method を呼び出した結果を result とする。配列のデフォルトの toString は String を返す。String は非 Object 型なので If Type(result) is not Object という条件をパスし result が OrdinaryToPrimitive の返り値となる。つまりなんだっけ？ApplyStringOrNumericBinaryOperator を思い出してほしい。ApplyStringOrNumericBinaryOperator では ToPrimitive によって左辺と右辺をプリミティブ化した値(lprim と rprim)が String であれば、それを結合して返すのだった。配列に対する ToPrimitive は結局のところ配列の toString を呼び出したものを返す。配列の toString の挙動は簡単に確認できる。(仕様では https://tc39.es/ecma262/#sec-array.prototype.tostring で定義されている)const arrStr = [1, 2, 3].toString();console.log(arrStr); // \"1,2,3\"つまり、単純にそれを結合したものが ApplyStringOrNumericBinaryOperator の返り値になり、それはそのまま + 演算子の返り値になるのだ。[1, 2, 3] + [4, 5, 6] の場合は、ToPrimitive([1, 2, 3]) が \"1,2,3\" であり ToPrimitive([4, 5, 6]) が \"4,5,6\" なので ApplyStringOrNumericBinaryOperator によってその２つが文字列として結合され + 演算子全体の結果が \"1,2,34,5,6\" になったということである。ここからハックさて、この仕様がわかればいくつかのハックが思いつくだろう。まずは ToPrimitive によって OrdinaryToPrimitive よりも先に実行される @@ToPrimitive を上書きすればその挙動を変更できる。const arr = [1, 2, 3];arr[Symbol.toPrimitive] = () => \"hello!!\";console.log(arr + [4, 5, 6]); // \"hello!!4,5,6\"また、配列の場合 toString よりも valueOf の方が優先される。なので valueOf が非 Object 型を返すように上書きしてもその挙動を変更できる。const arr = [1, 2, 3];arr.valueOf = () => \"hello!!\";console.log(arr + [4, 5, 6]); // \"hello!!4,5,6\"もしくは toString 自体を上書きしてもその挙動を変更できる。const arr = [1, 2, 3];arr.toString = () => \"hello!!\";console.log(arr + [4, 5, 6]); // \"hello!!4,5,6\"まとめThe Addition Operator の仕様には次のような記述がある。Note: The addition operator either performs string concatenation or numeric addition.つまり + 演算子というのは数値の加算もしくは文字列の結合を行う演算子なのだ。したがって直感的でない挙動を避けるためにはそれ以外の用途では使わない方がよいだろう。当然だが TypeScript では  [1, 2, 3] + [4, 5, 6] のような式はコンパイルエラーになる。TypeScript を使おう。","link":"https://sosukesuzuki.dev/posts/array-plus-array/","isoDate":"2022-01-13T00:00:00.000Z","dateMiliSeconds":1642032000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Prettier は Playground から直接 Issue を作成できます","contentSnippet":"Prettier にはブラウザ上でフォーマットを試せる Playground があります。https://prettier.io/playground上のスクリーンショットでは const    foo =    \"foo\"; を const foo = \"foo\"; にフォーマットしています。これは、技術的には Prettier のソースコードをブラウザで実行できるようにバンドルして Web Workers で実行する React アプリケーションになっています。この Playground には(多分)あまり知られていない機能があります。なんと右下の「Report Issu...","link":"https://zenn.dev/sosukesuzuki/articles/cae9aec1793c12","isoDate":"2022-01-09T23:47:36.000Z","dateMiliSeconds":1641772056000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Node.js コアモジュール の import/require の node schema を強制する ESLint ルール","contentSnippet":"メモ。Node.js のコアモジュールを import/require するときは node schema をつけることができる。const fs = require(\"node:fs\");const path = require(\"node:path\");それ自体の概要については公式ドキュメントや@yosuke_furukawaさんのブログ記事を読んでほしい。https://yosuke-furukawa.hatenablog.com/entry/2021/12/27/003424ここから本題。筆者はこの機能は便利なので使っていくべきだという立場である。しかし普通にコード...","link":"https://zenn.dev/sosukesuzuki/articles/ee9c612446c62d","isoDate":"2022-01-08T21:48:12.000Z","dateMiliSeconds":1641678492000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript で対が存在しないサロゲートペアとマッチする正規表現","contentSnippet":"先日 Acorn に https://github.com/tc39/ecma262/pull/2154 を実装するときに調べたhttps://github.com/acornjs/acorn/pull/1090const regex = /[\\uD800-\\uDFFF]/u","link":"https://zenn.dev/sosukesuzuki/articles/01a448f4fd9f2d","isoDate":"2022-01-08T19:27:53.000Z","dateMiliSeconds":1641670073000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"翻訳: Prettier はメンテナーへの報酬の支払いを始めます","contentSnippet":"この記事は Prettier 公式ブログに掲載されている Christopher Chedeau (@vjeux) 氏による記事 Prettier begins paying maintainers を、許可を得て翻訳したものです。JavaScript を始めとしたいくつかの Web 開発のための言語のコードフォーマッターである Prettier は、2019 年から OpenCollective で寄付を募り始めすでに $50,000 が集まっています。私達はこの資金から二人のメンテナーに毎月$1500を支払うことにしました。この資金により、彼らは将来に渡って Prettier のメンテナンスを継続できます。オープンソースとお金の問題は往々にして厄介です。私たちはこの問題に対して様々なことを試してきました。Prettierがオープンソース化された直後に Facebook は James Long (訳注: Prettier の作者) と2週間の契約を結びこのプロジェクトに磨きをかけました。そして Christopher Chedeau（vjeux） には9ヶ月の間フルタイムで取り組んでもらいました。また、寄付で集まった資金が $10,000 を超えたころ、大きな貢献をしてくれた開発者全員に $1,000 ずつ配ろうとしました。しかし、手続きがやや複雑であったため、実際に報酬を受け取った人はほとんどいませんでした。現在私達が持っている $50,000 というのはそれなりに大きな金額ですが、それに取り組むだけのスキルを持った人をフルタイムで雇うには足りません。だからといってその資金を使わないまま放置しておくわけにもいきません。そこで、検討の結果、現在このプロジェクトのメンテナンスをしている二人に対して定期的に$1,500を支払うことにしました。彼らはこの二年間、Prettierプロジェクトの素晴らしいstewardでした。Fisker CheungSosuke Suzuki (訳注: 私)ご想像のとおり、全JavaScript開発者の60%が使っているプロジェクトをメンテナンスすることは簡単ではありません。現在、我々は 3.0 のリリースや ECMAScript Modules への移行などを予定しています。さらに、全ての新しい言語機能に対応し続け、定期的に発生するエッジケースのバグも修正します。もし Prettier があなたやあなたの会社の役に立っているなら、今一度 Prettier への寄付を検討してください。その寄付金は、Prettier をより良くするために使わせていただきます。","link":"https://sosukesuzuki.dev/posts/prettier-begins-paying-maintainers/","isoDate":"2022-01-07T00:00:00.000Z","dateMiliSeconds":1641513600000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"2021 年振り返り","contentSnippet":"2021 の出来事を振り返ります。学校2021 年 4 月で B3 になるはずだったんですが、留年しました。留年していたらしいということを夏頃に知りました。後輩が教えてくれました。僕が留年したことを教えてくれた後輩たちの顔はすごく楽しそうでした。いつか留年するつもりではいたので特に悲しい気持ちはなかったんですが、留年したことに気づくことすらできてなかったのはちょっとおもしろいなと思いました。両親も「そりゃそうだよね」みたいな反応をしていました。筑波大学の留年の仕組みをよく知らないので自分が B3 と名乗るべきなのか B2 と名乗るべきなのかよくわからないんですが、少なくとも卒業までの年数が1年伸びたのは確かなようです。留年はしたものの、線形代数 A という科目を再々履修で修得することができました。すごく嬉しかったです。色々と教えてくれた同級生、後輩、知りあいのエンジニアの方々、本当にありがとうございました。これはこの一年の中で最も偉大なことでした。秋に受講した授業の成績がまだ発表されていないのですが、かなりやばそうな雰囲気があります。仕事初めてソフトウェアを開発する仕事(アルバイト)をはじめたのが 2017 年の 1 月だったので約 5 年経過したことになります。現在は二つの会社で業務委託として雇用されています。Cybozuサイボウズのフロントエンドエキスパートチームというところで働いています。2021 年の最初の頃に、kintone というプロダクトのフロントエンドのコードベースに Prettier を導入するという仕事をしました。Prettier を導入するなんて簡単じゃないかと思われるかもしれませんが、実際はかなり長い道のりでした。kintone のフロントエンドは Closure Tools という JavaScript ツールチェインで実装されています。Closure Tools では JavaScript のコメントを使って型を記述して静的な型チェックができるのですが、この機能と Prettier の相性がすこぶる悪かったのです。実際に kintone のコードベースに対して Prettier を実行すると型が壊れるというバグがいくつか見つかりました。自分が入る前にこの問題に色々な方法でアプローチしたそうなのですが、どれも微妙に上手くいかなかったそうです。で、「せっかく Prettier にやたら詳しい人がチームに入ったんだから本体直せばいいやん」ということで、本体にいくつかパッチをあてるのと、それをリリースするための作業を業務時間にやりました。これは普通に楽しかったし、「Closure Tools を使い続けるのはつらいことが多いよ」という点と「OSS メンテナーを会社に抱えてるとこういうところでいいことあるよ」という点で、良い例を示せたかなと思います。という話をサイボウズの技術ブログに書きました。大規模 Closure Tools プロジェクトに Prettier を導入するまでの道のり - Cybozu Inside Out | サイボウズエンジニアのブログチームでやっているフロントエンドマンスリーという月に一回の配信にも何度か出演しました。自分はだいたい TC39 の動向とかを話していました。自分が情報を収集するきっかけにもなって良かったです。Cybozu Frontend Monthly他に外に出てる仕事としてはチームのウェブサイトを作りました。これはもともとハッカソンで作ったんですが完成させて公開しました。チームメンバーの皆さんはいろいろな有益なフロントエンド情報を会社のインターナルな場所に書いているんですが、そのうち結構な割合のものがサイボウズ特有の情報ではなかったので表に出していいじゃんと前から思っていました。なのでこういう場でたくさん発信していけたらいいなと思っています。サイボウズフロントエンドエキスパートチームのウェブサイトを作りました | サイボウズ フロントエンドエキスパートチームUbie実は 4 月くらいから気が向いたときに Ubie という会社で働いています。Ubie では昔インターンをやっていたのですが業務委託として戻りました。Ubie のとあるエンジニアが書いた記事があります。150 万 MAU の Nuxt.js 製サービスを機能開発を止めずに 1 ヶ月&1 人で Next.js に置き換えた話この記事の最後の方に出てくる「識者」というのは実は自分です。Ubie のドメイン知識が多少あって、コミュニケーションコストが低くて、フロントエンド周りを見れる、みたいなところで声をかけていただいたようです。記事にあるように、フロントエンドの設計の壁打ち相手になったり、少し手を動かしたりといったお手伝いをしました。この作業が終わったあとは、フロントエンドのパフォーマンスを改善したり、メンバーの Pull Request を見て気になった箇所を先回りするように ESLint のルールを入れたりとか、ライブラリのバージョンあげたりそういう細々したことをやらせてもらっています。Ubie のインターンをやめてから仕事では現代的なフロントエンド開発をほとんどしていませんでした。なのでそういうのに触れる機会としてはかなり良かったと思います。OSS9 月頃に GitHub Sponsors を始めたところ想像していた以上に多くの人から支援していただけたことが印象に残っています。Prettier今まで通りバグ修正とか機能追加みたいなコードを書く仕事や、Issue の管理や PR のレビューみたいな作業をずっとやっています。あと actionlint を Prettier で使いたかったので Go で書かれた actionlint を WebAssembly にコンパイルして Node.js から実行できる node-actionlint というツールを作りました。まあまあ便利なんですが Node.js と WebAssembly をかませる分速度的なオーバーヘッドがすごいので、ローカルで実行するときは本家 actionlint を使ってます。今年のバージョンのほとんどでリリースを担当しました。リリースはやることが多いので面倒だし緊張するのであんまりやりたくないのですが、自分がやらないと一生 Prettier がリリースされなさそうで、それは困るのでやることにしました。リリースに関連して、prettier-regression-testing という自作のツールを TypeScript で書き直して GitHub の Prettier オーガナイゼーションに移管しました。去年に比べて明確に他のメンテナーとのコミュニケーションが増えました。Prettier はインターナルな Discord サーバーがあってそこでアクティブでないメンテナーも集まって話をすることがあります。英語でのチャットは以前はすごい苦手だったんですが、最近ちょっとずつ慣れてきました。OpenCollective で集めたお金をどう使おうか、というのをずっと上手く話せずにいたんですが、ちょっと頑張ってやっとまとまったので近いうちにブログを書きます。新しいメンテナーを推薦して招待するとかそういう活動もしていました。いろんな Podcast や登壇で「Prettier には人が足りなくて〜〜」みたいな話をするのもいい加減飽きてきた感じがあるので人を増やそうと思ったのです。アクティブに活動してくいれているコントリビューターを他のメンテナーに推薦して合意がとれたら勧誘して、みたいなことをしてました。2021 年は約 100 個の Pull Request を出しました。Babelリポジトリのライト権限をもらいました。今の所権限を使ったことはほとんどありません。月に数回程度 Pull Request を投げています。たまにレビューとかもやっています。Babel でやった最も大きな仕事は、パーサーの構文エラーにエラーコードの概念を導入したことです。Prettier で Babel のパーサーを使うときに復帰したい構文エラーと復帰したくない構文エラーがあるんですが、今まではその判定をエラーメッセージに対する正規表現マッチングでやっていました。これだと Babel 側がエラーメッセージをちょっと修正しただけで Prettier の挙動に影響が出るのでエラーコードを導入してそれを使ってエラーから復帰するかどうかの判定をするように変更しました。https://github.com/babel/babel/pull/130332021 年は約 40 個 Pull Request を出していて、3 番目に多いみたいです。お金をもらっていないメンバーの中では 1 番でした。typescript-eslinttypescript-eslint のメンテナーは忙しそうなので助ける意味もこめて TypeScript の新しいバージョンがリリースされたときにはその対応をやっています。あと普通に自分がほしいルールを実装しました。2021 年は約 20 個 Pull Request を出しました。SWCRust への入門として SWC への貢献をちょっとずつやっています。Babel に比べてまだまだバギーなので貢献するべきところがたくさんあって楽しいです。ただ貢献するために求められる Rust 力はそんなに高くないので、Rust の練習としては微妙だったかもしれません。最初の頃はパーサーのバグ修正や機能追加をやっていました。普通の再帰下降構文解析で実装されているので、Rust のことがわからなくてもある程度雰囲気で書けました。最近はトランスフォーマーの実装をやっています。SWC のトランスフォーマーは Babel に比べるとかなり難しいです。パーサーを修正することに比べると Rust の知識が必要だし、何よりトランスフォーマーを書くための内部 crate のドキュメントがほとんどありません。なので既存のトランスフォーマーのコードを読んで、自分でコードをたくさん書いて修得するしかありませんでした。楽しかったです。余談ですが SWC のドキュメントには JavaScript でプラグインが書けるっぽいことが書いてあるんですが、これは v2 でなくなるようです。SWC で現在計画されているプラグインシステムではユーザーが Rust を使ってトランスフォーマーを書く必要があります(パフォーマンス上の懸念から JavaScript プラグインは今のところ計画されていません)。SWC が今後 Babel を置き換えていこうとするならここがネックになるような気がします。Babel プラグインは公式が便利なヘルパーを提供している上にドキュメントが豊富です。しかも多くの Babel ユーザーが得意であろう JavaScript で書けます。一方で SWC の場合は言語が Rust な上に今のところ便利なヘルパーはほとんどなくトランスフォーマーのドキュメントもない状態です。このあたりを変えていく必要があります。とりあえず JavaScript ツールをよく触るエンジニアは Rust の勉強を少ししておいた方が後々楽かもしれません。2021 年は約 20 個 Pull Request を出しました。イベント等いくつかのイベントや Podcast に出演させていただきました。楽しかったです。mozaic.fmmozaic.fm という Podcast に 2 回出演させてもらいました。一回目は「TC39」というテーマでしたが、あんまり TC39 の話は出来なかった気がしていて、ちょっと後悔しています。今ならもう少し TC39 っぽい話ができそうだなと思います。ep78 TC39 | mozaic.fm二回目は Monthly Web です。JavaScript っぽいことをちょっと話しました。ep82 Monthly Web 202104 | mozaic.fmWeb24Web24 という、24 時間 Web について議論し続けるというイベントに参加しました。このイベントでは、時間ごとにテーマとメンバーが変わるのですが、自分は Frontend Tooling というテーマで話しました。結構おもしろい話ができたんじゃないかと思います。アーカイブは残ってないので何を話したのか今となってはわからないのですが。Web24 - connpass東京 Node 学園 36 時限目東京 Node 学園 36 時限目で、「Prettier に従わなくてもよい場合」という発表をしました。「Prettier に脳死で従うべき」みたいな話を見るたびに「必ずしもそうではなくない？」と思っていたので、OSS 仕草の話をあわせて Prettier との向き合い方みたいな話をしました。Node学園 36時限目 オンライン - connpassUIT INSIDE ep. 100LINE の UIT INSIDE の ep. 100 に出演しました。過去の出演者たちが出演するやつらしくて、自分は前に Podcast に出演させてもらったので、声をかけていただきました。OSS をテーマに話しました。UIT INSIDE ep.100『100回記念8時間生放送』 - connpassJSConf JP 2021JSConf JP 2021 で、最初の基調講演をさせていただきました。ここ二年間くらい JavaScript の OSS に深く関わってきて、色々思うことをちまちまと発信はしていたのですが、ちょっとまとめて話したいなと思ったので CFP を応募しました。海外の OSS メンテナーたちにインタビューしたりして、自分も楽しくやれたので良かったです。30分の登壇をするのは初めてでしかも基調講演なのでちょっと緊張しましたが何事もなくやれました。JSConf JPブログhttps://sosukesuzuki.dev には 9 個書きました。TC39 の気になるプロポーザルを見つけたときに詳細を書くのが多かったです。何回かやっていると仕様を読むのに慣れてきてどんどん楽しくなっていきました。https://zenn.dev/sosukesuzuki には 17 個書きました。こちらはほとんどメモみたいな記事ばかりです。いくつかメモよりもう少し詳しいくらいの記事があります。メモが意外と伸びてびっくりしました。仕事で作った会社のブログ https://cybozu.github.io/frontend-expert にも 3 本くらい書きました。ブログを書くことを重視しているわけではないですが、文章を書くのは好きなのでこれからも思いついたときに雑に書きます。せっかく会社のチームのウェブサイトを作ったので、そっちでもいっぱい書こうと思います。その他自動車教習所2020 年の 6 月くらいから自動車教習所に通っていました。しかし、ずっとサボっていたら期限が切れてしまったので免許をとることはできず退校しました。あまりにサボっていたので半額返ってきました。でも車を運転したいので次の春に後輩と一緒に合宿免許にいきます。諦めない心が大事だと思います。読書何冊か技術書を読みました。数えてみたら月に 0.7 冊くらいは読んでいたみたいです。中でも次の3つの本は今の自分にとってすごくおもしろかったです。プログラマのための文字コード技術入門[試して理解］LinuxのしくみTCP技術入門まとめ「周囲の人間はよく頑張っていてすげーなーまあおれはのんびり適当に生きるけどね」みたいな気持ちでずっといた一年でした。個人的には本当になんにもやっていない感覚があったので振り返ってみて実は色々とやっていたことを知ってびっくりしました。（留年と教習所期限切れのダブルパンチでプラマイゼロどころかマイナスみたいな感じではありますが）とは言ってもやっていることの内容は去年の延長みたいな感じで新しいことはほとんどできていませんでした。なので来年は何か新しいことに挑戦したいです。しかしまずは進級と免許です。","link":"https://sosukesuzuki.dev/posts/2021/","isoDate":"2021-12-28T00:00:00.000Z","dateMiliSeconds":1640649600000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"babel-parser デバッグスクリプト","contentSnippet":"babel-parser を開発するときに使うやつ。./packages/babel-parser において使っている。jq よく知らないのでもっと良い書き方あるかも。--omit-loc でロケーション情報なしのやつ。--errors で Recoverable なエラーの配列。/* eslint-disable */const { execSync } = require(\"child_process\");const { parse, parseExpression } = require(\"./lib/index.js\");const args = pro...","link":"https://zenn.dev/sosukesuzuki/articles/66b7bb7a3bf365","isoDate":"2021-11-28T15:49:04.000Z","dateMiliSeconds":1638114544000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"swc に Stage 4 のプロポーザル class static blocks を実装した","contentSnippet":"Rust で書かれた swc という JavaScript のトランスパイラがあります。最近は Next.js 12 からデフォルトで Babel の代わりに使われることになったので日本でも話題にあがることが多くなったように思います。https://github.com/swc-project/swcちょっと前から、暇なときに、Rust への入門のために swc に貢献しています。この間、現在 Stage 4 の static blocks という提案を swc に実装したので、そのときの話を書きます。ただ数ヶ月前の話なので、正直詳細まで覚えていません。なのでこの記事は雑なメモだと...","link":"https://zenn.dev/sosukesuzuki/articles/c2fa4f24ae8880","isoDate":"2021-10-31T22:40:43.000Z","dateMiliSeconds":1635720043000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"TS4.5 の type Modifiers on Import Names のパースがおもしろい","contentSnippet":"TypeScript 4.5 のベータ版がアナウンスされました。https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/たくさんの新機能があり、大きなバージョンになりそうです。それらの新機能の中に type Modifiers on Import Names というものがあります。これは、TypeScript 3.8 から追加された Type-only imports and exports を specifier 単位で指定できるようにしたものです。今までは、import { Foo1...","link":"https://zenn.dev/sosukesuzuki/articles/1460075795cf08","isoDate":"2021-10-02T07:53:34.000Z","dateMiliSeconds":1633161214000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"ECMAScript Modules  が動く場所での最小構成フロントエンド","contentSnippet":"ECMAScript Modules が直接動く環境でしか使われないアプリケーション(自分用便利ツールとか)のフロントエンドなら、モジュールバンドラーは要らないじゃんという構成。なんとびっくり書いたコードがそのままブラウザで動いてすごい。 作ったもの２つのテキストの差分を見せてくれるやつ。https://sosuke-diff-editor.netlify.app/https://github.com/sosukesuzuki/diff-editor 使った技術preactサイズが小さい & UI が宣言的に書ける & 状態管理がいい感じ...","link":"https://zenn.dev/sosukesuzuki/articles/077ee084b7a623","isoDate":"2021-09-27T21:42:31.000Z","dateMiliSeconds":1632778951000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"GitHub Sponsors をはじめました","contentSnippet":"GitHub Sponsors をはじめました。I've just started GitHub Sponsors. If you like my Open Source work, you can sponsor me on GitHub.https://t.co/1xiCsXDpzC— sosuke (@__sosukesuzuki) September 9, 2021 すでに4人の方に支援していただいています。ありがとうございます。他の方にも支援していただけると嬉しいです。Sponsorどのような OSS 活動をしているのか主に JavaScript や TypeScript などのためのコードフォーマッター Prettier のメンテナーをやっています。また Prettier が依存している他の OSS プロジェクトにも貢献しています。Babel や typescript-eslint に貢献しています。Babel では、パーサーを中心にバグ修正や機能追加をしています。最近では、babel/babel や babel/website のリポジトリへのコミット権限が付与されました。typescript-eslint では、TypeScript の新しい構文への対応や、Babel の TypeScript パーサーの AST との互換性の改善などの作業をしています。ほかにも、興味のあるプロジェクトには積極的に貢献しています。swc のバグ修正や新しい構文への対応などをしています。私が作成した直近 25 件の Pull Request と Issue は https://sosukesuzuki.dev/github/ から確認できます。なぜ GitHub Sponsors をはじめたのかより多くの時間を OSS 活動に割くためです。現在、私は偶然にもある程度の時間を OSS 活動に割くことができています。私は大学生で、フルタイムの仕事がなく、家庭を持っていません。モチベーションが低下したり、就職したりして、十分な時間を OSS に割けなくなる可能性があります。また、私のモチベーションが維持できないと Prettier プロジェクトのメンテナンスの継続が難しいという短期的な理由もあります。Prettier は JavaScript や TypeScript を使った開発では欠かせないソフトウェアとなりました。dprintなどの新しいソフトウェアも知られるようになってきましたが、最もよく使われているのはおそらくまだ Prettier です。しかし、Prettier Team は人手が足りていません。アクティブなメンテナーは私を含めて 2 ~ 3 人です。私にとって OSS 活動はオンラインゲームのようなもので、そのほとんどが完全な趣味です。(一部仕事としてやったものもあります)なので、いつ飽きてやめるか正直わかりません。支援があれば、「応援されてるしお金も貰ってるからやるか〜」といったモチベーションが湧いてくるでしょう。なぜ今まで GitHub Sponsors をやっていなかったのかGitHub Sponsors に登録するには Stripe に登録する必要があり、そのために身分証明証が必要になります。最近になって再度確認してみたところ、マイナンバーカードでも Stripe の登録が可能になっていました。OpenCollective の資金は使わないのかPrettier は OpenCollective での支援を受け付けており、現在 $45,000 以上の資金が集まっています。https://opencollective.com/prettierこの資金の使い方について Prettier Team (過去の貢献者も含むコミュニティ)で議論されていたのですが、誰も興味がないのか、話がほとんど進みませんでした。(一応、何人かの貢献者に対して $1,000 ずつ分配されました。)おそらく、この議論にもっとも興味がある人間の一人は現在のアクティブメンテナーである私ですが、英語でお金について議論をするのが困難で諦めていまいました。しかし、せっかく $45,000 以上の支援をいただいているのに使わないのはもったいないので、もう一度話をしてみようと思っています。スポンサー特典はあるのか特にありませんが、私のモチベーションが高まり、Prettier のメンテナンスが継続されやすくなります。","link":"https://sosukesuzuki.dev/posts/github-sponsors/","isoDate":"2021-09-22T00:00:00.000Z","dateMiliSeconds":1632268800000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Prettier デバッグオプション","contentSnippet":"Prettier をデバッグするための CLI オプションを３つ紹介します。次のような JavaScript のコードを test.js として保存している前提です。test.js// hiconst foo = \"foo\"; --debug-print-docフォーマット結果の代わりに、Doc を表示します。./bin/prettier.js test.js --debug-print-doc[  \"// hi\",  hardline,  group([    \"const\",    \" \",    group([group(\"foo\"), \" =\"...","link":"https://zenn.dev/sosukesuzuki/articles/c00306f4630c60","isoDate":"2021-09-16T05:29:44.000Z","dateMiliSeconds":1631770184000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript の Class Static Blocks について","contentSnippet":"この記事では現在 Stage 3 の Class Static Blocks について解説する。なお、まだ現時点で Stage 3 であるため実装状況や細かい仕様は今後変更される可能性がある。概要Class Static Blocks プロポーザルは、クラス内でスタティックなメンバにアクセスできるブロックの構文を導入する。次のコードの static { から始まるブロックが新たに導入される構文である。このとき、スタティックブロック内のthis.fooはスタティックなメンバである。class C {  static foo;  static {    this.foo = \"foo\";  }}スタティックブロックはクラスCが評価されるタイミングで実行される即時実行関数のようなものと見ることもできる。また、クラスは複数のスタティックブロックを持つことができ、その場合は上から順に実行される。モチベーション2021年4月のTC39ミーティングで Static Class Features というプロポーザルが Stage 4 になった。Static Class Features は、次のようにスタティックなメンバをクラス内に列挙して定義するための構文を導入する。class C {  static foo = \"foo\";}このとき、C.foo は \"foo\" である。この Static Class Features の構文によって容易にクラスのスタティックなメンバを定義できるようになった。しかし、JavaScript の制御構文のほとんどは文である。そのため、Static Class Features の構文のみでは、複雑な計算の結果をスティックメンバの初期値として設定するのは難しい。たとえば、典型的な例として try catch について考えてみよう。try catch を使って次のような処理を記述したいとする。try 内でなんらかの計算をする計算が成功した場合はその結果をクラスCのスタティックメンバfooに入れる計算が失敗した場合はフォールバックの値をクラスCのスタティックメンバfooに入れるこのような場合に Static Class Features の機能だけではクラス内に書くことができない。class C {  static foo;}try {  const result = calculate();  C.foo = result;} catch {  C.foo = -1;}ここで Class Static Blocks を使うと次のようにクラス内に書くことができる。class C {  static foo;  static {    try {      const result = calculate();      this.foo = result;    } catch {      this.foo = -1;    }  }}また、Class Static Blocks はクラス内に閉じているためプライベートなメンバにもアクセスできる。let getFooOfC;let writeFooOfC;class C {  #foo;  constructor(foo) {    this.#foo = foo;  }  static {    getFooOfC = (c) => c.#foo;    writeFooOfC = (c, v) => { c.#foo = v; }  }}const c = new C(\"private value\");getFooOfC(c); // -> \"private value\"writeFooOfC(c, \"updated private value\");getFooOfC(c); // -> \"updated private value\"TypeScript 4.4実は Class Static Blocks は、先日ベータ版が公開された TypeScript 4.4 に実装される予定である。公式のベータ版アナウンス記事では Class Static Blocks についての言及がなかったので気づかなかった人も多いのではないだろうか。実際に TypeScript の Playground で試してみることもできる(Playground link)。ref: https://devblogs.microsoft.com/typescript/announcing-typescript-4-4-beta/ref: https://github.com/microsoft/TypeScript/pull/43370ref: https://twitter.com/robpalmer2/status/1410855524770406403おわりに現代のフロントエンド開発ではそもそもクラスを使う機会が少なくなっているように感じる。そのため、Class Static Blocks が使えるようになっても実際に使うウェブ開発者はそこまで多くないだろう。しかしながら、ライブラリ開発などには役に立つ可能性が高いので、覚えておくとよいだろう。","link":"https://sosukesuzuki.dev/posts/stage-3-class-static-blocks/","isoDate":"2021-07-06T00:00:00.000Z","dateMiliSeconds":1625529600000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript の Object.hasOwn について","contentSnippet":"この記事では、現在 Stage 3 の Object.hasOwn プロポーザルの概要や、経緯について解説する。プロポーザルの詳細については https://github.com/tc39/proposal-accessible-object-hasownproperty を参照してほしい。また Object.hasOwn は現在 Stage 3 であり、細かい仕様については今後更新される可能性がある。概要Object.hasOwn プロポーザルは、Object.hasOwn という新しいメソッドを導入する。Object.hasOwn メソッドは、Object.prototype.hasOwnProperty()をObjectのスタティックメソッドにしたものだ。つまり、次の２つのプログラムは同じ挙動になる。let hasOwnProperty = Object.prototype.hasOwnProperty;if (hasOwnProperty.call(object, \"foo\")) {  console.log(\"has property foo\");}if (Object.hasOwn(object, \"foo\")) {  console.log(\"has property foo\");}経緯とモチベーションObject.prototype.hasOwnProperty は使ったことがあるだろう。たとえば、for in 等でオブジェクトのプロパティを走査するときに意図しないものを参照しないために使うことがある。たとえば次のようなコードを考える。const foo = { prop1: 1 };for (const prop in foo) {  console.log(prop);}このようなコードを書いたとき、多くの場合 prop1 が表示されることを期待するだろう。実際、これをそのまま実行すれば prop1 と表示される。しかしこのコードより前に、次のような Object.prototype を変更するようなコードがあった場合、結果が変わってしまう。Object.prototype.prop2 = 2;const foo = { prop1: 1 };for (const prop in foo) {  console.log(prop);}これを実行すると、次のようにprop2も表示される。prop1prop2「そんなコード書かないよ」という人もいるだろう。しかし、依存の奥深くのライブラリに Object.prototype を更新するコードが入っていたらどうだろうか。そのような懸念から、for in を使う場合にはObject.prototype.hasOwnProperty 等を使ってガードすることが多い。Object.prototype.hasOwnPropertyを使えば、プロトタイプをさかのぼることなく、そのオブジェクトに特定のプロパティが存在するかどうかを確かめることができる。なので、次のようにhasOwnPropertyを使うことで、継承されているprop2を除いてfooに存在するprop1だけを表示できる。Object.prototype.prop2 = 2;const foo = { prop1: 1 };for (const prop in foo) {  if (foo.hasOwnProperty(prop)) {    console.log(prop);  }}しかし、実際にはfooに必ずhasOwnPropertyが存在するという保証はない。なぜなら、hasOwnProperty自体を上書きできるからだ。Object.prototype.prop2 = 2;const foo = {  prop1: 1,  hasOwnProperty: () => true,};for (const prop in foo) {  if (foo.hasOwnProperty(prop)) {    console.log(prop);  }}このコードを実行すると、次のように継承されたprop2も表示されてしまう。prop1hasOwnPropertyprop2また、たとえばObject.create(null)で生成されたオブジェクトにはhasOwnPropertyが存在しない。Object.create(null).hasOwnProperty(\"foo\");// Uncaught TypeError: Object.create(...).hasOwnProperty is not a functionこのようなことを避けるため多くの場合次のようにして、必ず Object.prototype.hasOwnProperty を参照するパターンがよく使われている。Object.prototype.hasOwnProperty.call(foo, key);{}.hasOwnProperty.call(foo, key);ESLint にはそれを強制するためのルールが存在する（ 参照: https://eslint.org/docs/rules/guard-for-in ）。このパターンはよく知られており、ESLint のルールの存在もあって浸透しているよう。しかし、記述量が多くなる上に直感的でない。Function.prototype.callや、現在ではあまり使われなくなったプロトタイプについての理解が求められる。そのため、JavaScript 初心者にとってはややハードルが高いように感じる。そこで、Objectのスタティックメソッドとして同等の機能を実装することで、使いやすくしようというのが Object.hasOwn プロポーザルの目的である。命名について実はObject.hasOwn はもともと Object.has という名前で提案されていた。しかし、Object.has という名前ではプロトタイプをさかのぼる挙動が想像されるということから改名されることになった。JavaScript には Reflect というトップレベルのオブジェクトが存在する。そして、Reflect には Object と同じようなセマンティクスを持つスタティックメソッドがいくつか存在している。さらに Reflect には Reflect.has というスタティックメソッドが存在する。Reflect.has は in 演算子と同じようなセマンティクスを持ち、つまりプロトタイプをさかのぼってプロパティの有無をチェックする。なので、JavaScript プログラマーが次のように推測してしまう可能性が高い。Reflect と Object には似たセマンティクスのメソッドがいくつか存在する。Reflect には has というスタティックメソッドが存在する。ならば、Object.has も Reflect.has と同じようにプロトタイプをさかのぼるだろう。このような懸念から、Object.has ではなく Object.hasOwn という名前に変更された。この改名に関する議論は以下のリンクを参照してほしい。https://github.com/tc39/proposal-accessible-object-hasownproperty/issues/3https://github.com/tc39/notes/blob/master/meetings/2021-04/apr-20.md#objecthas-for-stage-1提案の進化の速さプロポーザルにとって本質的なことではないが、このプロポーザルは異様な速さで Stage を進んでいる。2021 年 4 月の TC39 のミーティングで初めて議題にあがり、そのミーティング内で Stage 1 を飛ばしていきなり Stage 2 になった。そして、2021 年 5 月の TC39 ミーティングでは Stage 3 になった。現在 V8 と SpiderMonkery ではすでにフラグ付きで実装されている。2021 年 7 月のミーティングでも、\"Accessible Object hasOwnProperty update\" として議題にあがる予定だ。このままいけば ES2022 に入る可能性もあるだろう。おわりに筆者自身、数年前に JavaScript を始めたころは Object.prototype.hasOwnProperty.call を使ったコードを見て困惑した記憶がある。なので、よく使われるこのパターンが言語に入ってくれるのは喜ばしいことだと考えている。また、Stage を駆け上がっていく様を見るのも楽しいので、今後も注目しておきたいプロポーザルの1つである。","link":"https://sosukesuzuki.dev/posts/stage-3-object-hasown/","isoDate":"2021-07-02T00:00:00.000Z","dateMiliSeconds":1625184000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Node.js の import.meta.resolve について","contentSnippet":"先日 import.meta について調査して人に話す機会があり HTML(Web) と Node.js の各ホストの import.meta がどのようなオブジェクトを返すのかを調査していた。そのときは、「HTML でも Node.js でも import.meta.url だけが生えていて〜〜」という話をしてしまった。後になって知ったのだが、Node.js には import.meta.url 以外にも import.meta.resolve というプロパティが実装されている。この記事では Node.js に実装されている import.meta.resolve について解説する。なお、import.meta.url はまだ Stability 1 の API なので、今後仕様が変わる可能性があることに注意してほしい。import.meta についてまず import.meta について軽く触れておこうと思う。import.meta については知っているよという人は飛ばしてほしい。import.meta は ECMAScript 2020 から入った機能で、現在実行中のモジュールに対してホスト固有のメタデータをオブジェクトとして提供する(現在は ECMAScript に入っているのでリポジトリはアーカイブされているが、プロポーザルは https://github.com/tc39/proposal-import-meta にある)。大事なルールとして、import.meta はモジュールに対してのみ機能するのでスクリプトの環境では使うことができない。そして、import.metaは現在の ECMAScript には２つしかない Meta Property と呼ばれる構文の１つである(ref: https://tc39.es/ecma262/#prod-MetaProperty)。import.meta は、ECMAScript の範囲内ではそれがオブジェクトであるということしか決まっていない。なので、実際にどのようなメタデータをモジュールに対して提供するかはホストの実装者に委ねられている。現在 HTML と Node.js の両方に実装されているのが import.meta.url である。これは現在実行中のモジュールの URL を表す。HTML では http スキームだが、Node.js では file スキームの URL になる。Node.js の import.meta.urlNode.js では import.meta.url はよく使われるだろう。Node.js 10 が EOL となった今、Node.js でも ECMAScript Modules を使ったプログラムを書くことが増えてきた。ECMAScript Modules では、今まで Node.js のプログラム内でよく使われてきた__filenameや__dirnameを使うことができない。そこでimport.meta.urlを使うことでそれに相当する値を簡単に作ることができる。import url from \"node:url\";import path from \"node:path\";const __filename = url.fileURLToPath(import.meta.url);const __dirname = path.dirname(url.fileURLToPath(import.meta.url));また、Node.js の module モジュールには CommonJS Modules での require に相当する関数を作るための関数 createRequire が実装されている。createRequire の引数にimport.meta.urlを渡すことでrequire関数を取得するのもよくあるパターンだと思う。import module from \"node:module\";const require = module.createRequire(import.meta.url);Node.js の import.meta.resolve実は Node.js には import.meta.url の他に import.meta.resolve というプロパティが実装されている。ECMAScript Modules 界隈では有名な Guy Bedford による https://github.com/nodejs/node/pull/31032 によって実装されたようで、この Pull Request は 2019 年の 12 月に作成されている。ドキュメントは https://nodejs.org/api/esm.html#esm_import_meta_resolve_specifier_parent にある。import.meta.resolve は CommonJS Modules でいう require.resolve に相当する関数である。つまり、モジュールの specifier を引数に渡すと、そのモジュールの URL が返ってくる。ECMAScript Modules でのモジュール解決は非同期に行われるため、import.meta.resolveの返り値は Promise になっている。また、import.meta.resolveは現在 Stability 1 の experimental な API なので、実行するには--experimental-import-meta-resolveオプションをつける必要がある。// index.jsconst lodashUrl = await import.meta.resolve(\"lodash\");console.log({ lodashUrl });node --experimental-import-meta-resolve ./index.js{  lodashUrl: 'file:///Users/hoge/development/import-meta-resolve-example/node_modules/lodash/lodash.js'}import.meta.resolveにはオプショナルな第二引数が存在し、解決元となるファイルの絶対パス URL を指定できる。デフォルトではimport.meta.urlが指定されている。つまり、デフォルトではimport.meta.resolveが実行されるファイルの URL が指定されている。この第二引数を使うことで現在実行中ではないファイルをもとに解決されたモジュールの URL を取得できる。たとえば、次のようなディレクトリ構造があるとする。.├── pkg1│   ├── index.js│   └── package.json└── pkg2    ├── index.js    ├── node_modules    │   └── lodash    ├── package-lock.json    └── package.jsonこのとき、pkg1/index.js から pkg2 の lodash の URL を取得する場合、次のように import.meta.resolve を使うことができる。// ./pkg1/index.jsconst lodashUrlFromPkg2 = await import.meta.resolve(  \"lodash\",  \"file:///Users/foo/import-meta-resolve-examples/pkg2/index.js\");console.log({ lodashUrlFromPkg2 });node --experimental-import-meta-resolve ./pkg1/index.js{  lodashUrlFromPkg2: 'file:///Users/foo/import-meta-resolve-examples/pkg2/node_modules/lodash/lodash.js'}おわりに自分はまだあまり Node.js の ECMAScript Modules で複雑なプログラムを書いたことがなく、この機能を知らなかった。しかし、今後様々なパッケージが ECMAScript Modules で書かれていくことを考えると、import.meta.resolve も安定に向かっていくのだろう。","link":"https://sosukesuzuki.dev/posts/nodejs-import-meta-resolve/","isoDate":"2021-05-23T00:00:00.000Z","dateMiliSeconds":1621728000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript にイミュータブルな配列操作メソッドを導入するプロポーザルについて","contentSnippet":"この記事では、現在 Stage 1 のプロポーザル Change Array by copy について解説する。プロポーザルの詳細については、https://github.com/tc39/proposal-change-array-by-copy を参照してほしい。また、ここで紹介した仕様に関しては今後更新されていく可能性がある。概要Change Array by copy は、簡単にいえばイミュータブルな配列操作メソッドを導入するプロポーザルである。JavaScript の配列には多くのインスタンスメソッドがあり、それらを使って配列を操作できる。配列のインスタンスメソッドには、ミュータブルなもの、つまりもとの配列を変更することによって配列を操作するタイプのものがいくつかある。たとえば、Array.prototype.push や Array.prototype.pop、Array.prototype.reverseなどはミュータブルなメソッドである。// もとの配列を破壊する例const array1 = [1, 2, 3, 4, 5];array1.push(6);console.log(array1); // [1, 2, 3, 4, 5, 6]const array2 = [1, 2, 3, 4, 5];array2.pop();console.log(array.2); // [1, 2, 3, 4]const array3 = [1, 2, 3, 4, 5];array3.reverse();console.log(array3); // [5, 4, 3, 2, 1]Change Array by copy プロポーザルは、これらのミュータブルなメソッドたちに対して、同じような操作をするためのイミュータブルなメソッドを導入する具体的には、次の 10 個のインスタンスメソッドを導入する。Array.prototype.filled(value, start, end) -> ArrayArray.prototype.copiedWithin(copiedTarget, start, end) -> ArrayArray.prototype.popped() -> ArrayArray.prototype.pushed(values...) -> ArrayArray.prototype.reversed() -> ArrayArray.prototype.shifted() -> ArrayArray.prototype.sorted(compareFn) -> ArrayArray.prototype.spliced(start, deleteCount, ...items) -> ArrayArray.prototype.unshifted(...values) -> ArrayArray.prototype.with(index, value) -> Arrayまた、ArrayのみではなくTypedArrayについても同様のメソッドたちを導入する。みればわかるとおりこれらのメソッドは、基本的には既存のミュータブルなメソッドの名前を過去形(というより意図されているのはおそらく過去分詞系)にした名前になっている。モチベーション根本的にミュータブルな配列操作というのは扱いが難しい。ある配列が現在どのような状態であるのかを把握するのが難しくなってしまう。たとえば、定数として扱いたい値を配列として確保する例を考える。const USER_NAMES = [\"Suzuki Sosuke\", \"Javascript Taro\", \"Ecmascript Hanako\"];このUSER_NAMESをアルファベット順にソートして関数someOperationに渡したい。// 整列済みの配列を引数に受け取るなんらかの操作someOperation(USER_NAMES.sort());このように関数に渡してしまうことがあるだろう。しかし、Array.prototype.sortは整列された新しい配列を返すだけではなく、もとの配列も変更してしまう。つまり、上記のsomeOperation実行後はUSER_NAMESという配列自体がソートされたものになってしまう。someOperation(USER_NAMES.sort());console.log(USER_NAMES); // [\"Ecmascript Hanako\", \"Javascript Taro\", \"Suzuki Sosuke\"]これはそのあとのプログラムで想定外の挙動を引き起こす可能性がある。そういったことを防ぐ手段がいくつかある。Object.freeze を使って配列を凍結する。Object.freezeで配列を凍結すれば、ミュータブルなメソッドをそもそも使うことができなくなる(むりやり使うと実行時エラーになる)。TypeScript を使っている場合USER_NAMESの定義の時点でas constをつける。as constをつければその配列は型上は凍結されたようなものとして扱われ、ミュータブルなメソッドを使うとコンパイルエラーになる。そのうえで、もとの配列を変更することなく整列済みの配列を手に入れる必要がある。たとえばArray.prototype.sortをそのまま使ったり、someOperationを呼び出すときにスプレッド構文等でコピーしてからソートしたり、lodash 等のライブラリを使用することが考えられるが、いずれも面倒くさい。ここで Change array by copy によって導入されるArray.prototype.sortedを使うことで、安全かつ簡単に配列をソートできる。// USER_NAMES は変更されないsomeOperation(USER_NAMES.sorted());ほかにも様々なケースが考えられる。ある程度 JavaScript を書いたことがあるひとなら、イミュータブルな配列操作メソッドがほしくなったことがあるだろう。経緯Change Array by copy プロポーザルが生まれた経緯には、現在 Stage 2 の Records and Tuples という別のプロポーザルが関係している。Records and Tuples は簡単にいえば、イミュータブルなオブジェクトと配列のようなデータ構造である Record と Tuple を導入するプロポーザルである。次のような構文で Record と Tuple を作ることができる。const record = #{ x: \"x\" };const tuple = #[1, 2, 3];Records and Tuples は 2019 年ごろから議論されていた提案であり、当初から「Record と Tuple に対して記述したコードはオブジェクトと配列に対しても同じように動作するべき」という方針があった。しかし、最近になって配列と Tuple の挙動の一貫性について調査したところ、Tuple.prototype にあって Array.prototype にはないインスタンスメソッドが存在することに気づいたらしい。それが pushedやpoppedやrevesedのようなイミュータブルなメソッドたちである。当初の方針にしたがうと、Tuple に対して記述したコードを配列に対しても動作させるために、配列にも同様のインスタンスメソッドを導入するべきというということになる。もともとは、それらのメソッドの仕様策定は Records and Tuples 提案の中に行うという考えもあったようだ。しかし、そういったイミュータブルな操作というのは一般的に Tuple だけではなく配列に対して実装されていても有益であるという判断がされたため、Records and Tuples とは異なる別のプロポーザルとして提案されるとことになった。その判断が行われたのが 2021 年 3 月のミーティングであり、実際にこの Change Array by copy プロポーザルが提案されたのが 2021 年 4 月のミーティングである。Tuple のために仕様が決まっていたとはいえ、かなりのスピードでミーティングまでいったことになる。ちなみに、該当するミーティングの議事は https://github.com/tc39/notes/blob/master/meetings/2021-03/mar-9.md#records-and-tuples-update に公開されている。おわりにChange Array by copy プロポーザルはわかりやすく実用的な機能であり、個人的にも ECMAScript に入るのが待ち遠しい。","link":"https://sosukesuzuki.dev/posts/change-array-by-copy/","isoDate":"2021-05-02T00:00:00.000Z","dateMiliSeconds":1619913600000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript の Symbols as WeakMap keys について","contentSnippet":"この記事では現在 Stage 2 の Symbols as WeakMap keys 提案について解説する。プロポーザルの詳細についてはtc39/proposal-symbols-as-weakmap-keysを参照してほしい。また、ここで紹介した仕様に関しては今後更新されていく可能性がある。概要Symbols as WeakMap keys は、WeakMap のキーとしてシンボルを使えるようにするための提案である。現在の WeakMap では、キーとしてオブジェクトのみを使用できる。const weak = new WeakMap();const key = {};const value = \"\";weak.set(key, value);たとえば、キーとして数字や文字列などのプリミティブな値を使用すると実行時エラーが発生する。const weak = new WeakMap();const key = 3;const value = \"\";weak.set(key, value); // Uncaught TypeError: Invalid value used as weak map keyJavaScript のシンボルは数字や文字列と同様にプリミティブな値なので、現在の仕様では WeakMap のキーとして使うことができない。const weak = new WeakMap();const key = Symbol(\"key\");const value = \"\";weak.set(key, value); // Uncaught TypeError: Invalid value used as weak map keyモチベーションシンボルは WeakMap のキーに必要な性質を満たすそもそも WeakMap は GC 可能なユニークな値をキーとして扱いたいだけなので、シンボルをキーとして使用できても問題がない、ということらしい。現在の WeakMap がオブジェクトをキーとして扱うようになっているのも、オブジェクトがユニークかつ GC によって不要になったら回収されるからである。{} === {}; // falseシンボルもユニークであり、不要になったら GC によって回収されるのでこの性質を満たす。Symbol(\"foo\") === Symbol(\"foo\"); // falseシンボルを WeakMap のキーとして扱えると人間にわかりやすい単純に、シンボルを WeakMap のキーとして使えると人間にとってわかりやすい。Records and Tuples の制限のためRecords and Tuples という現在 Stage 2 の提案がある。Records and Tuples プロポーザルは Record と Tuple という新しい２つのデータ構造を導入する。これはかんたんに説明すると、それぞれイミュータブルなオブジェクトと配列である。Record と Tuple の構文は、ぞれぞれオブジェクトリテラルと配列リテラルの先頭に#をつけたものになっている。const record = #{ x: 1, y: 2 };const tuple = #[1, 2, 3];このときrecordとtupleの中身はイミュータブルになっており、あとから変更することはできない。そして Record と Tuple には、プリミティブな値もしくは Record と Tuple しかプロパティの値として持てないという制約がある。つまり、Record と Tuple の中にはイミュータブルな値しかいれることしかできないということである。これはイミュータブルなデータ構造を導入する以上妥当な制約であり、むしろこの制約が存在しなかった場合、イミュータブルと呼ぶことはできないだろう。しかし、Record や Tuple は関数をプロパティの値として持つことができないということでもある。// 関数はオブジェクトであり、Recordはオブジェクトを持てないのでこれはできないconst record = #{  func: () => {    console.log(\"foo\");  },};これが不便だというのは、容易に想像ができるだろう。この制限を保ったまま、擬似的に Record や Tuple に関数を保持させるために、Symbols as WeakMap keys を使用できる。シンボルはあくまでイミュータブルなプリミティブな値であるため、Record と Tuple は他のプリミティブな値と同様にシンボルくをプロパティの値として持つことができる。// シンボルはプリミティブな値なので Record はプロパティの値としてシンボル持つことができる。const record = #{ x: Symbol(\"foo\") };つまり、Record にはシンボルをもたせておき、そのシンボルを使って WeakMap から関数を取得するようなことは可能なのだ。const weak = new WeakMap();const key = Symbol(\"function key\");weak.set(key, () => {  console.log(\"HI!!\");});const record = #{ x: key };weak.get(record.x)(); // HI!!そしてこの操作をよりかんたんにするためのラッパーを書くことができる。class RefBookkeeper {  #references = new WeakMap();  ref(obj) {    const sym = Symbol();    this.#references.set(sym, obj);    return sym;  }  deref(sym) {    return this.#references.get(sym);  }}const refs = new RefBookkeeper();const record = #{  x: refs.ref(() => {    console.log(\"HI!!\");  }),};refs.deref(record.x)(); // HI!!現在の懸念点well-known な Symbol も WeakMap のキーとして使えるようにするのか？JavaScript には、well-known なシンボルと呼ばれる特別なシンボルがいくつかある。Symbol.iteratorは使ったことがある人もいるのではないだろうか。その他のものについては、 https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Symbol#static_properties や https://tc39.es/ecma262/#sec-well-known-symbols などをを参照してほしい。このようなシンボルを WeakMap のキーとして許容するかどうかは TC39 のメンバーの中でも意見が割れているようだ。現在は、許容することも禁止することも現実的な選択肢として考えられている。グローバルシンボルレジストリに登録されたシンボルも WeakMap のキーとして使えるようにするのか？SymbolにはSymbol.forとSymbol.keyForという２つの静的メソッドが存在する。これらのメソッドは、グローバルシンボルレジストリに関連するものである。グローバルシンボルレジストリは、その名の通り、グローバルにシンボルが登録される場所である。普通にシンボルを作成した場合はグローバルシンボルレジストリには登録されない。// グローバルシンボルレジストリには登録されないconst sym = Symbol(\"sym\");Symbol.forを使うことで、グローバルシンボルレジストリにシンボルを登録できる。// グローバルシンボルレジストリに登録される。const sym = Symbol.for(\"sym\");Symbol.forは、引数として key と呼ばれる文字列を受け取り、グローバルシンボルレジストリから key にマッチするシンボルを検索し、存在した場合そのシンボルを返し、存在しない場合は新しく key を使ってグローバルシンボルレジストリに新しいシンボルを作成し、そのシンボルを返す。// まだグローバルシンボルレジストリに、key `sym` に対応するシンボルが存在しないため、// 新しくグローバルシンボルレジストリにシンボルを作成し、そのシンボルを返すconst sym1 = Symbol.for(\"sym\");// すでにグローバルシンボルレジストリに key `sym` に対応するシンボルが存在するため、// そのシンボルを返すconst sym2 = Symbol.for(\"sym\");console.log(sym1 === sym2); // true;もう1つの静的メソッドであるSymbol.keyForは、Symbol.forとは逆にシンボルを引数として受け取り、そのシンボルに対応するキーの文字列を返す。const sym1 = Symbol.for(\"sym\");console.log(Symbol.keyFor(sym1)); // symつまり、これらの静的メソッドを使えばどこからでも取得可能なシンボルを作成できる。このようなシンボルを WeakMap のキーとして許容するのかというのが論点である。WeakRef 等でも同様にシンボルをサポートするのか？WeakRef や WeakSet、FinalizationRegistry 等の弱参照に関係するその他のデータ構造でも同様にシンボルをサポートするかどうかについては、それをすることもできるししないこともできるということらしい。今の所明確なユースケースは存在しないが、WeakMap のキーとしてシンボルを追加することと一貫させるためにそのような仕様の修正が行われることはあるのかもしれない。おわりに提案のタイトルからわかりやすい仕様ではあるが、細かい部分でまだ決まりきっていないところもあるので引き続き議論を追っていきたい。また、Prettier や Babel などの開発では実際にこの仕様を使うようなシーンもありそうなので頭に入れておきたい。","link":"https://sosukesuzuki.dev/posts/symbols-as-weakmap-keys/","isoDate":"2021-04-28T00:00:00.000Z","dateMiliSeconds":1619568000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"20 歳になった","contentSnippet":"2001 年 03 月 01 日に生まれたので、昨日 2021 年 03 月 01 日に 20 歳になりました。もしプレゼントをくれる方がいればこちらのほしいものリストからお願いします。https://www.amazon.jp/hz/wishlist/ls/2VMKXAI8J8278?ref_=wl_shareサイボウズフロントエンドエキスパートチームは毎月フロントエンドマンスリーという配信イベントをやっていて、自分もそれに出演しているんですが、配信終了後チームメンバーから誕生日を祝ってもらえて嬉しかったです。終わって @__sosukesuzuki の誕生日をお祝いした#サイボウズフロントエンドマンスリー— Sakito (@__sakito__) March 2, 2021 20 歳というのはなんとなく人生の節目っぽいので、現在の気持ちについて書きます。5 年後とかに今書いたこの文章を見て自分がどう感じるのか気になります。今のところソフトウェア開発者としてある程度まともになってきてはいるのかなーという感覚はあって、仕事とか OSS とかちょっとずつだけどやれているのでそのへんは良かったかなと思っています。これに関しては 10 代後半くらいからの出会いに恵まれた + 好きなことをやらせてくれる両親がいたのが本当に大きかったと思っていて、自分と関わってくれた色々な人にとても強く感謝しています。自分は(少なくとも今は)プログラミングが好きだし楽しいので、技術的なことに関しては正直あまり大きな心配はしていません。現状に満足しているわけじゃないんですが、勉強することもコードを書くことも人との会話も楽しいので、それらを今後も継続できると思っています。プログラミングや会話が楽しくなくなってきたら焦ると思います。ただプログラミング以外のスキルや素養については大いに心配しています。お金のこととかキャリアのこととか様々なライフイベントとかそういうことについて考えられていないし知識も乏しいです。少なくとも法律の上では大人と言われる年齢になってしまったので、そういうことをちゃんと勉強したり考えたりする必要があるんだろうなと漠然と思っています。やる気は全然湧いてきません。そしてお酒が飲めるようになったので誰かお酒を飲みに行きましょう(こんなご時世ですのでいけるようになったらですが)。","link":"https://sosukesuzuki.dev/posts/20-years-old/","isoDate":"2021-03-02T00:00:00.000Z","dateMiliSeconds":1614643200000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript の Module Fragments について","contentSnippet":"現在 TC39 の 3 月のミーティングのアジェンダが GitHub にて公開されている(Link)。それによると、Module Frangments という新しいプロポーザルが@littledan氏によって提案される予定だ。この記事では、現在の Module Frangments の概要とモチベーション、構文について解説する。もしさらなる詳細に興味がある場合は https://github.com/littledan/proposal-module-fragments を読んでほしい。また、Module Fragments は現在 Stage 0 の提案であり、今後仕様が大きく変わっていくことが予想されるのでその点には注意してほしい。概要Module Fragments はインラインで JavaScript のモジュールを定義するための構文を導入する提案である。詳細は後述するが、次のような構文を用いて1つのファイル内に複数のモジュールを定義し、import できる。// filename: app.jsmodule \"#count\" {  let i = 0;  export function count() {    i++;    return i;  }}module \"#uppercase\" {  export function uppercase(string) {    return string.toUpperCase();  }}import { count } from \"#count\";import { uppercase } from \"#uppercase\";console.log(count()); // 1console.log(uppercase(\"daniel\")); // \"DANIEL\"module ~~ からのブロックが Module Fragments が導入する構文だ。moduleキーワードのあとにモジュール指定子を置き、そのあとにブロックを配置することでモジュールとして扱うことができる。そして、import宣言のモジュール指定子として使うことで定義したモジュールを import できる。モチベーションModule Fragments は主に webpack や Rollup や Parcel などのモジュールバンドラーの出力として使われることを想定している。現在では多くの開発者が ECMAScript Modules(ESM) を使って開発を行っている。数年前まではウェブブラウザがモジュールシステムを解釈できなかったため、モジュールバンドラーを使ってモジュールシステムをエミュレートして単一(もしくは複数)の JavaScript ファイルを出力するのがウェブ開発の主流になった。しかし多くのウェブブラウザが ESM を実装した現在でも、読み込み時のコストなどの実行効率の懸念からモジュールバンドラーが広く使われている。しかしながら、モジュールバンドラーは ESM のセマンティクスを完全にエミュレートする必要があるため、その実装がかなり複雑になってしまう。また、ESM に関連する仕様はこれからも増えていくことが予想される。たとえば、top-level awaitやImport Assertionsなどのモジュールに関する仕様が ECMAScript に追加されるたびに各モジュールバンドラーはそれらをエミュレートするための実装を行う必要がある。さらに V8 や JavaScriptCore などの実際にウェブブラウザなどで動作する JavaScript エンジンは、バンドルされたあとのコードを実行することになるので開発者が記述したままのモジュール構造を見ることができない。そのためモジュールの構造を利用した最適化ができずパフォーマンスに悪影響を及ぼすことがある。Module Fragments は実行時のオーバーヘッドが低いためバンドラーの出力として使うことができ、以前に比べてモジュールバンドラーがエミュレートするべきモジュールの仕様を減らすことができる。また、モジュールバンドラーはモジュールの構造をそのまま吐き出すことができるようになるので、JavaScript エンジンはその構造を見ることができるようになる。構文Module Fragments では import ステートメントや export ステートメントのようなモジュールのトップレベルに配置できる新しい非終端記号を導入する。ECMAScript の仕様で言えばModule Itemに新しいステートメントが追加されるということになる。module \"#m\" {}また Module Fragments をネストすることはできず、必ずトップレベルで宣言する必要がある。// NGmodule \"#m1\" {  module \"#m2\" {}}ECMAScript のプロポーザルについて調べたことがある人なら、Module Blocksという現在 Stage 2 のプロポーザルで提案されている構文と似ていることに気がつくかもしれない。Module Fragments も Module Blocks もmoduleというキーワードを使うが、Module Blocks ではモジュール指定子を指定せずにmoduleの後にすぐ{がくるので構文的に衝突することはない。// Module Blocksconst m = module {};// Module Fragmentsmodule \"#m\" {}Module Fragments が実行されるランタイムがブラウザの場合、module キーワードのあとに続くモジュール指定子を表す文字列は # から始まる URL フラグメントで使える文字列である必要がある(つまり ASCII 文字列)。この指定子を使って絶対または相対 URL として Module Fragments で定義されたモジュールを import できる。// In https://example.com/bundle.jsmodule \"#counts\" {  let i = 0;  export function count() {    i++;    return i;  }}import { count } from \"https://example.com/bundle.js#counts\";なおこれは ECMAScript の仕様ではなくブラウザに限定された規則である。そのため、例えば Node.js や Deno などの別のホストがこれに従う必要はない。しかし、それらのホストでも必要に応じてこの規則に従うことが推奨されている。おわりに筆者がこの提案を見たときは Module Blocks と構文上の類似点が気になったが、この 2 つは全く異なるモチベーションで提案された提案である。Module Blocks は、Worker コンストラクタなどにそのままモジュールを渡すことで Web Workers などの利便性を向上させるなどの目的があるが、Module Fragments はバンドルのチューニングの目的で使われることになるのだろう。そのため一般のウェブアプリケーション開発者が直接 Module Fragments を使うことは少ないように思うが、ライブラリ開発者やウェブアプリケーションのバンドルのチューニングを行う開発者は将来的には把握しておく必要がありそうだ。個人的には、先日提案されたDeferring Module Evaluationや、Module Blocks、そしてこの Module Fragments などモジュールのパフォーマンスや利便性を向上させるための提案が続々と出てきているのは興味深い。ESM 自体が安定して使われるようになってきた今、そのパフォーマンスや利便性が気になるフェーズになってきたということだろうか。","link":"https://sosukesuzuki.dev/posts/stage-0-module-fragments/","isoDate":"2021-02-28T00:00:00.000Z","dateMiliSeconds":1614470400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"はじめて自分で作ったリポジトリを OSS の Organization に移管した","contentSnippet":"過去のブログ記事で紹介した prettier-regression-testing というツールを Prettier Organization に移管した。Prettier のユーザーにとって何かが変わるとかそういうことは全くないのだが、自ら作成したリポジトリを OSS の Organization に移管したのは初めてだった。他のメンテナーにとっても便利だったらしいもともと prettier-regression-testing は自分がリリースするときにリグレッションが発生しないことを確認するのを簡単にするためのツールだった。大規模 Closure Tools プロジェクトに Prettier を導入するまでの道のり - Cybozu Inside Out | サイボウズエンジニアのブログこちらの記事でも紹介したように、Prettier のリリース前リグレッションチェックはすべて手動で行われており面倒だったので、自動化するため prettier-regression-testing を開発した。基本的には自分ひとりで使う想定で開発したが、他のメンテナーたちも使ってくれてより便利にするための PR を投げてくれた。コードが汚すぎたしかし prettier-regression-testing はありえないくらいメンテナビリティの低いコードになっていた。GitHub Actions 上で動作する JavaScript のコードを書くのがはじめてだったため手探りで書きなぐってしまい、結果としてワンファイルの JavaScript で、書いた本人ですら一ヶ月後には読めなくなってしまうようなコードが誕生した。その状態でも PR を投げてくれた他のメンテナーたちの適応力には驚いたが、さすがに「このままではだめだ...」と思い始めた。そんな気持ちを抱えたまま 4 ヶ月が経過し、そしてメンテナーの一人によって CLI で動かすためのかなり大きな PR が作成された。「このまま PR を受け入れてしまってはもう取り返しのつかないことになる」と思ったので、そのメンテナーには「本当に申し訳ないんだけど、週末に TypeScript でこの機能までカバーできるように書き直すから、そのときにレビューをしてほしい」という旨を伝え、週末に本気で書き直した。移管する意外と上手く書き直すことができ、「みんなにとっても便利そうなら、Prettier Organization に移管したいんですがどう？」と尋ねたところ賛成してもらえたので、移管した。移管作業自体は簡単で、GitHub のドキュメントに従って操作したらすぐ終わった。感想と教訓自分が自分のために作ったものが他人にも使ってもらえるというのは嬉しかった。また Prettier Organization のような公式の場所に自分の作ったリポジトリが置かれているのもなんとなく嬉しくなれる。自分しか使わないようなツールでも誰かの役に立つことがあるというのは色々なところで言われていることなので知識としては頭に入っていたが、それを実感できて良かった。今後も自分のためのツールであっても積極的に公開していきたいと思う。そして今回の件から得られた教訓としては、それがたとえ自分のためのものであろうが、長期的に使うかどうかわからないものであろうが、できるだけコードは丁寧に書いた方が良いということだ。こちらも当たり前のことかもしれないが、実際にそれで困ったという経験が得られたのは結果として良かったかもしれない。「丁寧に書く」というのは曖昧で難しいが、Node.js での開発においてはまず TypeScript を使うということと、少なくとも入出力の再現が容易である操作に関してはユニットテストを書いておくというのは意識したほうが良さそうだ。","link":"https://sosukesuzuki.dev/posts/transfer-my-repo-to-oss-org/","isoDate":"2021-02-13T00:00:00.000Z","dateMiliSeconds":1613174400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"2020年 OSS 活動振り返り","contentSnippet":"https://sosuke.dev をブログにしていたんですが、わけあってドメインを失効してしまったのでしばらくの間ははてなブログに書くことになりそうです。2020 年ももうすぐ終わります。今年は OSS の開発に多くの時間を費やしてきた実感があるので、実際どのプロジェクトで何ができて逆に何ができなかったのか振り返り、そして来年はどのように OSS と向き合っていくのか考えていこうと思います。(GitHub Sponsors できない(免許もパスポートもない)ので、僕の活動を応援してくれる人がいたら下のほしいものリストからアマギフを aosukeke[at]gmail.com まで送ってくれるととても嬉しいです)https://www.amazon.jp/hz/wishlist/ls/2VMKXAI8J8278?ref_=wl_share主に関わったプロジェクトずっと JavaScript ツールチェイン系のプロジェクトに関わっていて、主に Prettier と Babel の 2 つの開発に関わっていました。Prettier去年の 9 月にコミット権限をもらってからアクティブに活動をしています。去年から引き続きバグ修正や機能追加など「みんなが求める Prettier」のクォリティを維持するための開発をしています。長く関わっているといろいろと自分の意見が出来てくるもので、様々な決定に関わったりとある程度重要な立場になってきたと感じています。また、アクティブなメンテナーの数は減る一方という状況もあり、 2.1 からはリリースブログとリリースを担当するようになりました。2.1 のリリースのときは大変緊張しましたが、パッチリリース含めて何度かリリースを繰り返す度に慣れてきていて、リリーススクリプトの改善等もできるようになってきました。2020 年のコントリビューションの数を見るとこんな感じです。コードレビューが多いので、コードを書いた数はそんなに多くありません。2020 年のコミットの数を見るとこんな感じです。まあ、そこそこやっているという感じでしょうか。質を劣化させないことは出来たと思うけど、プロジェクトを先に進める開発は全然できなかったなと思います。来年はもう少し大きな開発をやりたいと思っています。Babel9 月末頃から「パーサーの実装が気になって仕方がない！！！」という気持ちが出てきて、Babel のパーサーの実装を読み始めました。そこからバグを見つけ次第コミットしまくっていたら、10 月頃に Org に招待されました。I've joined @babeljs ! pic.twitter.com/Fvp5KsmndB— Sosuke Suzuki (@__sosukesuzuki) October 18, 2020 招待されるまでがかなり早かったように思えますが、Prettier メンテナーとしての活動で Babel と関わることもあったのでそのあたりで認知されていたのも影響しているのかなーと思っています。Babel 側のバグ修正を大量にやった結果、Babel のパーサーに依存している Prettier 側のタスク量がめっちゃ増えたのは大変でしたが「エコシステムを改善しているんだ」という感覚を持ててよかったです。Babel のシンタックスエラー直しまくったら Prettier の方の作業量めっちゃ多くなってびびってる https://t.co/TrUzTaqLMH— Sosuke Suzuki (@__sosukesuzuki) October 15, 2020 最近はバグ修正だけではなくて、新しいプロポーザルの実装なども自らお願いして担当したりしてます。https://zenn.dev/sosukesuzuki/articles/432588a7c8287d2020 年のコントリビューションを見るとこんな感じです。数は全然多くないですね。2020 年のコミット数はこんな感じです。こちらも全然多くはないですね。とはいえ、2020 年に限ればコアチームのメンバーたちの次に多いみたいです。Babel ではまだまだ新人コントリビューターという感じなので、引き続き貢献しつつもっと価値を出していけるようになると良いなと思ってます。あんまり Babel にとって役に立つことはできませんでしたが、得たものは大きかったように思います。Babel の開発をしていると ECMAScript の仕様をちゃんと眺めつつ実装していくことがよくあるので、そういった仕様を読む力がついたと思うし、なにより以前に比べて JavaScript に詳しくなったと感じています。その他のプロジェクトガッツリ時間を使ったのは Prettier と Babel だけでしたが、暇なときにその他にもいくつか自分が使っている OSS にちょこちょこ PR や Issue を出していたような気がするので見てみます。typescript-eslintPrettier が依存していたり Babel の AST との互換性を意識しているのもあってたまにコミットしていたAST の型がキレイについてて開発体験が良いExcalidraw出たばかりの頃に小さなバグをいくつか直したりした最近は全然やってなくてわからないけど、大学の課題で木書くときとかにたまに使ってるDefinitelyTypedPrettier の型定義が壊れがちなのでたまに直したりしていた他のライブラリはほとんどやってないと思うリポジトリが巨大なのであまり好きではないeslint-plugin-vue一時期インターンで Vue を使っていたので新しいルールを追加したりバグを直したりした最近は Vue を使ってないし全然やってないけど一応ウォッチしているmizchi/mdbufMarkdown を書くときに使っているエディタブラウザで動くしシンプルだしそこそこ速いので便利バグを修正したりダークモード追加したりしたこんな感じです。どれも楽しかったです。来年どうしていくのか今年関わったプロジェクトには関わり続けていくつもりです。特に Prettier は自分がいなくなるとちょっとやばそうだし。ただ同じことばっかりやっていても飽きるので、でも JavaScript は好きなので、来年は C++ を勉強して V8 や JavaScriptCore みたいな実用エンジンを読んだりできそうだったら貢献したりしたいなーと思ってます。あと、OSS プロジェクト内で価値を出していくにはやはり英語で議論する力が必要だと感じることも多かったので、コーディングの時間を減らして英語学習に使ったほうがいいかなとも思っています。","link":"https://sosukesuzuki.dev/posts/2020-oss-activity/","isoDate":"2020-12-24T00:00:00.000Z","dateMiliSeconds":1608768000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"JavaScript の Import Assertions について","contentSnippet":"はじめにImport Assertions は現在 Stage 3 の ECMAScript のプロポーザルである。2020 年 9 月に行われた TC39 のミーティングで Stage 3 になった(ミーティングノートは https://github.com/tc39/notes/blob/master/meetings/2020-09/sept-22.md#import-assertions-for-stage-3 にて公開されている)。Babel では 先日リリースされた 7.12 から Import Assertions を使えるようになった。この記事では現時点での Import Assertions について解説する。概要このプロポーザルは従来の import 文 にインラインの構文を追加し、モジュール指定子とは別に詳細情報の指定を可能にする。主に想定される用途は JavaScript 以外のタイプのモジュールのサポートだ。Import Assertions で追加される構文を使って JSON modules を import する例を考える。import json from \"./foo.json\" assert { type: \"json\" };import json from \"./foo.json\" までは従来の import 文と同様の形をとっている。その直後にある assert { type: \"json\" } の部分が Import Assertions で提案されている構文だ。この例では import されるモジュールが JSON modules であることを示している。ちなみに、JSON modules というのは Import Assertions とは別の Stage 2 の ECMAScript のプロポーザルである。もともとは Import Assertions のプロポーザルに含まれていたが、個別のプロポーザルとして分離された。JSON modules は JSON のモジュールとしての扱いを統一することを目的としている。現状では、それぞれの環境(例えば webpack や Node.js など)が JSON のモジュールとしての扱いを自由に実装できる。そこで JSON modules を仕様として定めることで、ECMAScript の仕様の準拠したすべての場所で一貫して動作させることが可能になる。本題とそれてしまうのでここでは JSON modules について詳しく解説はしない。構文まず構文について見ていこう。上述の通り基本的には import 文の後ろに assert というキーワードが続き、更にその後ろに詳細情報をオブジェクトリテラルのように記述する。import json from \"./foo.json\" assert { type: \"json\" };Import Aserttions がこのような中括弧を使った記法を採用したのには2つの理由がある。1つは、JavaScript を使う開発者はすでにオブジェクトリテラルの記法に慣れているため。もう1つは、将来的にassert以外の属性を指定できるようになる可能性があり、その場合に様々な属性に対してグルーピングを行うためである。以下の例を見てほしい。import json from \"./foo.json\" assert { type: \"json\" } with { transformA: \"value\" };この例では、assert { type: \"json\" } の後ろに with { transformA: \"value\" } という他の属性が続いている。このwithという属性は現在の仕様には含まれてはいない。しかし、将来的にこういった他の属性が別の提案として追加されることが想定されている。このとき中括弧を使ったオブジェクトリテラルのような構文によってそれぞれが属性に対応するグループだということがわかる。Import Assertions は import のみではなく export に対しても使うことができる。export { val } from './foo.js' assert { type: \"javascript\" };また、Import Assertions は dynamic import をサポートしている。その場合、関数の第 2 引数にオブジェクトリテラルを渡すようにして指定する。import(\"foo.json\", { assert: { type: \"json\" } });経緯次に、このプロポーザルが生まれたモチベーションや経緯について解説する。当初は、新しい構文を追加することなく JSON をモジュールとして読み込むための、Import Assertion とは異なる仕様として提案されていた。この提案では、次のようにして JSON をモジュールとして import できる。import json from \"./foo.json\";これは多くの非標準の環境での JSON の読み込みと似ている。たとえば、Node.js では --experimental-json-modules フラグをつければ上記のコードをそのまま実行できるはずだ。この提案は多くの開発者からの支持を受けた。その結果、whatwg/html にマージされ、Microsoft によって Chromium に実装された。しかし、あとになってセキュリティ上の問題が指摘された。もとの仕様では、例えば次のようなコードがあるとき通常は JSON が import されることが想像されるだろう。import foo from \"./foo.json\";しかし、宛先のサーバーで MIME タイプが変更されたり、宛先のサーバーが悪意を持った攻撃にさらされたりした場合に意図せずなにかを実行してしまう可能性がある。この問題に対する解決策として Import Assertions が ECMAScript に提案されることになった(当初は Module Attributes という名前だった)。Import Assertions では、import する側が import される側のコンテンツをどのように解析するべきかを指定できるため、そのような問題を防ぐことができる。ちなみに、もとの仕様は現在ではwhatwg/html からリバートされている。おわりに現在 Stage 3 であるため、よほどのことがない限り ECMAScript に正式に含まれることになるだろう。実際、TypeScript や Deno ではすでに実装が検討されている。更に詳細が気になる場合は https://github.com/tc39/proposal-import-assertions を見てほしい。","link":"https://sosukesuzuki.dev/posts/import-assertions/","isoDate":"2020-10-24T00:00:00.000Z","dateMiliSeconds":1603497600000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"9 月の OSS 活動 (Prettier とか Babel とか)","contentSnippet":"以前投稿した7 月と 8 月と 9 月前半の OSS 活動の中で、9 月前半までの記録を含めてしまったが、それ以降もそれなりに活動をしていたので改めて 9 月の OSS 活動として紹介したいと思う。9 月は Prettier のメンテナーとしての活動を続ける傍らで Babel のパーサーの改善も行っていた。Prettier は JavaScript をパースするときにデフォルトでは @babel/parser を使用するので、Babel のパーサーの改善は間接的に Prettier を改善することにもつながる。実際、自分が今月行った改善のおかげでいままで Prettier がフォーマットできなかったコードが一部フォーマットできるようになるので、Babel がリリースされたらテストケースを追加しようと思う。prettier/prettier2.1.2 をリリースした。これは 2.1 で発生したリグレッションの修正のみを含むパッチリリースである。Prettier のようなコードフォーマッターでは、何が破壊的変更なのかという判断が非常に難しいので、厳密に semver を守れている自信はないのだけど、できるだけ semver に従ったバージョニングをしていきたいと思っている。そのため、2.1 で発生したリグレッションの修正以外のコミットはリリースに含めたくなかった。しかしすでにmasterブランチにそういったコミットが入っていたので、手動でpatch-releaseブランチにcherry-pickしてそこからリリースした。ローカルの Git で行う作業が多いリリースは非常に緊張する。I've published @PrettierCode 2.1.2. This version includes some bug fixes. Please see changelog for detail.https://t.co/XoCPFUW6qm— Sosuke Suzuki (@__sosukesuzuki) September 16, 2020 2.1.2 に含まれる以下の変更もほとんど自分が行った。GraphQL: Fix formatting for directives in fields(9116)GraphQL でフィールドに対するディレクティブのインデントが崩れるというバグの修正だが、正直自分は GraphQL 1回も書いたことないので直してみてから有識者に聞いたところ挙動に問題はなさそうとのことだったのでマージした。Fix line breaks for CSS in JSstyled-components などの CSS in JS で改行が一部の改行が壊れるというバグの修正。// Inputstyled.div`  ${(props) => getSize(props.$size.xs)}  ${(props) => getSize(props.$size.sm, \"sm\")}  ${(props) => getSize(props.$size.md, \"md\")}`;// Outputstyled.div`  ${(props) => getSize(props.$size.xs)}  ${(props) => getSize(props.$size.sm, \"sm\")}  ${(props) => getSize(props.$size.md, \"md\")}`;YAML: Fix printing doubles a blank line before a commentこれは YAML のコメントと空行を組み合わせると奇妙なフォーマットが起こるというバグで、今でもよくわかっていない。YAML のシンタックスは自分には難しく、そしてほとんど書いたことがないので実は未だによくわかっていない。なので他のメンテナーに一部引き継いでもらった。未だに不安定な気はするものの、リグレッションは修正できたのでその状態でリリースを行った。まだリリースされていはいないいくつかの変更もここで紹介する。Use better fonts in Playground。Playgroundを等幅フォントに変更した。これによってスペースの数などを目視で確認するのが圧倒的に楽になった。Release script: Commit and push after updating dependents count。https://prettier.io には Prettier に依存しているパッケージの数が掲載されており、リリーススクリプト内でリリースと同時に更新している。しかし、実際には変更だけしてコミット・プッシュがされていなかったのでするように修正した。Refactor: Use set instead of array。これはRefactorとタイトルに書いてあるが、実際にはリファクタリングというよりパフォーマンス改善にあたる。Set のような使い方をされていた配列を、Set と WeakMap を使って書き換えた。sosukesuzuki/prettier-regression-testinghttps://zenn.dev/sosukesuzuki/articles/753d7ec2d65e154599c3 に書いたが、GitHub Actions を使って Prettier にバグがないかを確認するツールを開発した。個人で開発したものだが、OSS 活動のために作った OSS なのでここに書いておく。babel/babel先月はなぜか Babel パーサーへの意欲が高まってしまい、10 個ほど Pull Request を作成した。すべてシンタックスエラーの改善だが、一部は Prettier の挙動に影響を及ぼす。Babel は最近になって(7.9 から) errorRecovery 機能が導入されたこともあり、シンタックスエラーがあまりヒューマンフレンドリーではない傾向にある。そういった挙動を修正するのは比較的簡単だがあまり手がつけられていないようなので、もし Babel へのコントリビューションに興味がある人がいたらそこから挑戦していくと良いかもしれない。メンテナーとしての責任や義務感がないので、全体的に楽しくやることができた。そして JavaScript や TypeScript について多少詳しくなれたような気がする。Throw a syntax error for a declare function with a body現在の Babel は次のような変換を行う。// Inputdeclare function foo() {};// Outputfunction foo() {}この入力は TypeScript のインバリッドなコードだが、このような変換がされるのはバグである。Babel のパーサーは ambient context の関数だろうが、ボディがあれば FunctionDeclaration としてパースするためこのようなバグが起こる。本来であれば TSDeclareFunction としてパースするべきで、例えば typescript-eslint/typescript-estree はそのようにパースする。また、このコードはインバリッドであるため、errorRecovery可能なシンタックスエラーを吐いてあげると人間に親切である。なので、そのように修正した。Throw a syntax error for a parameter properties in not constructor現在の @babel/parser は次のようなエラーをスローする。// Inputclass C {  not_constructor(readonly foo: string) {}}// ErrorUnexpected token, expected \",\" (2:27)この入力は constrcutor 以外に対してパラメータープロパティを使っているためインバリッドな TypeScript のコードだが、このエラーはあまりにも不親切である。そしてこのエラーは errorRecovery 不能なために、例えば次のようなコードを Prettier に入力するとエラーになる。class C {  // o が足りない  constructr(readonly foo: string) {}}本来 Prettier は書きかけのコードであってもある程度フォーマットができてほしいので、これは修正する必要がある。なので、errorRecovery 可能なシンタックスエラーを吐きつつ、パースは成功するように修正した。Throw a syntax error for a constructor with type parameters現在の @babel/parser は次のようなコードに対してエラーをスローしない。// Inputclass C {  constructor<T>(foo: T) {}}しかしこのコードは constructor に型引数があるので TS 的にはインバリッドである。なのでシンタックスエラーをスローするように修正した。Do not throw an error for optional binding pattern params in function declaration現在の @babel/parser は次のようなコードに対してシンタックスエラーをスローする。// Inputexport declare function ohai({ foo }?: Args): string;// ErrorA binding pattern parameter cannot be optional in an implementation signature. (1:29)implementation signature ではないのにこのエラーが出るのはバグで、実際 TypeScript コンパイラーではこのエラーは出ない。なので修正した。Throw an error for a declare class field that have an initializer現在の @babel/parser は次のようなコードに対してシンタックスエラーをスローしない。// Inputclass A {  declare bar: string = \"test\";}本来 TypeScript では declare なフィールドに初期値をもたせることはできないはずなので、シンタックスエラーを吐くべきである。なので修正した。Add missing tests for TypeScript syntax errorsこれは足りていなかったテストケースを追加した。よく使われている OSS でも意外とこういうことがある。Improve syntax error for class fields in ambient context「初期値を持つ declare なクラスフィールドにシンタックスエラーをスローしない」、というのは修正したが、ambient context なクラスフィールドの定義方法は他にも存在し、それらに対してもシンタックスエラーをスローするように修正した。// Inputdeclare module m {  class C {    field = \"field\";  }}そして、エラーメッセージを TypeScript コンパイラと統一した。[ts] Throw a syntax error for index signature with declare現在の @babel/parser は次のようなコードに対してシンタックスエラーをスローしない。// Inputclass C {  [key: string]: string;}TypeScript では declare な index signature というのは定義できないはずなので、シンタックスエラーをスローするように修正した。Throw a recoverable error for missing initializer in const declaration現在の @babel/parser は次のようなコードに対して errorRecovery 不能なエラーをスローする。// Inputconst a;// ErrorUnexpected token (1:9)これは人間にとってわかりにくいので、errorRecovery可能なエラーをスローし、パース自体は成功するように修正した。Throw a syntax error for empty type parameter/argument現在の @babel/parser は次のようなコードに対してシンタックスエラーをスローしない。// Inputlet a: Foo<>;TypeScript コンパイラは空の型引数に対してシンタックスエラーをスローするので、それに合わせる形で修正した。","link":"https://sosukesuzuki.dev/posts/oss-2020-09/","isoDate":"2020-10-10T00:00:00.000Z","dateMiliSeconds":1602288000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"GitHub Actions で Prettier がバグってないか確認する","contentSnippet":"背景Prettier をリリースする前には実際に Prettier を使っているプロジェクトのソースコードに対して新しいバージョンの Prettier を実行し、リグレッションが起きていないかを確認する必要がある。前回のリリースを担当したので、この作業も自分でやったのだけどかなり面倒くさかった。というのも、次のような作業を手動で行う必要があったから。そのタイミングでの最新バージョンの Prettier を使っているプロジェクトを GitHub で探す。フォークする。クローンして、Prettier のバージョンを master(prettier/prettier)に更新する。package.json を読んで Prettier を実行するスクリプトを探して実行する。差分をコミットしてフォークに Pull Request を投げて他のメンテナーに共有する。これらの工程を手動でやるのは、難しくはないけどとても面倒くさい。できればもうやりたくないので、よしなに自動化できたらいいなーなんて思ってた。そして、これとは別の文脈で、「Prettier のリリース頻度遅くない？」みたいな話がユーザーからもメンテナーからもあがっていた。それはそうで、1回のマイナーリリースに約半年かかることもある。これは別に意図しているわけではなくて、人手が足りなかったりしてそのバージョンでやりたいことが達成できず、ユーザーに急かされてリリースする、といった流れになっていた。なので、「月に1回マイナーリリースしたいねー」みたいな話を自分から提案してみた。https://github.com/prettier/prettier/issues/9095まだ決まったわけではないけど、個人的には月に一度のマイナーリリースを実現したいと考えている。月に一度マイナーリリースをするということは、上記のリグレッションチェックの工程を月に1回しなければならないということで、それは本当に面倒くさいし楽しくないので、やはり自動化をしなければと思い立ちそういう Issue を作った。(ついでに、自分のプライベート的にも 10 月からはオフラインとはいえ大学も普通に始まるし、最近自動車教習所に通い始めてしまったので、Prettier に割く無駄な時間は積極的に減らしていきたいと考えていた。)https://github.com/prettier/prettier/issues/9290この Issue で、自分は「自動化したいなー」というくらいの話しかしていなくて具体的な手法については全然考えていなかったのだけど、他のメンテナーから、別リポジトリに切り出して git submodule と GitHub Actions を使って Pull Request 上で差分を確認したいみたいな提案があった。確かに Prettier 本体のリポジトリで色々いじるより小回り聞くし別リポジトリでさっくりやってみるかーと思い作り始めた。概要開発したものは sosukesuzuki/prettier-regression-testing においてあって使い方も書いてあるので先にみたい人はそちらを見てください。使い方は簡単で、基本的には Issue に run という内容でコメントするだけ。それをトリガーにして GitHub Actions のワークフローが実行される。そのワークフローでは、 git submodule として事前に登録してあるリポジトリのソースコードに対して、新しい Prettier(これも submodule として追加されている)を実行する。実行した結果なにか差分があればそれを Issue コメントとして返す。なければない旨を表示する。Prettier のコミットハッシュやブランチを指定できると便利なので、run with checking out 36c35be2109e4d4d4b0e89862c993e15e22cc6d1 みたいなコメントをするとそこにチェックアウトした上で実行し、差分をコメントしてくれる。当初 Pull Request で差分を確認するつもりだったが、submodule 内の差分を Pull Request で確認する方法がわからなかったから Issue コメントとして実装してみたら意外にもいい感じだったのでそのままいくことにした。どうしても Pull Request 上で確認したくなったら git submodule じゃなくて git clone することになりそう。しくみまず、prettier/prettier が git submodule として ./prettier に置いてある。ワークフローで実行する Prettier はこの submodule です。そして、Prettier を実行する対象のリポジトリは submodule として ./repos 下ににおいてある。現在は自分が過去に何度か貢献していてなんとなく勝手がわかっている typescript-eslint/typescript-eslint と vuejs/eslint-plugin-vue がある。そして、ワークフローがトリガーされると次のような順番で処理が行われる。./prettier の依存をインストールする。(run with checking out ... で実行されていた場合、チェックアウトする)./repos 下においてあるリポジトリに対して ./prettier/bin/prettier.js を実行する(Prettier は素の JavaScript で書かれているので、GitHub から落としてきたものをそのまま実行できる)git diff --submodule=difff ./repos で対象のリポジトリに生まれた差分をテキストで得る。差分のテキストを含めた Issue コメントを作成する。簡単に言えばこのような感じ。ちなみに自分はシェルスクリプトや YAML を書くのが苦手なので、上記の工程は全部 JavaScript で書いた。(sindresorhus/execaを多用した。) https://github.com/sosukesuzuki/prettier-regression-testing/blob/97c104bab18ce9683532e0b76c9585034e5890f5/index.js にこの記事を書いている時点でのコードがあります。所感まだ対象にしているリポジトリが少なすぎるので、追加していきたいと思っている。できれば、TypeScript と JavaScript 以外のものをどんどん追加していきたい(その２つは得意なメンテナーが多い)。Vue の SFC とか GraphQL とかのコードを Prettier でフォーマットしているプロジェクトをご存知の人がいたら教えてくれると嬉しいです。それにまだ実際にリリース時のリグレッションチェックの作業に使ったわけではないので、本当に便利なのかはまだ正直わからない。でも手動でやるよりは明らかに楽になるのでリリースの頻度をあげられるんじゃないかなーとは思ってる。","link":"https://sosukesuzuki.dev/posts/regression-checker-for-prettier/","isoDate":"2020-10-05T00:00:00.000Z","dateMiliSeconds":1601856000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"7月と8月と9月前半の OSS 活動","contentSnippet":"7 月から 9 月前半までの OSS 活動の振り返りです。prettier/prettierブログにも書きましたが初めて自分でリリース行ったりしてコード書く以外のちょっと面倒なことの分量が増えたかなーという感覚があります。リリースの間隔が長すぎるというのはメンテナーたちも課題だと思っていて、月 1 マイナーリリースを目指そうかなーみたいな話がありつつも、最近自動車教習所に通い始めて自由な時間が減っている+秋学期は単位をとらないとまずいのでどうなるかはわかりません。2.1 のリリース2.1.1 のリリース2.1.2 のリリース#8849 remark v8 へのアップデートに伴うテストの追加#8820 #8849 では足りてなかったテストの追加#8740 一部の関数で JSDoc の型が正しく参照できてなかったので修正#8710 型チェックに使っている tsc がデバッグ用のファイルを無視するように修正#8692 TS4.0 でShort-Circuiting Assignment Operatorsが導入されるのでそのためにテストを追加#8689 一部の関数で JSDoc の型が正しく参照できていなかったので修正#9078 CSS in JS で不要な空白が挿入されるバグの修正#9058 ブログ記事の下書きを生成するスクリプトを修正#9024 過去に行った#7889 のリバートが不十分だったので続き#8982 TypeScript 4.0 サポート#8984 各 Pull Request に含まれるチェンジログからブログ記事を生成するときに一部文言を置換するように修正#8981 新しい Prettier を typescript-eslint のソースコードで実行したときに発生したバグの修正(1)#8967 新しい Prettier を typescript-eslint のソースコードで実行したときに発生したバグの修正(２)#8932 2.1 リリースブログを追加#9083 リリーススクリプトを実行するタイミングで dependents cound を更新してリモートリポジトリにプッシュするように修正#9164 Array を Set っぽく使ってるところで Set を使うように修正#9136 CSS in JS で一部改行が崩れるバグを修正#9116 GraphQL で一部インデントが崩れるバグを修正#9143 YAML で一部改行が二重にプリントされてしまうバグを修正kintone/dts-gen#325 標準の no-unused-vars ではなく @typescript-eslint の no-unused-vars を使うように修正acronjs/acorn-jsx#115 JSX Element にカッコなしで yield したときにシンタックスエラーになるバグを修正SchemaStore/schemastore#1213 Prettier 2.1 用のスキーマに修正mizchi/mdbuf#19 GraphQL コードブロックを書いたときに止まるバグを修正babel/babel#12061 babel-parser でコンストラクタ以外にパラメタプロパティを使ったときに出るシンタックスエラーを改善、またリカバリ可能に修正","link":"https://sosukesuzuki.dev/posts/oss-2020-07-08-09/","isoDate":"2020-09-16T00:00:00.000Z","dateMiliSeconds":1600214400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"はじめて自分で Prettier をリリースした","contentSnippet":"先日 Prettier のバージョン 2.1 をリリースしました。いままでコミット権限をもらってから１年ほど経ちますが自分でリリースをしたのははじめてでした。こういう記録をあんまり見たことないような気がするので、やったこととかメンタルのことを書き残しておこうと思います。やったことリリースチェックリストの Issue を作るhttps://github.com/prettier/prettier/wiki/Release-Checklist にリリース前にやることリストのテンプレートがおいてあるので、それをコピーして Issue を作ってピンしておきます。(https://github.com/prettier/prettier/issues/8882)基本的にはこのチェックリストにしたがって作業を進めていきます。作業を整理するPrettier は GitHub で管理されていて、バージョンごとの作業の管理にマイルストーン機能を使っています。マイルストーンの運用に厳密なルールはなくて、メンテナが各々必要そうだなと思ったものをマイルストーンに入れています。なので、優先度の低いものや今はリソースが足りなくて取りかかれないものなどが入っていることがあります。そういったものをマイルストーンからはずして本当に次のリリースに必要なものだけを残します。作業を完遂するマイルストーンを整理したら、そこに入っている作業をこなします。今回のリリースでは、主に２つの作業がありました。remark パーサーのアップデートに伴うテストの追加と、メンバーチェインのフォーマットの中途半端な改善のリバートです。結構めんどくさい(難しくない)作業なんですが、頑張ってガガッと終わらせました。リバート作業の方は最初ミスってあとからまた直しました。いまのところそれが原因っぽいリグレッションは報告されてないから多分大丈夫だと思います。リリースブログを用意するhttps://prettier.io/blog/2020/08/24/2.1.0.html こういうやつを用意します。https://github.com/prettier/prettier/pull/8932Prettier のリリースブログは長くてしっかりしていると言われることがたまにありますが、全部の PR に Changelog をつけてもらっていてそれをスクリプトでくっつけているのであんまり記事の Author が書く量は多くありません。でもプレビューしてみてコードブロック狂ってるとかシンタックスハイライトきいてなさそうみたいな不具合は修正する必要があります。他のプロジェクトで新しい Prettier を実行してみてバグってないか確かめるPrettier を使っているいくつかの OSS のコードベースに対して新しい Prettier を実行してみておかしなところがないかを探します。(https://github.com/prettier/prettier/issues/8882#issuecomment-671021183)僕がそのリポジトリの勝手がわかっている方がやりやすいので、過去に何度か貢献したことのあるプロジェクトの中から良さそう(書かれてる言語とかが異なるもの)を選びます。今回はtypescript-eslint/typescript-eslintとvuejs/vue-eslint-plugin、excalidrawを使いました。この作業は結構めんどくさくて、それぞれフォークしてそのリポジトリの Prettier を更新して実行してフォークに PR 作ってみんなに共有して〜〜みたいな作業を手動でします。自動化したいのでよさそうな方法を考えています。また、本当はもっと多くのプロジェクトに対してこれをやるべきだと思っているので、もし Vue(SFC)や Angular や GraphQL で書かれた Prettier を使っているよさそうな OSS をご存知の方がいたら教えて下さい。見つけたバグを直す↑ の作業で見つかったバグを修正します。https://github.com/prettier/prettier/issues/8941https://github.com/prettier/prettier/issues/8943これが結構面倒。簡単に直せるやつならいいけど、今回はちょっと難しかった...。TypeScript 4.0 の空気を読むこれは今回特有。2.1 準備中に TS4.0 の RC が出たり Babel が 7.11 で TS4.0 をサポートしたり typescript-eslint も一部の構文だけサポートしたり他のエコシステムの対応状況を見つつ、どこまでサポートをするべきかを考えます。結局準備が長引いている間に TS4.0 の本リリースが行われたので、フルでサポートしました。これは依存しているパーサーを更新したりちょっとテスト書いたりすればいいから技術的には簡単です。https://github.com/prettier/prettier/issues/8646リリースするそんな感じで、チェックリストの項目を全部クリアしたらリリースします。リリーススクリプトが用意されているので基本的にはそれを実行して表示される指示に従えば問題なくリリースできます。過去のメンテナーに感謝です。一個おもしろい話としては、リリース準備中活動していたメンテナは僕含め誰も npm へのパブリッシュ権限をもっていなかったのでリリースができなかったタイミングがありました。結局過去のリリースを行った人に頼んで権限を付与してもらいましたが。ちなみにめっちゃ緊張しました。「なんかミスったらやべえぞ！！！」と思ってましたが、結果としてはほとんど何事もなくリリースが完了しました。メンタルっぽい話自分はバグを直したり機能を追加したりコミュニケーションをとったりするのは楽しいと感じるから全く苦ではないのですが、リグレッションをチェックする作業とかリリースブログを用意する作業とか Issue を眺めて治ってるかチェックする作業とかはきつくて、「めんどくせーーー」と思いつつも僕がやらなかったら誰もやらないもしくはやるのがだいぶ遅れることになるので、頑張ってやりました。自分は今大学が夏休みで、お仕事(業務委託)の稼働時間も少なくなっているので Prettier のための作業をする時間が結構確保できたけど、フルタイム社会人やりながらこういうことやってる人は時間の使い方が上手すぎるだろと思います。そういう人を目指して頑張ります。なんか自分で色々とめんどくさいこともやってみて、お金のないコミュニティベースの OSS が持続しているのは偶然っぽいし、もし将来なにかしらの理由で億万長者になることがあったら OSS にお金をあげたいなあと思いました。ただ、自分でリリースをすると達成感は明確にありました。数年前まで中学校の校庭でサッカーしてたやつのマシンから世界中で使われるソフトウェアがリリースされてるってすげえな...と感動しました。","link":"https://sosukesuzuki.dev/posts/my-first-release-prettier/","isoDate":"2020-08-31T00:00:00.000Z","dateMiliSeconds":1598832000000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"6 月の OSS 活動","contentSnippet":"５月いっぱいで、それまで月 100 時間くらいやってたインターンをやめたので OSS に多くの時間を割くことができるぞ！！！と意気込んでいたんですが、その割にはサボっちゃいました。無念。海外出たことなくてパスポートがなく、運転免許もないので GitHub Sponsor を始められていないのですが、僕を個人的に応援したい人がもしいたらそうすけ応援セット(ほしいものリスト)から水とか米を送ってくれると大変モチベーションに繋がります。Prettierめんどくさくなっちゃったのでスクリーンショットで...。一番下に Definitely Typed があると思うんですが、これは Prettier の doc builder の一部が型定義になかったので追加したやつです。２つまだオープンになっている PR がありますが、これらは影響範囲が大きいので慎重にすすめています。もう Prettier を壊したくないので！一番上に大きく表示されているものは、二項演算子とコメントを組み合わせたときにインデントが崩れるというもの。https://github.com/prettier/prettier/pull/8476a +  a + // comment  a;このコードがa +a + // comment  a;こんな風に修正されてしまう。このバグは今まで報告されていなくて、他のメンテナーがテストケースを作ってるときに発見したみたいなんですが、多分パイプライン演算子が入ってきたらこういうコードが頻繁に書かれる気がするので、パイプラインが ECMAScript とか TypeScript に入る前に直せてよかったですね。他にも、まだ実装途中なんですがちょっと大きめの修正をやっています。https://github.com/prettier/prettier/pull/8554三項演算子とコメントを組み合わせたときに、コメントが意図に反して移動してしまうというもの。test  // comment  ? first  : second;こんなふうに、条件と ? の間にコメントをいれるとtest  ? // comment    first  : second;? のあとに移動してしまいます。これは前々から報告があったもので、だいぶ前に実装して PR を出して放置してたんですがやっぱりやったほうがよさそうだったのでその PR を閉じて新しく始めたものです。これを実装してテストーケースを書いていく中でいくつか三項演算子とコメントを組み合わせたときのフォーマットのバグを発見したので、それらも修正しました。あと日本語話者の方々からしたら興味深い問題であろう、Markdown のラテン文字と日本語の間にスペース入っちゃう問題も水面下で進行中です。僕は前々からこの挙動はおかしいから直すべき、という立場なんですが、個人的にはラテン文字と日本語の間にはスペースを入れるスタイルを好んで使っています（あくまで個人が好きに選択すべきであって、Prettier が干渉すべき問題ではない。それを縛りたいのであれば textlint 等でやるべき、という主張です）。So you actually do use spaces between Latin and Japanese characters. Now I'm confused.— Georgii Dolzhykov (@thorn0) June 12, 2020そしたら他のメンテナーから、「（君いつもラテン文字と日本語の間にスペース入れるのはおかしいって言ってるけど）実際ツイートではそういう風に書いてるじゃん...、どういうこと...？」という反応を頂いておもしろかったです。mizchi/mdbufmizchi さんが作ってるシンプルなマークダウンエディタ。ブラウザですぐ開けて動作も軽快なので好んで使っています。自分は昔Boostnoteっていうののメンテナンスをしていたことがあって、そのときにマークダウンエディタについて色々考えたんですが、複雑なエディタは重かったり、複雑すぎてバグっていてメンテナンスがきつかったりとか色々あって、速くてシンプルなものを選ぶようになりました。自分でも作ったりしたんですが、そういった自作を含めても mdbuf が一番使いやすいので愛用しています。このブログや Prettier のチェンジログとかも mdbuf で書いていて、本当によく使っているんですが、チェンジログを書いてるときに vue のコードブロックを書くと止まっちゃうことに気づきました。それではちょっと困るので、vue コードブロックのシンタックスハイライトを無視するようにしました。https://github.com/mizchi/mdbuf/pull/13余談ですが、GitHub のリポジトリページに contributors という項目があるんですが、そこに mizchi さんと syake さんと僕で並んでしまっていて、なんかちょっと申し訳ない気持ちになっています。(syake さんは favicon とかを修正してくれたみたいです。タブから探すのがめっちゃ楽になってすごくありがたいです。)","link":"https://sosukesuzuki.dev/posts/oss-2020-06/","isoDate":"2020-07-03T00:00:00.000Z","dateMiliSeconds":1593734400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Prettier の中間表現 Doc をシュッと試せる JavaScript のサブセットを作ってブラウザで動かす","contentSnippet":"https://github.com/sosukesuzuki/prettier-doc-interpreterPrettier ではコードを整形する過程で Doc という中間表現を使うのですが、それをシュッと試せる JavaScript の(構文的には)サブセットを作ってブラウザで動かしてみました。これがあると、Prettier を開発するときに Doc の挙動をすぐに確かめられるので嬉しくなります。Prettier のしくみまず、Prettier のしくみをざっくり説明します。フォーマットしたいコードを受け取ったら、それをパースします。パースしたら、AST を再帰的に見ていってこの記事の主役である Doc と呼ばれる中間表現に変換します。Doc はフォーマットの対象の言語に依らず、テキストの形を表現するためのデータ構造で、最終的に文字列に変換されます。そして変換された文字列を返します。Doc の作り方と形Prettier のソースコード内には Doc を生成するための関数や変数(doc builder)が定義されていて、次のように使われています。(\"foo\"と\"bar\"は通常の JavaScript の文字列リテラルです)const doc = group(concat([\"foo\", hardline, \"bar\"]));ちなみに、doc builder のドキュメントは https://github.com/prettier/prettier/blob/master/commands.md にあります。このとき変数docは次のようなオブジェクトになっています。// 変数 doc の中身{  \"type\": \"group\",  \"contents\": {    \"type\": \"concat\",    \"parts\": [      \"foo\",      {        \"type\": \"concat\",        \"parts\": [          {            \"type\": \"line\",            \"hard\": true          },          {            \"type\": \"break-parent\"          }        ]      },      \"bar\"    ]  },  \"break\": false}このオブジェクトをprintDocToStringという関数に渡すと文字列に変換できます。const { formatted } = printDocToString(doc);console.log(formatted); // => foo\\nbarこのあたりのロジックは Prettier のコアとなる部分で、開発初期のころからほとんど変更されていません。プラグイン作る人くらいしか使わないと思いますが、doc builder やprintDocToStringはprettierパッケージで export されています。作ったものhttps://github.com/sosukesuzuki/prettier-doc-interpreterDoc を生成するための式(e.g. group(concat([\"foo\", hardline, \"bar\"])))を文字列として受け取って、変換した結果の文字列(e.g. \"foo\\nbar\")を返す関数です。まだちょっとバギーだし機能不足なんですが...。$ npm install prettier-doc-interpreterで入ります。こんな感じで使えます。import { evaluate } from \"prettier-doc-interpreter\";const source = `group(concat([\"foo\", hardline, \"bar\"]))`;const formatted = evaluate(source);console.log(formatted); // => foo\\nbarしくみ(受け取った JavaScript のコードを実行して返すものなので、最初はevalでやっちゃおうかなーとも思ったんですが、危険だったりエラーを丁寧に吐けなかったりするし、おもしろくないのでやめました。)まず、受け取ったコードを acorn でパースします。そしたら AST を上から見ていって、prettier/standaloneから import した doc builder に渡して Doc を作ります。このときに不正なノードや変な形をした Doc があったらエラーを投げます。最後に、作った Doc をprettier/standaloneから import したprintDocToStringに渡して文字列に変換して、返します。パーサーに acorn を使った理由ですが、ブラウザで動かすことを考えるとできるだけ軽量なものが望ましいというのと、TS とか JSX とかをパースするつもりはなかったので @babel/parser みたいな高機能なものは不要だったというのがあります。ただ、acorn の型定義はちょっと弱いので、型定義だけは@types/estreeを使ってみました。const ast = (acorn.parse(code, { locations: true }) as any) as ESTree.Node;多分本当は acron の吐く AST と ESTree の型定義は異なると思うけど、とりあえず問題なく動いたのでよし！問題がでたら直すかも。ブラウザで動く Playground もあるよhttps://prettier-doc-playground.netlify.app/https://github.com/sosukesuzuki/prettier-doc-playgroundpreact と TypeScript でできています。prettier-doc-interpreterの実行は Web Worker でやってます。comlink-loader便利ですね。人に共有できると便利なので、状態を URL ハッシュにもたせています。こういうやつにはよくある機能ですね。","link":"https://sosukesuzuki.dev/posts/prettier-doc-interpreter-and-playground/","isoDate":"2020-06-09T00:00:00.000Z","dateMiliSeconds":1591660800000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"5 月の OSS 活動","contentSnippet":"5 月のオープンソース活動です。意外とちゃんとやってた。PrettierVue や HTML の改善をやっていたような気がします。あと Babel 7.10 や TypeScript 3.9 の対応も若干。ここに載せた以外にも細かな改善もしました。Vue の SFC のパース改善https://github.com/prettier/prettier/pull/8153Prettier は HTML をパースするためにangular-html-parserという Angular の HTML パーサーのフォークを使っているんですが、Vue の SFC のような HTML ではないけど HTML っぽいものにもそれを使用しています。今までは Vue の SFC をそのまんま HTML としてパースしていました。なのでカスタムブロック内や pug 等の HTML 以外の言語を使った template 内に HTML タグとして認識されちゃう文字のパターンを入れるとシンタックスエラーになっていました。(Playground Link)<!-- これをPrettierでフォーマットしようとするとシンタックスエラーになる --><custom-block>const foo =    \"</\";</custom-block>これを解消するためにいくつか方法を考えました。vue-eslint-parserを使うか？とか、Vue 公式の SFC コンパイラのパーサーを使うか？とか。しかし、前者はカスタムブロックのサポートを公式にはしていないようで今回のニーズを満たすパース結果が得られず、後者はルートのコメント情報がパース結果に残らずフォーマッターに使うには不十分でした。なので angular-html-parser を修正してもらって、最終的に少々トリッキーな方法で解決しました。気が向いたらそのお話もどこかに書くかもしれません。Stage-1 プロポーザル private filed in in の対応https://github.com/prettier/prettier/pull/8431Babel 7.10 で対応された Stage-1 のプロポーザルの対応です。次のようなコードはいままでシンタックスエラーだったんですが、フォーマットできるようになります。Prettier 側の対応はパーサーのバージョンアップとオプションの指定だけだったので楽でした。#prop in obj;TypeScript 3.9 で入った Non Null Assertion と Optional Chaining の解釈の変更の対応https://github.com/prettier/prettier/pull/8450リリースノートを見て TypeScript 3.9 は新しい構文ないから Prettier の対応ないじゃん！って思ってたらありましたね。Babel 7.10 も同様の修正が入っているので、babel-tsパーサーにも対応しています。TypeScript 3.8 まではx?.y!.z;は(x === null || x === void 0 ? void 0 : x.y).z;という JavaScript にコンパイルされていたんですが、TypeScript 3.9 からはx === null || x === void 0 ? void 0 : x.y.z;にコンパイルされるようになりました。なので以前までの挙動を再現したい場合にカッコを補ってあげなくてはいけないんですが、Prettier はそのカッコをはずすようにフォーマットをしていたので、維持するようにしました。// Input(a?.b)!.c;// Prettier stablea?.b!.c;// Prettier master(a?.b)!.c;eslint-plugin-vueno-arrow-functions-in-watch ルールの追加https://github.com/vuejs/eslint-plugin-vue/pull/1155ドキュメントに書いてあるんですが、Vue のwatchにアロー関数を使うのはアンチパターンです。thisで束縛される値が変わってしまって、Vue インスタンスを指さなくなります。なので、watchにアロー関数を使っているときに警告を出すルールを追加しました。詳しくは eslint-plugin-vue のドキュメントの https://eslint.vuejs.org/rules/no-arrow-functions-in-watch.html を見ていただけると。typescript-eslintmethod-signature-styleルールの自動修正のバグの修正https://github.com/typescript-eslint/typescript-eslint/pull/1966TypeScript では interface の関数プロパティを二通りの方法で書くことができます。// メソッドのショートハンドinterface T1 {  func(arg: string): number;}// 通常の関数プロパティinterface T2 {  func: (arg: string) => number;}method-signagure-styleルールはこれをどちらかに強制できます。ただ、メソッドのオーバーロードがあったときにメソッドのショートハンドから通常の関数プロパティに強制すると、ルールの自動フォーマットの結果がエラーになってしまうバグがありました。例えば、次のコードを通常の関数プロパティに強制することを考えます。interface T {  method(): void;  method(arg: string): void;  method(arg: number): string;}今までの実装だと、このようにフォーマットされていました。interface T {  method: () => void;  method: (arg: string) => void;  method: (arg: number) => string;}実際試してみるとわかりますが(Playground link)、これはDuplicate identifier 'method'.でコンパイラに怒られてしまいます。なので、これを intersection types としてフォーマットすることでエラーを回避します。interface T {  method: (() => void) & ((arg: string) => void) & ((arg: number) => string);}これはセーフになります(Playground link)。","link":"https://sosukesuzuki.dev/posts/oss-2020-05/","isoDate":"2020-06-01T00:00:00.000Z","dateMiliSeconds":1590969600000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Deno に採用されたコードフォーマッター dprint が速い","contentSnippet":"Deno では以下のようにサブコマンドを実行することで、ソースコードのフォーマットをできます。ref: https://deno.land/manual/tools/formatter$ deno fmt example.tsオフィシャルにコードフォーマッターを提供することによって、少なくとも Deno の世界のために記述されるコードのスタイルが開発者によってバラバラになったり、そのために議論が生まれるということはなさそうです。これは大変良いことです。この deno fmt コマンドの内部では以前までは Prettier が使用されていたのですが、 deno v 0.32.0 から dprint という Rust で書かれたコードフォーマッターが使われるようになりました。ref: https://github.com/denoland/deno/pull/3820この dprint、どうやら実行速度がとても速いという噂を聞いたので、実際のコードでためして Prettier と比較してどの程度速いのか試してみようと思います。実行マシンとベンチマーク方法以下の性能の MacBook Pro で計測を行います。MacBook Pro (13-inch, 2019, Four Thunderbolt 3 ports)プロセッサ 2.4 GHz Intel Core i5メモリ 16 GB 2133 MHz LPDDR3グラフィックス Intel Iris Plus Graphics 655 1536 MB以下のような形のディレクトリを作り、dprintとprettierをローカルインストールします。/repositories下には https://github.com/prettier/prettier と https://github.com/mictosoft/typescript がクローンされています。dprint.config.js と prettierrc はデフォルトのままにします。.├── dprint.config.js├── package.json├── repositories│   ├── prettier│   └── typescript└── yarn.lockhyperfineを使って、それぞれnode_modules/.bin/下にある bin を叩いて計測をします。計測してみるまず、そこまでコード量が多くない https://github.com/prettier/prettier の /src ディレクトリ下の JavaScript ファイルを対象にして時間を計測してみます。対象ファイル数: 117対象コード行数: 29205$  hyperfine \"./node_modules/.bin/dprint \\\"repositories/prettier/src/**/**/*.js\\\"\" \"./node_modules/.bin/prettier \\\"repositories/prettier/src/**/**/*.js\\\" --write\" --ignore-failureBenchmark #1: ./node_modules/.bin/dprint \"repositories/prettier/src/**/**/*.js\"  Time (mean ± σ):      1.209 s ±  0.206 s    [User: 4.046 s, System: 0.139 s]  Range (min … max):    1.003 s …  1.663 s    10 runsBenchmark #2: ./node_modules/.bin/prettier \"repositories/prettier/src/**/**/*.js\" --write  Time (mean ± σ):      2.519 s ±  0.135 s    [User: 4.123 s, System: 0.136 s]  Range (min … max):    2.318 s …  2.709 s    10 runsSummary  './node_modules/.bin/dprint \"repositories/prettier/src/**/**/*.js\"' ran    2.08 ± 0.37 times faster than './node_modules/.bin/prettier \"repositories/prettier/src/**/**/*.js\" --write'平均値を見てみます。dprint: 1.209 sprettier: 2.519 sこの規模のプロジェクトでも、 dprint のほうが 2 倍くらい速くなっています。少し大きめのコードでも試すために、 https://github.com/microsoft/typescript の /src 下の TypeScript ファイルに対してもやってみます。対象ファイル数: 430対象コード行数: 438366$  hyperfine \"./node_modules/.bin/dprint \\\"repositories/TypeScript/src/**/**/*.ts\\\"\" \"./node_modules/.bin/prettier \\\"repositories/TypeScript/src/**/**/*.ts\\\" --write\" --ignore-failureBenchmark #1: ./node_modules/.bin/dprint \"repositories/TypeScript/src/**/**/*.ts\"  Time (mean ± σ):      5.295 s ±  0.143 s    [User: 7.884 s, System: 0.213 s]  Range (min … max):    5.132 s …  5.548 s    10 runsBenchmark #2: ./node_modules/.bin/prettier \"repositories/TypeScript/src/**/**/*.ts\" --write  Time (mean ± σ):     22.387 s ±  0.242 s    [User: 38.089 s, System: 1.103 s]  Range (min … max):   22.121 s … 22.848 s    10 runs  Warning: Ignoring non-zero exit code.Summary  './node_modules/.bin/dprint \"repositories/TypeScript/src/**/**/*.ts\"' ran    4.23 ± 0.12 times faster than './node_modules/.bin/prettier \"repositories/TypeScript/src/**/**/*.ts\" --write'平均値を見てみます。dprint: 5.295 sprettier: 22.387 sこの規模になってくると差が顕著になってきますね。速い体感でわかるくらい速いし、測ってみたら速かったです。今後 Deno や dprint がどうなっていくかはわかりませんが、1.0 がリリースされる前の段階で dprint のような Rust 製のコードフォーマッターに移行したのは英断だったように思います。コードフォーマッターとしての性能はまだ見れていないのでなんとも言えませんが、もしかしたら通常の TypeScript/JavaScript プロジェクトにも採用できるかもしれません。今度は、 dprint に Prettier のテストケースを食わせてちゃんとフォーマットできるかやってみようと思います。","link":"https://sosukesuzuki.dev/posts/dprint-is-fast/","isoDate":"2020-05-25T00:00:00.000Z","dateMiliSeconds":1590364800000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"4 月の OSS 活動","contentSnippet":"4 月の OSS 活動です。今月は仕事と大学の方がそこそこ忙しく思うように OSS に時間をとれませんでしたが、カスタムブロックのサポートやずっと放置していたパイプラインオペレータのサポートができたのでそこは良かったかなと思います。PrettierSmart / F# スタイルのパイプラインオペレータのサポートhttps://github.com/prettier/prettier/pull/6319ECMAScript のパイプライン演算子のプロポーザルには３種類ありますが、Prettier がサポートしているのはMinimal Pipelineのみでした。この PR では、それ以外のSmart Pipeline、F#-style Pipelineのサポートを追加します。この PR は実は 2019 年の 6 月に作成していたのですが、実装が難しい箇所があり約 10 ヶ月放置していました。しかし、唐突に良い実装を思いついたので実装してマージしました。Vue のカスタムブロックのサポートhttps://github.com/prettier/prettier/pull/8023Vue の SFC の中にはカスタムブロックとして任意の言語を記述できます。しかし、渡されたテキストを見てもどの言語で書かれているのか判別できないという理由で、いままで Prettier はその中に書かれたコードをフォーマットしていませんでした。それでは不便なので lang や type 属性をカスタムブロックタグにつけた場合、それに対応した言語としてフォーマットを行う機能を追加しました。<template>  <p>foo</p></template><custom-block lang=\"javascript\">const foo =     \"foo\";</custom-block>↑ このコード中のcustom-block の中身は JavaScript としてフォーマットされるようになります。将来的には、2.1 から追加される embeddedLanguageFormatting オプションを使って属性なしでのフォーマットができるようにしたいと考えています。(DefenitelyTyped) 型定義を 2.0 用に更新https://github.com/DefinitelyTyped/DefinitelyTyped/pull/435762.0 でいくつか API が更新されたけど追従できてなかったので修正します。typescript-eslintexplicit-module-boundary-types ルールに shouldTrackReferences オプションを追加https://github.com/typescript-eslint/typescript-eslint/pull/1778explicit-module-boundary-types ルールは、export されている関数の型を明示することを強制します。しかし、変数に代入された関数の場合は警告が出ません。これは警告が出るexport const foo = (arg) => arg;これは警告が出ない(よくない)const foo = (arg) => arg;export default foo;なので、shouldTrackReferencesオプションを追加して、それが true のときは変数の参照を追って警告を出すようにしました。以前までとの挙動が変わることはありませんが、このオプションはデフォルトで true になります。","link":"https://sosukesuzuki.dev/posts/oss-2020-04/","isoDate":"2020-04-30T00:00:00.000Z","dateMiliSeconds":1588204800000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"3 月の OSS 活動","contentSnippet":"誰かがこれを見てなにかを参考にしてくれたらいいなぁっていう気持ちと、自分のための活動の記録として、OSS 活動を毎月適当なタイミングでまとめていこうと思います。その３月分です。Prettier最近レビューばかりでバグ修正とかがあんまりできてなかったんですが、３月は結構できました。7709: 改行を含む変数代入・宣言のときのコメントの位置の修正改行とブロックコメントを含む変数の代入・宣言が壊れちゃうやつです。このバグによって Closure Compiler や JSDoc など、式の直前にコメントが存在することに意味があるツールでは、意味を破壊されてしまいます。// Inputconst foo = /* comments */  bar;// Outputconst foo /* comments */ = bar;// This PRconst foo = /* comments */ bar;7729: 空の型パラメータの中にコメントいれるとエラーが出るこれは一体誰が困るんですかね。// Inputconst a: T</* comment */> = 1;// OutputError: Comment \"comment\" was not printed. Please report this error!// This PRconst a: T</* comment */> = 1;7764：TypeScript 3.8 の export * as ns 構文のサポートexport * as ns のサポートです。これで、TS 3.8 から入るすべての構文のサポートが完了しました。7804: Babel パーサーでの TypeScript 3.8 type only import/export の対応2.0 から parser=babel-ts オプションをつけることで Babel を使って TypeScript のパースができるようになったのですが、TypeScript 3.8 で追加された type only import/export のサポートができていませんでした。この PR はそれを修正します。ちなみに、type only import/export は Babel 7.9 から入っているんですが、リリース直後にそれ周りのバグを見つけたのでツイッターで Babel のメンテナチームの方に確認したら、一瞬で Issue が作られて一瞬で直されて一瞬でリリースされていました。ありがたい。7869: TypeScript の as を二項演算子としてフォーマットする今まで TypeScript の as は行の幅が長いときにうまいことフォーマットされないことがありました。例えば、下の例の場合は、= に直後に改行が入ることが期待されると思います。// Inputconst varibale = foooooooooooooooooooooooooooooooooooooooooooooooooooo as SomeType;// Outputconst varibale = foooooooooooooooooooooooooooooooooooooooooooooooooooo as SomeType;これは、as に対してあまり凝ったロジックを使わずにフォーマットしていたので、想定通りといえば想定通りの挙動でした。ただ、TypeScript の as は基本的に JavaScript の二項演算子(3 + 3 の + とか)と同様のフォーマットをして問題なさそうということになったので、そのように修正しました。これは、もともと Babel や ESLint のメンテナのkaicataldoが実装しかけていたアイデアを引き継いだものになります。// This RPconst varibale =　　foooooooooooooooooooooooooooooooooooooooooooooooooooo as SomeType;7892: Flow の inexact object type で他にプロパティがないときにコメント入れるとエラーが出るこれも誰が困るんだろうシリーズかもしれない。Flow 書かないからよくわかんないけど。// Inputtype Foo = {  // comment  ...,};// OutputError: Comment \"comment\" was not printed. Please report this error!// This PRtype Foo = {  // comment  ...,};eslint-plugin-vue1086: no-template-target-blankルールの追加まだマージされてません。eslint-plugin-react のjsx-no-target-blank相当のことを Vue のテンプレートでやります。これによって、rel='noreferrer noopener' なしで target='_blank' を使ったときに警告がでるようになります。このルールはもともと会社で必要だったので社内向けに作ったのですが、せっかくだから eslint-plugin-vue に追加してみようと思い PR を投げました。","link":"https://sosukesuzuki.dev/posts/oss-2020-03/","isoDate":"2020-04-04T00:00:00.000Z","dateMiliSeconds":1585958400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Prettier の TypeScript 3.8 対応遅れてそうだけどどうしたの？","contentSnippet":"追記:3 月 21 日にPrettier 2.0はリリースされ、無事 TypeScript 3.8 のサポートも行われました〜ここから本文:TypeScript 3.8 の正式版が 2 月 20 日 にリリースされましたね。(リリースノート)type only import/export や ECMAScript private field、top-level await など、いくつかの便利な新しい構文がサポートされるようになりました。でもまだ、 Prettier はそれらをサポートできていません。ベータ版リリース直後から Issue はつくられていた3.8 のベータ版がリリースされたのが 1 月 10 日です。(リリースノート)実はその翌日の 1 月 11 日に Prettier に Issue が作られています。(prettier/prettier#7263-Support TypeScript 3.8)対応するのを忘れていたとか、必要だと思っていなかったとかそういうわけではなく、きちんと認識した上でまだサポートできていません。新しい構文のサポートはパーサーライブラリに依存するPrettier は自分でパーサーを実装しておらず、外部パーサーライブラリに依存しています。(JavaScript のパースには @babel/parser を使っているし、 Markdown のパースには remark を使っています。)TypeScript のパースには、typescript-eslint チームが開発している typescript-estree を使っています。これは、 TypeScript Compiler API を使って TS コードをパースし、それを ESTree っぽい AST に変換するためのライブラリです。そして、新しい構文のサポートをするときはこの依存するパーサーの負担が大きくなります。Prettier 側が大変なことも構文の種類によってはあると思いますが、今回追加される構文たちの場合、すでに(見た目の上では)似た構文が存在するので printer の修正は難しくないと思います。Babel や ESTree との兼ね合いtypescript-eslint/typescript-eslint#1465-WIP: feat: new ast for typescript 3.8-comment新しい構文のサポートをするとき、 typescript-eslint チームだけでそれを行うことはできません。各々が勝手に実装すると、ツール間で扱う AST のノードの形がずれてしまうため、Babel や ESTree と相談しつつ決定する必要があります。以前、TypeScript 3.7 で実装された Optional Chaining と Nullish Coalescing のときにこのあたりで若干失敗しているようです。3.7 がリリースされたあと typescript-estree は Babel と同様の形のノードを採用する決定をしました。(Babel の AST の仕様)しかし、 ESTree はそれとは異なる形のノードを採用しようとしているので、ESLint は Babel/typescript-eslint とは違った AST を扱うことになります。(estree/estree#204-Update es2020.md for Dec 2019で Optional Chaining と Nullish Coalescing のノードの形が議論されていて、まだマージされていないみたいですが。)こういった自体を避けるため、今回は慎重になっているようです。あと typescript-eslint チームはだいたいみんなボランティアだから時間がないみたいです。待っててねつまり、Prettier チームとしては typescrit-estree の更新を待つ必要があり、それを開発している typescript-eslint チームとしては Babel や ESTree との兼ね合いがあるので全体的に遅れているという感じです。誰も悪くないので気長に待ちましょう。","link":"https://sosukesuzuki.dev/posts/why-prettier-ts3.8-support-delay/","isoDate":"2020-03-06T00:00:00.000Z","dateMiliSeconds":1583452800000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Introducing Yarn 2 ! メモ","contentSnippet":"https://dev.to/arcanis/introducing-yarn-2-4eh1コアにかなり大きな変更が入ったらしい。v1 からのマイグレーションについてマイグレーションガイドがあるらしい。あとで読む。一応、メジャーなツールでは最新版を使っていれば特に問題は起こらないそう。ただ、Flow と React-Native は現時点では Plug’n’Play (PnP)環境では動かない。(PnP ってなんだろう)それぞれのチームと協力して頑張っていくらしい。v1 のメンテについて来週 1.22 がリリースされる予定で、それ以降は完全にメンテナンスモードに入る。つまり、脆弱性にパッチあてる以外のリリースはしない。新機能は Yarn v2 に対してのみ開発される。v1 のコードベースは、yarnpkg/legacy に移行される。数年後にアーカイブされるかも。v2 のコードベースが yarnpkg/yarn になることはない。履歴が消えるのが痛いから。当面は yarnpkg/berry のままで開発する。これまでのウェブサイトは legacy.yarnpkg.com に移動し、 v2 用のウェブサイト(今の next.yarnpkg.com)がメインドメインに移動する。Node の Docker イメージは、2020 年 4 月リリース予定の Node 14 から、Yarn 2 を出荷する。それまでは yarnPathを使ってすべての Node イメージで Yarn 2 をシームレスに使えるらしい。変更の詳細CLI の出力ほぼすべてのメッセージには独自のエラーコードが含まれていて、ドキュメントで検索できる。行ごとに色をつけるのではなく、各メッセージの重要な部分につける(通常はパッケージ名とバージョン)これからの数ヶ月の間に調整が入る(特に色覚異常へのアクセシビリティとか)ワークスペース周りyarn up <name> ですべてのワークスペースで使われているパッケージを更新できる。yarn add -i <name> で他のワークスペースで使われているパッケージと同じバージョンを再利用する。version pluginってのがあるらしい。あとで読む。ゼロインストールゼロインストール機能はないけど、そのために調整された Yarn の機能が多くある。ベンダーファイルをキャッシュから直接読むから、リポジトリにキャッシュが含まれている場合 yarn install が不要。リポジトリサイズに大きな影響が出るけど、yarn 1 のオフラインミラー機能と同様に合理的らしい。yarn 1 のオフラインミラーを知らないのであとで読む。詳細はゼロインストールのドキュメントを読むと良いらしい。yarn dlxdlxは`download and execute の略)npx と同じことを脆弱性低めにやる。yarn workspaces foreachyarn workspaces foreach run build` みたいなことができるようになるらしい。オプションで、並列実行するかとかスキップするワークスペースを選んだりできる。patch:プロトコル依存関係ツリーの特定のパッケージに変更を適用したいときに使える。{  \"dependencies\": {    \"left-pad\": \"patch:left-pad@1.3.0#./my- patch.patch\"  }}portal: プロトコルlink:と似てる。portal:は推移的な依存解決をするけどlink:はそうじゃないらしい。このあたりはよくわからん。ワークスペースのリリース全く新しいワークフローを設計したらしい(https://next.yarnpkg.com/features/release-workflow)あとで読むワークスペースの Constraints (日本語でこれを翻訳するべきなのかしないでそのまま書くべきなのかわかんない)Constraintsという新しいコンセプトが導入された。ワークスペースに対してバリデーションを Prolog を書くことができる例えば、次の Prolog で書かれたルールはアンダースコアに依存しないことを検証するgen_enforced_dependency(WorkspaceCwd, 'underscore', null, DependencyType) :-workspace_has_dependency(WorkspaceCwd, 'underscore', _, DependencyType).パッケージごとのビルド設定ビルドスクリプトをパッケージごとに実行するかどうかを指定できるようになった。現時点ではデフォルトではすべて実行する。enableScriptsですべてをオフにして明示的に実行するパッケージを選ぶこともできる。シェルのノーマライズYarn 2 の開発当初、Windowns 勢から PR をもらうことがよくあり、それらの多くは Bash でしか動かないとかの問題だったなので、scriptsに記述されるであろうものの 90%をカバーできるような簡易的なインタープリタを実装した。これによって OSX でも Windows でも関係なく実行できるようになった。Peer Dependency のリンクの改善Lock ファイルのフォーマットYarn 1 のときは、YAML ライクだけど YAML じゃない記法を使っていた。でもサードパーティ開発者にとっては厳しいので、YAML の標準にした。TypeScript で書かれたユーザーには影響はないが、Flow をやめて TypeScript で書かれている。Moduler Architectureこれを読めばわかりそうプラグインが作れるようになったから依存関係にアクセスしたいサードパーティツールの開発が楽になった。設定のノーマライズパーッケージの境界が厳密になったdependenciesにないパッケージは使えない。Buncle Dependencies の除去bundleDependenciesが使えなくなったらしいけど名前しか知らなかった使いたい場合は、マイグレーションガイドをよんで代替案を考えるべきRead-Only パッケージ安全性のためにパッケージが読み取り専用になったこういうことはできない:const { writeFileSync } = require(`fs`);const lodash = require.resolve(`lodash`);writeFileSync(lodash, `module.exports = 42;`);","link":"https://sosukesuzuki.dev/posts/introducing-yarn-2-note/","isoDate":"2020-01-25T00:00:00.000Z","dateMiliSeconds":1579910400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"Prettier がファイルパスからパーサを推測するときの情報源","contentSnippet":"Prettier の.cjs対応をしようとおもって、すでに対応されているmjsとかで grep してもヒットしないからどこに情報持ってるんだろうって思って調べたメモをちょっとちゃんと書いたものです。前提1: Prettier はファイル名からパーサーを推測するPrettier を CLI から使うとき、parserオプションを使ってパーサーを指定できます。# パーサーオプションを指定してみる$ prettier foo.js parser=babelただし、ファイル名からパーサーを推測できるときは、parserオプションを省略できます。「foo.jsは拡張子が.jsだから、JavaScript としてパースすればいいよね」といった具合に、Prettier がパーサーを推測してくれます。# これもオッケー$ prettier foo.jsもっとも多いユースケースであるソースコードのフォーマットにおいては、パーサーを明示的に指定せずに使っている人が大半だと思います。2: JavaScript としてパースしてほしいいろんなファイル.js ファイルはもちろんですが.jsx や .es6 など、JavaScript としてパースしたいファイルが他にもいくつかあります。.cjsも JavaScript としてパースしたいファイル拡張子の1つなのですが、現時点で Prettier は対応していませんでした。(.mjsは対応しています。)$ prettier test.mjsconsole.log(\"Hello, ECMAScript Modules!\");$ prettier test.cjstest.cjs[error] No parser could be inferred for file: test.cjs(補足).cjs について大雑把に解説しておきます。Node.js は CommonJS と ECMAScript Modules という２つのモジュールシステムをサポートしていて、あるファイルがそのどちらのモジュールシステムを使って書かれているのかを Node.js になんらかの方法で伝える必要があります。その方法の1つがファイル拡張子であり、.cjsの場合は CommonJS、.mjsの場合は ECMAScript Modules となります。詳しく知りたい人は https://nodejs.org/api/esm.html を読んでください。Prettier Pluginshttps://prettier.io/docs/en/plugins.htmlPrettier にはプラグインという機能があり、コアで対応できていない言語でも外部のプラグインとして対応できます。例えば、GitHub の Prettier オーガナイゼーション下には https://github.com/prettier/plugin-php や https://github.com/prettier/plugin-ruby といったプラグインが存在しており、コミュニティによって管理されています。Prettier のプラグインは次の５つを named export することで実装できます。(optionsとdefaultOptionsは必須ではなかった気がする)languagesparsersprintersoptionsdefaultOptionsこのlanguagesというのは、当然ですが決められた形をしたオブジェクトの配列で、そのオブジェクトにはextensionsというプロパティを含めることができます。そしてextensionsに渡す配列で、言語と拡張子の対応付け行っています。実は、JavaScript や HTML などのコアでサポートしている言語も、内部的にはプラグインとして実装されています。(これらは Prettier のソースコード内ではinternalPluginsと呼ばれています。)https://github.com/prettier/prettier/blob/master/src/common/internal-plugins.jsなので、前述のlanguagesはコアでサポートしている言語にも存在し、extensionsも存在します。linguist-languagesinternalPluginsの実装を読むと、extensionsはlinguist-languagesというライブラリからひっぱってきていることがわかります。どうりでどれだけ grep してもヒットしないわけです。ソースコードに含まれていないのですから。https://github.com/prettier/prettier/blob/master/src/language-js/index.js#L9これは Prettier のメンテナの一人であるika 氏が、github/linguistのlanguages.yamlを JSON に自動でフォーマットしたものみたいです。本家 linguist の.cjs追加は、https://github.com/github/linguist/pull/4703 で行われており、それに追従したlinguist-languagesが v7.7 としてリリースされていました。(Prettier が依存しているのは 7.6)つまり、依存しているlinguist-langagesのバージョンを 7.6=>7.7 にしたら直ったよっていう話でした。","link":"https://sosukesuzuki.dev/posts/prettier-infer-parser-from-filepath/","isoDate":"2020-01-05T00:00:00.000Z","dateMiliSeconds":1578182400000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"},{"title":"2019 やったこと","contentSnippet":"昨年から引き続きですが、ずっと JavaScript か TypeScript を書いていました。先にまとめ18 歳になった筑波大学に入学したOSS 活動を再開して Prettier のコミッターになった勉強会で発表したUbie でフロントエンドの開発をしてます18 歳になった誕生日おめでとう自分— sosukesuzuki (@__sosukesuzuki) February 28, 2019 今年も 3 月に誕生日を迎え、18 歳になりました。祝ってくれた方々はありがとうございました。次の 3 月で 19 歳になります。筑波大学に入学した筑波大学情報学群情報科学類、合格！ｗ— sosukesuzuki (@__sosukesuzuki) October 19, 2018 筑波大学の情報学群情報科学類というところに入りました。わかりきっていたことですが、数学はできないし授業に出るのもできてなくて苦しいですが、友人はおもしろい人ばかりなのでなんだかんだ楽しく生きてます。学園祭実行委員会の情報っぽい部門に入ってたまにウェブアプリ書いたりウェブサイト作るお手伝いとかもやっていました。学園祭実行委員会は主に 2 年生が動くことになるので、来年はもっと開発や他のもろもろをやっていくことになると思います。OSS 活動を再開して Prettier のコミッターになったPrettier のコミット権限をもらったので、コミッタになりましたhttps://t.co/ZBNu13rM7s— sosukesuzuki (@__sosukesuzuki) September 28, 2019 高校 1~2 年生のときにBoostnoteのメンテナンスをやってたとき以来だと思いますが、本格的に OSS 活動を再開して、9 月末くらいに Prettier のコミッターになりました。僕の今年のコミット数は現時点(2019/12/21)で 39 コミットなのでそこまで多いわけではないんですが、Prettier はアクティブメンバーが少ないので 2019 年では 3 番目に多いことになります(通算では 13 番目)。Issue のトリアージや PR のレビュー等をしつつ、フォーマットのバグを直したり、たまにリファクタリングしたり、CI が壊れてるの直したり色々していました。Prettier で作業していると AST とにらめっこしたり依存している各パーサー(@babel/parser とか @typescript-eslint/estree とか)のバグとも戦ったりするので、JavaScript/TypeScript のシンタックスにそれなりに詳しくなれたんじゃないかなと思っています。今年は JavaScript/TypeScript の部分しか見られなかったので来年は CSS とか HTML あたりもやっていこうかなと思っています。勉強会で発表した昨年までは身内以外の勉強会とかで発表したことがなかったんですが、今年は何回か発表してみました。僕が知ってるような知識って大体の人が知ってるような気がしていたのでいままで発表するのを躊躇ってたんですが、 Prettier のコミッターって(多分)日本にいないのでそういう話をしていました。We Are JavaScripters!、Ginza.js、Nihonbashi.jsで発表させていただきました。運営の方々ありがとうございました。こうした発表を通じてエンジニアの知り合いができたのも嬉しかったです。来年はカンファレンスとかで発表できたらいいなと思っています。Ubie でフロントエンドの開発をしてます2018 年 12 月からインターンで参加している Ubie で、今年もずっと働いていました。最近はチームメンバーも給料も増えてきました。基本的には茨城からリモートで働きつつ、たまーに三越前のオフィスまで出社しています。具体的には、toC のウェブサービスの開発を Nuxt.js と TypeScript でやってます。まだオープンになっておらず、鋭意開発中のプロダクトです。機能追加やバグ修正など、コードを書く仕事をたくさんしつつ、エラー対応とかデプロイフローの改善とか Linter の整備とか(その一貫で@typescript-eslint にコントリビュートしたり)フロントエンド周りで色々と必要なことをたくさんやっていました。","link":"https://sosukesuzuki.dev/posts/2019-what-i-did/","isoDate":"2019-12-22T00:00:00.000Z","dateMiliSeconds":1576972800000,"authorName":"sosukesuzuki","authorId":"sosukesuzuki"}]},"__N_SSG":true}